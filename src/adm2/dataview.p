&ANALYZE-SUSPEND _VERSION-NUMBER AB_v10r12
&ANALYZE-RESUME
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CUSTOM _DEFINITIONS Procedure 
/**********************************************************************************/
/* Copyright (C) 2005,2006 by Progress Software Corporation. All rights reserved. */
/* Prior versions of this work may contain portions contributed by participants   */      
/* of Possenet.                                                                   */               
/******************************************************************************/
/*--------------------------------------------------------------------------
    File        : dataview.p
    Purpose     : Super procedure for dataview class.

    Syntax      : RUN start-super-proc("adm2/dataview.p":U).

    Created     : 03/01/2005
  ------------------------------------------------------------------------*/
/*          This .W file was created with the Progress UIB.             */
/*----------------------------------------------------------------------*/

/* ***************************  Definitions  ************************** */

DEFINE VARIABLE ghDataContainer AS HANDLE     NO-UNDO.

&SCOP ADMSuper dataview.p

/* Custom exclude file */

{src/adm2/custom/dataviewexclcustom.i}

{src/adm2/ttsdoout.i}
{src/adm2/schemai.i}

&SCOPED-DEFINE MaxBreaks 16  /* core limit on number of BY  */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-PREPROCESSOR-BLOCK 

/* ********************  Preprocessor Definitions  ******************** */

&Scoped-define PROCEDURE-TYPE Procedure
&Scoped-define DB-AWARE no



/* _UIB-PREPROCESSOR-BLOCK-END */
&ANALYZE-RESUME


/* ************************  Function Prototypes ********************** */

&IF DEFINED(EXCLUDE-activateHiddenFetchChildren) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD activateHiddenFetchChildren Procedure 
FUNCTION activateHiddenFetchChildren RETURNS CHARACTER PRIVATE
  (   )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-addDatasetClone) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD addDatasetClone Procedure 
FUNCTION addDatasetClone RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-addDatasetSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD addDatasetSource Procedure 
FUNCTION addDatasetSource RETURNS LOGICAL
  (   )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-addForeignKey) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD addForeignKey Procedure 
FUNCTION addForeignKey RETURNS LOGICAL
  ( )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-addRow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD addRow Procedure 
FUNCTION addRow RETURNS CHARACTER
  ( pcViewColList AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-applyContextFromServer) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD applyContextFromServer Procedure 
FUNCTION applyContextFromServer RETURNS LOGICAL
  ( pcContext AS CHAR)  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-assignColumnColumnLabel) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD assignColumnColumnLabel Procedure 
FUNCTION assignColumnColumnLabel RETURNS LOGICAL
  ( pcColumn      AS CHARACTER,
    pcColumnLabel AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-assignColumnFormat) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD assignColumnFormat Procedure 
FUNCTION assignColumnFormat RETURNS LOGICAL
  ( pcColumn AS CHARACTER,
    pcFormat AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-assignColumnHelp) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD assignColumnHelp Procedure 
FUNCTION assignColumnHelp RETURNS LOGICAL
  ( pcColumn AS CHARACTER,
    pcHelp   AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-assignColumnLabel) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD assignColumnLabel Procedure 
FUNCTION assignColumnLabel RETURNS LOGICAL
  ( pcColumn AS CHARACTER,
    pcLabel  AS CHARACTER)  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-assignColumnPrivateData) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD assignColumnPrivateData Procedure 
FUNCTION assignColumnPrivateData RETURNS LOGICAL
  ( pcColumn      AS CHARACTER, 
    pcPrivateData AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-assignQuerySelection) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD assignQuerySelection Procedure 
FUNCTION assignQuerySelection RETURNS LOGICAL
  (pcColumns   AS CHARACTER,   
   pcValues    AS CHARACTER,    
   pcOperators AS CHARACTER) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-bufferWhereClause) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD bufferWhereClause Procedure 
FUNCTION bufferWhereClause RETURNS CHARACTER
  (pcBuffer AS CHAR,
   pcWhere  AS CHAR)  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-cancelRow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD cancelRow Procedure 
FUNCTION cancelRow RETURNS CHARACTER
  ( )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-canNavigate) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD canNavigate Procedure 
FUNCTION canNavigate RETURNS LOGICAL
  ( )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-childForeignFields) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD childForeignFields Procedure 
FUNCTION childForeignFields RETURNS CHARACTER
  ( pcChild AS CHAR )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-closeQuery) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD closeQuery Procedure 
FUNCTION closeQuery RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnColumnLabel) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD columnColumnLabel Procedure 
FUNCTION columnColumnLabel RETURNS CHARACTER
  ( pcColumn AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnDataType) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD columnDataType Procedure 
FUNCTION columnDataType RETURNS CHARACTER
  ( pcColumn AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnDefaultValue) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD columnDefaultValue Procedure 
FUNCTION columnDefaultValue RETURNS CHARACTER
  ( pcColumn AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnFormat) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD columnFormat Procedure 
FUNCTION columnFormat RETURNS CHARACTER
  ( pcColumn AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnHandle) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD columnHandle Procedure 
FUNCTION columnHandle RETURNS HANDLE
  ( pcColumn AS CHAR)  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnHelp) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD columnHelp Procedure 
FUNCTION columnHelp RETURNS CHARACTER
  ( pcColumn AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnInitial) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD columnInitial Procedure 
FUNCTION columnInitial RETURNS CHARACTER
  ( pcColumn AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnLabel) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD columnLabel Procedure 
FUNCTION columnLabel RETURNS CHARACTER
  ( pcColumn AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnLongCharValue) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD columnLongCharValue Procedure 
FUNCTION columnLongCharValue RETURNS LONGCHAR
  ( pcColumn AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnName) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD columnName Procedure 
FUNCTION columnName RETURNS CHARACTER
  ( phHandle AS HANDLE)  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnPrivateData) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD columnPrivateData Procedure 
FUNCTION columnPrivateData RETURNS CHARACTER
  ( pcColumn AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnQuerySelection) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD columnQuerySelection Procedure 
FUNCTION columnQuerySelection RETURNS CHARACTER
  ( pcColumn AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnReadOnly) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD columnReadOnly Procedure 
FUNCTION columnReadOnly RETURNS LOGICAL
  ( pcColumn AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnStringValue) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD columnStringValue Procedure 
FUNCTION columnStringValue RETURNS CHARACTER
  ( pcColumn AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnTable) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD columnTable Procedure 
FUNCTION columnTable RETURNS CHAR
  ( pcColumn AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnValue) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD columnValue Procedure 
FUNCTION columnValue RETURNS CHARACTER
  ( pcColumn AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnWidth) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD columnWidth Procedure 
FUNCTION columnWidth RETURNS DECIMAL
  ( pcColumn AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-colValues) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD colValues Procedure 
FUNCTION colValues RETURNS CHARACTER
  ( pcViewColList AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-copyLargeColumnToFile) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD copyLargeColumnToFile Procedure 
FUNCTION copyLargeColumnToFile RETURNS LOGICAL
  ( pcColumn   AS CHAR,
    pcFileName AS CHARACTER)  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-copyLargeColumnToMemptr) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD copyLargeColumnToMemptr Procedure 
FUNCTION copyLargeColumnToMemptr RETURNS LOGICAL
  ( pcColumn AS CHAR,
    pmMemptr AS MEMPTR)  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-copyRow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD copyRow Procedure 
FUNCTION copyRow RETURNS CHARACTER
  ( pcViewColList AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-deleteRow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD deleteRow Procedure 
FUNCTION deleteRow RETURNS LOGICAL
  ( pcRowIdent AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-destroyView) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD destroyView Procedure 
FUNCTION destroyView RETURNS LOGICAL
  ( /* parameter-definitions */ )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-findRow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD findRow Procedure 
FUNCTION findRow RETURNS LOGICAL
  (pcKeyValues AS CHAR)  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-findRowObjectUseRowIdent) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD findRowObjectUseRowIdent Procedure 
FUNCTION findRowObjectUseRowIdent RETURNS LOGICAL
  ( INPUT pcRowIdent AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-findRowObjectWhere) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD findRowObjectWhere Procedure 
FUNCTION findRowObjectWhere RETURNS LOGICAL
  (pcColumns     AS CHARACTER,   
   pcValues      AS CHARACTER,    
   pcOperators   AS CHARACTER,
   pcMode        AS CHARACTER) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-findRowWhere) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD findRowWhere Procedure 
FUNCTION findRowWhere RETURNS LOGICAL
  (pcColumns     AS CHARACTER,   
   pcValues      AS CHARACTER,    
   pcOperators   AS CHARACTER) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-findUniqueRowWhere) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD findUniqueRowWhere Procedure 
FUNCTION findUniqueRowWhere RETURNS LOGICAL
  (pcColumns     AS CHARACTER,   
   pcValues      AS CHARACTER,    
   pcOperators   AS CHARACTER) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-firstRowids) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD firstRowids Procedure 
FUNCTION firstRowids RETURNS CHARACTER
  (pcQueryString AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getAuditEnabled) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getAuditEnabled Procedure 
FUNCTION getAuditEnabled RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getAutoCommit) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getAutoCommit Procedure 
FUNCTION getAutoCommit RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getBLOBColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getBLOBColumns Procedure 
FUNCTION getBLOBColumns RETURNS CHARACTER
  ( )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getBufferHandles) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getBufferHandles Procedure 
FUNCTION getBufferHandles RETURNS CHARACTER
  ( /* parameter-definitions */ )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getBusinessEntity) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getBusinessEntity Procedure 
FUNCTION getBusinessEntity RETURNS CHARACTER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getCLOBColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getCLOBColumns Procedure 
FUNCTION getCLOBColumns RETURNS CHARACTER
  ( )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getCommitSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getCommitSource Procedure 
FUNCTION getCommitSource RETURNS HANDLE
  ( )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getCommitSourceEvents) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getCommitSourceEvents Procedure 
FUNCTION getCommitSourceEvents RETURNS CHARACTER
(  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getCommitTarget) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getCommitTarget Procedure 
FUNCTION getCommitTarget RETURNS CHARACTER
  ( )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getCommitTargetEvents) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getCommitTargetEvents Procedure 
FUNCTION getCommitTargetEvents RETURNS CHARACTER
(  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getCurrentUpdateSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getCurrentUpdateSource Procedure 
FUNCTION getCurrentUpdateSource RETURNS HANDLE
(  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getDataColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getDataColumns Procedure 
FUNCTION getDataColumns RETURNS CHARACTER
  ( )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getDataContainerHandle) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getDataContainerHandle Procedure 
FUNCTION getDataContainerHandle RETURNS HANDLE
  ( )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getDataHandle) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getDataHandle Procedure 
FUNCTION getDataHandle RETURNS HANDLE
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getDataIsFetched) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getDataIsFetched Procedure 
FUNCTION getDataIsFetched RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getDataModified) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getDataModified Procedure 
FUNCTION getDataModified RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getDataQueryBrowsed) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getDataQueryBrowsed Procedure 
FUNCTION getDataQueryBrowsed RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getDataQueryString) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getDataQueryString Procedure 
FUNCTION getDataQueryString RETURNS CHARACTER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getDatasetName) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getDatasetName Procedure 
FUNCTION getDatasetName RETURNS CHARACTER
  ( )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getDatasetSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getDatasetSource Procedure 
FUNCTION getDatasetSource RETURNS HANDLE
  ( )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getDataTable) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getDataTable Procedure 
FUNCTION getDataTable RETURNS CHARACTER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getFetchOnOpen) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getFetchOnOpen Procedure 
FUNCTION getFetchOnOpen RETURNS CHARACTER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getFillBatchOnRepos) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getFillBatchOnRepos Procedure 
FUNCTION getFillBatchOnRepos RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getFilterActive) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getFilterActive Procedure 
FUNCTION getFilterActive RETURNS LOGICAL
  ( /* parameter-definitions */ )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getFilterAvailable) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getFilterAvailable Procedure 
FUNCTION getFilterAvailable RETURNS LOGICAL
  ( /* parameter-definitions */ )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getFilterSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getFilterSource Procedure 
FUNCTION getFilterSource RETURNS HANDLE
  ( )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getFilterWindow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getFilterWindow Procedure 
FUNCTION getFilterWindow RETURNS CHARACTER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getFirstRowNum) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getFirstRowNum Procedure 
FUNCTION getFirstRowNum RETURNS INTEGER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getForeignFields) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getForeignFields Procedure 
FUNCTION getForeignFields RETURNS CHARACTER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getForeignValues) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getForeignValues Procedure 
FUNCTION getForeignValues RETURNS CHARACTER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getHasFirst) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getHasFirst Procedure 
FUNCTION getHasFirst RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getHasLast) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getHasLast Procedure 
FUNCTION getHasLast RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getIndexInformation) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getIndexInformation Procedure 
FUNCTION getIndexInformation RETURNS CHARACTER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getKeyFields) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getKeyFields Procedure 
FUNCTION getKeyFields RETURNS CHARACTER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getKeyTableId) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getKeyTableId Procedure 
FUNCTION getKeyTableId RETURNS CHARACTER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getKeyWhere) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getKeyWhere Procedure 
FUNCTION getKeyWhere RETURNS CHARACTER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getLargeColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getLargeColumns Procedure 
FUNCTION getLargeColumns RETURNS CHARACTER
  ( )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getLastRowNum) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getLastRowNum Procedure 
FUNCTION getLastRowNum RETURNS INTEGER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getNavigationSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getNavigationSource Procedure 
FUNCTION getNavigationSource RETURNS CHAR
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getNavigationSourceEvents) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getNavigationSourceEvents Procedure 
FUNCTION getNavigationSourceEvents RETURNS CHARACTER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getNewMode) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getNewMode Procedure 
FUNCTION getNewMode RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getNewRow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getNewRow Procedure 
FUNCTION getNewRow RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getOpenOnInit) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getOpenOnInit Procedure 
FUNCTION getOpenOnInit RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getPositionSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getPositionSource Procedure 
FUNCTION getPositionSource RETURNS HANDLE
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getPrimarySDOSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getPrimarySDOSource Procedure 
FUNCTION getPrimarySDOSource RETURNS HANDLE
  ( )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getPromptColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getPromptColumns Procedure 
FUNCTION getPromptColumns RETURNS CHARACTER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getPromptOnDelete) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getPromptOnDelete Procedure 
FUNCTION getPromptOnDelete RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getQueryColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getQueryColumns Procedure 
FUNCTION getQueryColumns RETURNS CHARACTER
  ( /* parameter-definitions */ )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getQueryHandle) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getQueryHandle Procedure 
FUNCTION getQueryHandle RETURNS HANDLE
  ( /* parameter-definitions */ )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getQueryOpen) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getQueryOpen Procedure 
FUNCTION getQueryOpen RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getQueryPosition) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getQueryPosition Procedure 
FUNCTION getQueryPosition RETURNS CHARACTER
  (   )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getQuerySort) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getQuerySort Procedure 
FUNCTION getQuerySort RETURNS CHARACTER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getQuerySortDefault) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getQuerySortDefault Procedure 
FUNCTION getQuerySortDefault RETURNS CHARACTER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getQueryString) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getQueryString Procedure 
FUNCTION getQueryString RETURNS CHARACTER
  ( )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getQueryStringDefault) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getQueryStringDefault Procedure 
FUNCTION getQueryStringDefault RETURNS CHARACTER
  (   )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getQueryTables) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getQueryTables Procedure 
FUNCTION getQueryTables RETURNS CHARACTER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getRebuildOnRepos) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getRebuildOnRepos Procedure 
FUNCTION getRebuildOnRepos RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getRequestHandle) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getRequestHandle Procedure 
FUNCTION getRequestHandle RETURNS HANDLE
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getRowident) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getRowident Procedure 
FUNCTION getRowident RETURNS CHARACTER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getRowObject) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getRowObject Procedure 
FUNCTION getRowObject RETURNS HANDLE
  ( )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getRowObjectState) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getRowObjectState Procedure 
FUNCTION getRowObjectState RETURNS CHARACTER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getRowsToBatch) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getRowsToBatch Procedure 
FUNCTION getRowsToBatch RETURNS INTEGER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getScrollable) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getScrollable Procedure 
FUNCTION getScrollable RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getTables) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getTables Procedure 
FUNCTION getTables RETURNS CHARACTER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getToggleDataTargets) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getToggleDataTargets Procedure 
FUNCTION getToggleDataTargets RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getTransferChildrenForAll) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getTransferChildrenForAll Procedure 
FUNCTION getTransferChildrenForAll RETURNS LOGICAL
  (   )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getUpdatableColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getUpdatableColumns Procedure 
FUNCTION getUpdatableColumns RETURNS CHARACTER
  (   )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getUpdateSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getUpdateSource Procedure 
FUNCTION getUpdateSource RETURNS CHARACTER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getUseDBQualifier) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getUseDBQualifier Procedure 
FUNCTION getUseDBQualifier RETURNS LOGICAL
  ( /* parameter-definitions */ )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getViewTables) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getViewTables Procedure 
FUNCTION getViewTables RETURNS CHARACTER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getWordIndexedFields) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD getWordIndexedFields Procedure 
FUNCTION getWordIndexedFields RETURNS CHARACTER
  ( )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-hasActiveAudit) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD hasActiveAudit Procedure 
FUNCTION hasActiveAudit RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-hasActiveComments) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD hasActiveComments Procedure 
FUNCTION hasActiveComments RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-hasForeignKeyChanged) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD hasForeignKeyChanged Procedure 
FUNCTION hasForeignKeyChanged RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-indexInformation) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD indexInformation Procedure 
FUNCTION indexInformation RETURNS CHARACTER
   (pcQuery       AS CHAR,
    plUseTableSep AS LOG,
    pcIndexInfo   AS CHAR) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-insertExpression) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD insertExpression Procedure 
FUNCTION insertExpression RETURNS CHARACTER
  (pcWhere      AS CHAR,   
   pcExpression AS CHAR,     
   pcAndOr      AS CHAR) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-instanceOf) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD instanceOf Procedure 
FUNCTION instanceOf RETURNS LOGICAL
    ( INPUT pcClass AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-isDataQueryComplete) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD isDataQueryComplete Procedure 
FUNCTION isDataQueryComplete RETURNS LOGICAL
  ( /* parameter-definitions */ )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-keyWhere) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD keyWhere Procedure 
FUNCTION keyWhere RETURNS CHARACTER
 (phBuffer AS HANDLE,
  pcQual   AS CHAR ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-newQuerySort) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD newQuerySort Procedure 
FUNCTION newQuerySort RETURNS CHARACTER
  ( pcQuery       AS CHAR,
    pcSort        AS CHAR)  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-newQueryString) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD newQueryString Procedure 
FUNCTION newQueryString RETURNS CHARACTER
  (pcColumns     AS CHARACTER,   
   pcValues      AS CHARACTER,    
   pcOperators   AS CHARACTER,
   pcQueryString AS CHARACTER,
   pcAndOr       AS CHARACTER) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-newWhereClause) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD newWhereClause Procedure 
FUNCTION newWhereClause RETURNS CHARACTER
  (pcBuffer     AS CHAR,   
   pcExpression AS char,  
   pcWhere      AS CHAR,
   pcAndOr      AS CHAR) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-obtainContextForServer) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD obtainContextForServer Procedure 
FUNCTION obtainContextForServer RETURNS CHARACTER
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-openDataQuery) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD openDataQuery Procedure 
FUNCTION openDataQuery RETURNS LOGICAL
  (pcPosition AS CHAR) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-openDataView) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD openDataView Procedure 
FUNCTION openDataView RETURNS LOGICAL
  (   )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-openQuery) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD openQuery Procedure 
FUNCTION openQuery RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-openQueryAtPosition) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD openQueryAtPosition Procedure 
FUNCTION openQueryAtPosition RETURNS LOGICAL
  ( pcPosition AS CHAR  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-refreshQuery) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD refreshQuery Procedure 
FUNCTION refreshQuery RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-removeDatasetClone) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD removeDatasetClone Procedure 
FUNCTION removeDatasetClone RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-removeForeignKey) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD removeForeignKey Procedure 
FUNCTION removeForeignKey RETURNS LOGICAL
  ( )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-removeQuerySelection) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD removeQuerySelection Procedure 
FUNCTION removeQuerySelection RETURNS LOGICAL
  (pcColumns   AS CHARACTER,
   pcOperators AS CHARACTER) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-repositionRowObject) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD repositionRowObject Procedure 
FUNCTION repositionRowObject RETURNS LOGICAL
     ( pcRowIdent AS CHARACTER ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-resetQueryString) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD resetQueryString Procedure 
FUNCTION resetQueryString RETURNS LOGICAL
  (   )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-resetRow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD resetRow Procedure 
FUNCTION resetRow RETURNS LOGICAL
  ( pcRowident AS CHAR )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-resolveBuffer) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD resolveBuffer Procedure 
FUNCTION resolveBuffer RETURNS CHARACTER
  ( pcBuffer AS CHAR )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-resolveColumn) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD resolveColumn Procedure 
FUNCTION resolveColumn RETURNS CHARACTER
  ( pcColumn AS CHAR )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-resortQuery) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD resortQuery Procedure 
FUNCTION resortQuery RETURNS LOGICAL
  ( pcSort AS CHARACTER  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-retrieveBatch) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD retrieveBatch Procedure 
FUNCTION retrieveBatch RETURNS LOGICAL
  ( pcMode AS CHAR,
    piNumRows AS INT )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-retrieveData) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD retrieveData Procedure 
FUNCTION retrieveData RETURNS LOGICAL
  ( pcMode AS CHAR,
    plRefresh AS LOG,
    piNumRows AS INT)  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-rowAvailable) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD rowAvailable Procedure 
FUNCTION rowAvailable RETURNS LOGICAL
  ( pcDirection  AS CHAR )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-rowValues) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD rowValues Procedure 
FUNCTION rowValues RETURNS CHARACTER
  ( pcColumns   AS CHAR,
    pcFormat    AS CHAR,
    pcDelimiter AS CHAR)  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setAutoCommit) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setAutoCommit Procedure 
FUNCTION setAutoCommit RETURNS LOGICAL
  ( plAutoCommit AS LOGICAL )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setBufferHandles) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setBufferHandles Procedure 
FUNCTION setBufferHandles RETURNS LOGICAL
  ( pcBufferHandles AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setBusinessEntity) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setBusinessEntity Procedure 
FUNCTION setBusinessEntity RETURNS LOGICAL
  ( pcBusinessEntity AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setCommitSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setCommitSource Procedure 
FUNCTION setCommitSource RETURNS LOGICAL
  ( phObject AS HANDLE )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setCommitSourceEvents) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setCommitSourceEvents Procedure 
FUNCTION setCommitSourceEvents RETURNS LOGICAL
  ( pcEvents AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setCommitTarget) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setCommitTarget Procedure 
FUNCTION setCommitTarget RETURNS LOGICAL
  ( pcObject AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setCommitTargetEvents) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setCommitTargetEvents Procedure 
FUNCTION setCommitTargetEvents RETURNS LOGICAL
  ( pcEvents AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setCurrentUpdateSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setCurrentUpdateSource Procedure 
FUNCTION setCurrentUpdateSource RETURNS LOGICAL
( phSource AS HANDLE )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setDataColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setDataColumns Procedure 
FUNCTION setDataColumns RETURNS LOGICAL
  ( pcColumns AS CHAR)  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setDataIsFetched) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setDataIsFetched Procedure 
FUNCTION setDataIsFetched RETURNS LOGICAL
  ( plFetched AS LOG)  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setDataModified) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setDataModified Procedure 
FUNCTION setDataModified RETURNS LOGICAL
  ( plDataModified AS LOGICAL )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setDataQueryBrowsed) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setDataQueryBrowsed Procedure 
FUNCTION setDataQueryBrowsed RETURNS LOGICAL
  ( plBrowsed AS LOGICAL )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setDataQueryString) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setDataQueryString Procedure 
FUNCTION setDataQueryString RETURNS LOGICAL
  (pcQueryString AS CHARACTER)  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setDatasetName) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setDatasetName Procedure 
FUNCTION setDatasetName RETURNS LOGICAL
  ( pcName AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setDatasetSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setDatasetSource Procedure 
FUNCTION setDatasetSource RETURNS LOGICAL
  ( phSource AS HANDLE )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setDataTable) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setDataTable Procedure 
FUNCTION setDataTable RETURNS LOGICAL
  ( pcDataTable AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setFetchOnOpen) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setFetchOnOpen Procedure 
FUNCTION setFetchOnOpen RETURNS LOGICAL
  ( pcFetchOnOpen AS CHAR )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setFillBatchOnRepos) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setFillBatchOnRepos Procedure 
FUNCTION setFillBatchOnRepos RETURNS LOGICAL
  ( plFlag AS LOGICAL )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setFilterActive) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setFilterActive Procedure 
FUNCTION setFilterActive RETURNS LOGICAL
  ( plFilterActive AS LOGICAL )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setFilterAvailable) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setFilterAvailable Procedure 
FUNCTION setFilterAvailable RETURNS LOGICAL
  ( plFilterAvailable AS LOGICAL )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setFilterSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setFilterSource Procedure 
FUNCTION setFilterSource RETURNS LOGICAL
  ( phObject AS HANDLE )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setFilterWindow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setFilterWindow Procedure 
FUNCTION setFilterWindow RETURNS LOGICAL
  ( pcObject AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setFirstRowNum) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setFirstRowNum Procedure 
FUNCTION setFirstRowNum RETURNS LOGICAL
  ( piRowNum AS INTEGER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setForeignFields) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setForeignFields Procedure 
FUNCTION setForeignFields RETURNS LOGICAL
  ( pcFields AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setForeignValues) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setForeignValues Procedure 
FUNCTION setForeignValues RETURNS LOGICAL
  ( pcValues AS CHAR )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setIndexInformation) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setIndexInformation Procedure 
FUNCTION setIndexInformation RETURNS LOGICAL
  (pcInfo AS CHAR)  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setLargeColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setLargeColumns Procedure 
FUNCTION setLargeColumns RETURNS LOGICAL
  ( pcLargeColumns AS CHAR)  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setLastRowNum) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setLastRowNum Procedure 
FUNCTION setLastRowNum RETURNS LOGICAL
  ( piLastRowNum AS INTEGER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setNavigationSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setNavigationSource Procedure 
FUNCTION setNavigationSource RETURNS LOGICAL
  ( pcObject AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setOpenOnInit) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setOpenOnInit Procedure 
FUNCTION setOpenOnInit RETURNS LOGICAL
  ( plOpen AS LOGICAL )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setPrimarySDOSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setPrimarySDOSource Procedure 
FUNCTION setPrimarySDOSource RETURNS LOGICAL
  ( phObject AS HANDLE )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setPromptColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setPromptColumns Procedure 
FUNCTION setPromptColumns RETURNS LOGICAL
  (INPUT pcPromptColumns AS CHARACTER)  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setPromptOnDelete) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setPromptOnDelete Procedure 
FUNCTION setPromptOnDelete RETURNS LOGICAL
  (INPUT plPrompt AS LOGICAL)  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setQueryColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setQueryColumns Procedure 
FUNCTION setQueryColumns RETURNS LOGICAL
  ( cQueryColumns AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setQueryPosition) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setQueryPosition Procedure 
FUNCTION setQueryPosition RETURNS LOGICAL
  ( pcPosition AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setQuerySort) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setQuerySort Procedure 
FUNCTION setQuerySort RETURNS LOGICAL
  ( pcSort AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setQueryString) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setQueryString Procedure 
FUNCTION setQueryString RETURNS LOGICAL
  (pcQueryString AS CHAR)  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setRebuildOnRepos) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setRebuildOnRepos Procedure 
FUNCTION setRebuildOnRepos RETURNS LOGICAL
  ( plRebuild AS LOGICAL )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setRowObject) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setRowObject Procedure 
FUNCTION setRowObject RETURNS LOGICAL
  ( phRowObject AS HANDLE )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setRowObjectState) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setRowObjectState Procedure 
FUNCTION setRowObjectState RETURNS LOGICAL
  ( pcState AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setRowsToBatch) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setRowsToBatch Procedure 
FUNCTION setRowsToBatch RETURNS LOGICAL
  ( piRows AS INTEGER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setTables) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setTables Procedure 
FUNCTION setTables RETURNS LOGICAL
  ( pcTables AS CHAR)  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setToggleDataTargets) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setToggleDataTargets Procedure 
FUNCTION setToggleDataTargets RETURNS LOGICAL
  ( plToggleDataTargets AS LOGICAL )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setTransferChildrenForAll) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setTransferChildrenForAll Procedure 
FUNCTION setTransferChildrenForAll RETURNS LOGICAL
  (plTransferChildrenForAll AS LOGICAL)  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setUpdatableColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setUpdatableColumns Procedure 
FUNCTION setUpdatableColumns RETURNS LOGICAL
  (pcColumns AS CHAR)  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setUpdateSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD setUpdateSource Procedure 
FUNCTION setUpdateSource RETURNS LOGICAL
  ( pcObject AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-showBI) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD showBI Procedure 
FUNCTION showBI RETURNS LOGICAL
  ( /* parameter-definitions */ )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-sortExpression) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD sortExpression Procedure 
FUNCTION sortExpression RETURNS CHARACTER
  ( pcQueryString AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-submitData) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD submitData Procedure 
FUNCTION submitData RETURNS LOGICAL
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-submitRow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD submitRow Procedure 
FUNCTION submitRow RETURNS LOGICAL
  ( pcRowIdent AS CHARACTER, pcValueList AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-undoRow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD undoRow Procedure 
FUNCTION undoRow RETURNS LOGICAL
  ( pcRowident AS CHAR )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-updateLargeColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD updateLargeColumns Procedure 
FUNCTION updateLargeColumns RETURNS LOGICAL PRIVATE
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-whereClauseBuffer) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-EXTERNAL whereClauseBuffer Procedure 
FUNCTION whereClauseBuffer RETURNS CHARACTER
  (pcWhere AS CHAR):
/*------------------------------------------------------------------------------
  Purpose:     Returns the buffername of a where clause expression. 
               This function avoids problems with leading or double blanks in 
               where clauses.
  Parameters:
    pcWhere - Complete where clause for ONE table with or without the FOR 
              keyword. The buffername must be the second token in the
              where clause as in "EACH order OF Customer" or if "FOR" is
              specified, the third token as in "FOR EACH order".
  
  Notes:      Used internally in query.p.
------------------------------------------------------------------------------*/
  pcWhere = LEFT-TRIM(pcWhere).
  
  /* Remove double blanks */
  DO WHILE INDEX(pcWhere,"  ":U) > 0:
    pcWhere = REPLACE(pcWhere,"  ":U," ":U).
  END.
  /* Get rid of potential line break characters */   
  pcWhere = REPLACE(pcWhere,CHR(10),'':U). 

  RETURN (IF NUM-ENTRIES(pcWhere," ":U) > 1 
          THEN ENTRY(IF pcWhere BEGINS "FOR ":U THEN 3 ELSE 2,pcWhere," ":U)
          ELSE "":U).
  
END.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF


/* *********************** Procedure Settings ************************ */

&ANALYZE-SUSPEND _PROCEDURE-SETTINGS
/* Settings for THIS-PROCEDURE
   Type: Procedure
   Allow: 
   Frames: 0
   Add Fields to: Neither
   Other Settings: CODE-ONLY COMPILE
 */
&ANALYZE-RESUME _END-PROCEDURE-SETTINGS

/* *************************  Create Window  ************************** */

&ANALYZE-SUSPEND _CREATE-WINDOW
/* DESIGN Window definition (used by the UIB) 
  CREATE WINDOW Procedure ASSIGN
         HEIGHT             = 27.29
         WIDTH              = 55.2.
/* END WINDOW DEFINITION */
                                                                        */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CUSTOM _INCLUDED-LIB Procedure 
/* ************************* Included-Libraries *********************** */

{src/adm2/dataviewprop.i}

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


 


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CUSTOM _MAIN-BLOCK Procedure 


/* ***************************  Main Block  *************************** */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


/* **********************  Internal Procedures  *********************** */

&IF DEFINED(EXCLUDE-buildDataRequest) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE buildDataRequest Procedure 
PROCEDURE buildDataRequest :
/*------------------------------------------------------------------------------
Purpose:      Build request info to be used as parameters for data 
              retrieval. 
Parameters: 
   phOwner   - The object that initiated this request.     
   pcDataSource    
             - Data source entity name in the case this request is from
               a data source. 
               This means that foreignfields need to be collected.
   pcViewerSource  
             - Viewer's data source entity name in the case 
               this request is passed through a containing viewer. 
               This means that this object probably has a link to an 
               SDF and position info need to be collected. The object
               may still be a child of another object on the viewer so 
               foreignfields are also collected. 
  INPUT-OUTPUT pcRequests   
  INPUT-OUTPUT pcHandles    
  INPUT-OUTPUT pcDataTables 
  INPUT-OUTPUT pcQueries  
  INPUT-OUTPUT pcBatchSizes  
  INPUT-OUTPUT pcForeignFields  
              - Semi-colon separeted list of foreign values.
                The other object's (parent) field is qualified with 
                entity if different than this object's entity.
                The order is child,parent as stored in the property,
                opposite of how it is used in a prodataset relation
  INPUT-OUTPUT pcPositionFields
              - semi-colon separeted list of position foreign values.
                (A single child relation on which smartviewer this 
                 object is dropped to lookup this table with an SDF)
                The other object's (child) field is qualified with 
                entity if different than this object's entity.
                The order is parent,child because... eh.. well..hmm
                it is similar to the foreignvalues in that THIS field
                is first and that it is opposite of how it is used in 
                a prodataset relation.    
  input-output pccontext              
        -- dataset information ---                                              
  
  INPUT-OUTPUT pcDatasetSources
  INPUT-OUTPUT pcEntities
  INPUT-OUTPUT pcEntityNames   
  
  Notes:    The requesting container will publish this or the object will 
            run this in itself before data retrieval.
            The object subscribes to this as datasource event and the event 
            is republished to reach all objects in the data-link chain.
            Objects that are top only will subscribe to its container's 
            event in initializeDataObjects and the container then publishes
            the event to collect the request info in fetchData. This includes 
            objects that have parents that are already initialized (on parent 
            containers).   
------------------------------------------------------------------------------*/
  DEFINE INPUT  PARAMETER phOwner         AS HANDLE     NO-UNDO.
  DEFINE INPUT  PARAMETER pcDataSource    AS CHARACTER  NO-UNDO.
  DEFINE INPUT  PARAMETER pcViewerSource  AS CHARACTER  NO-UNDO.
  DEFINE INPUT-OUTPUT PARAMETER pcRequests       AS CHARACTER  NO-UNDO.
  DEFINE INPUT-OUTPUT PARAMETER pcDataTables     AS CHARACTER  NO-UNDO.
  DEFINE INPUT-OUTPUT PARAMETER pcQueries        AS CHARACTER  NO-UNDO.
  DEFINE INPUT-OUTPUT PARAMETER pcBatchSizes     AS CHARACTER  NO-UNDO.
  DEFINE INPUT-OUTPUT PARAMETER pcForeignFields  AS CHARACTER  NO-UNDO.
  DEFINE INPUT-OUTPUT PARAMETER pcPositionFields AS CHARACTER  NO-UNDO.
  DEFINE INPUT-OUTPUT PARAMETER pcContext        AS CHARACTER  NO-UNDO.
  DEFINE INPUT-OUTPUT PARAMETER pcDatasetSources AS CHARACTER  NO-UNDO.
  DEFINE INPUT-OUTPUT PARAMETER pcEntities       AS CHARACTER  NO-UNDO.
  DEFINE INPUT-OUTPUT PARAMETER pcEntityNames    AS CHARACTER  NO-UNDO.

  DEFINE VARIABLE cBusinessEntity   AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hDatasetSource    AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cDatasetName      AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cDataTable        AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cDatasetTable     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cQuery            AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cForeignFields    AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cPositionFields   AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE iRowsToBatch      AS INTEGER    NO-UNDO.
  DEFINE VARIABLE lOpenOnInit       AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE hTarget           AS HANDLE     NO-UNDO.
  DEFINE VARIABLE iTarget           AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cTargetType       AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE lLocalField       AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cFieldName        AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cKeyField         AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cDlm1             AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cDlm2             AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE iField            AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cField            AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hDataSource       AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hContainer        AS HANDLE     NO-UNDO.
  DEFINE VARIABLE lInitialized      AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cBatch            AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE iSource           AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cParentTable      AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cParentEntity     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cParentDataset    AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE lParentInEntity   AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lDataIsFetched    AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cRequest          AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE iEntity           AS INTEGER    NO-UNDO.
  DEFINE VARIABLE lSkip             AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cViewTables       AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE iTable            AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cTable            AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cTargets          AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hPositionSource   AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cPosSourceTables  AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hPosSourceDSproc  AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cPosSourceDSName  AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cQueryTables      AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cQueryColumns     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cRequestQuery     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cSortExpression   AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE lQueryOpen        AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cRequestDlm       AS CHARACTER  NO-UNDO.

  &SCOPED-DEFINE xp-assign
  {get BusinessEntity cBusinessEntity}
  {get DatasetName cDatasetName}
  {get DatasetSource hDatasetSource}
  {get DataTable cDataTable}
  {get ForeignFields cForeignFields}
  {get RowsToBatch iRowsToBatch}
  {get OpenOnInit lOpenOnInit}
  {get QueryString cQuery}
  {get ObjectInitialized lInitialized}
  {get DataSource hDataSource}
  {get DataIsFetched lDataIsFetched}
  {get DataTarget cTargets}
  {get ViewTables cViewTables}
  {get QueryOpen lQueryOpen}
  .
  &UNDEFINE xp-assign
  
  cRequestDlm = CHR(1).
  IF cBusinessEntity > '' AND cDataTable > '' THEN
  DO:
    IF cDatasetName = '' OR cDatasetName = ? THEN 
      cDatasetName = cBusinessEntity.
    /* allow pass-thru SDO (currently has function but no buffer-field) */
    IF VALID-HANDLE(hDataSource) THEN
      {get DataTable cParentTable hDataSource} NO-ERROR.
    
    /* Check if parent is DEFS (openoninit false ) and set DEFS on this object
       if it is. */
    IF NOT lInitialized THEN
    DO:
      IF phOwner <> TARGET-PROCEDURE THEN
        SUBSCRIBE PROCEDURE TARGET-PROCEDURE TO 'dataRequestComplete':U IN phOwner
          RUN-PROCEDURE 'startObject':U.
      IF lOpenOnInit AND VALID-HANDLE(hDataSource) AND pcDataSource > '' THEN
      DO:
        iSource = LOOKUP(pcDataSource + '.':U + cParentTable,pcDataTables).
        IF iSource > 0 THEN
          lOpenOnInit = ENTRY(iSource,pcRequests,cRequestDlm) <> 'DEFS':U.
      END.
      {get PositionSource hPositionSource}.
      
      IF VALID-HANDLE(hPositionSource) THEN  
      DO:
        &SCOPED-DEFINE xp-assign
        {get DatasetName cPosSourceDSName hPositionSource}
        {get ViewTables  cPosSourceTables hPositionSource}
        .
        &UNDEFINE xp-assign
        IF cPosSourceDSName = cDataSetName 
        AND LOOKUP(cDataTable,cPosSourceTables) > 0 THEN
        DO:
          IF iRowsToBatch <> 0 THEN
            lSkip = TRUE. 
        END.
      END.

    END. /* not initialized */
    ELSE 
    DO:
      /* don't open openoninit from parent request so just return as no chidren
         should be opened either (openoninit is is set to true when opened) */
      IF NOT lOpenOnInit AND VALID-HANDLE(hDataSource) AND pcDataSource > '' THEN
        RETURN. /* --------------------------------------> */ 

      {get PositionSource hPositionSource}.
      IF VALID-HANDLE(hPositionSource) AND pcViewerSource > '' THEN 
      DO:
        IF {fn isDataQueryComplete} THEN
          lSkip = TRUE.
        /* The phOwner's data flow will not open our query, so subscribe to 
            the request completion  */ 
        ELSE IF phOwner <> TARGET-PROCEDURE AND NOT VALID-HANDLE(hDataSource) THEN
        DO:
          SUBSCRIBE PROCEDURE TARGET-PROCEDURE TO 'dataRequestComplete':U IN phOwner
           RUN-PROCEDURE 'refreshDataQuery':U.
          IF LOOKUP(cDatasetName + '.':U + cDataTable,pcDataTables) > 0 THEN
            lSkip = TRUE.
        END.
      END.
    END.
    IF NOT lSkip THEN
    DO:
      IF lInitialized OR lOpenOnInit THEN
      DO:
        IF VALID-HANDLE(hDataSource) THEN 
        DO:
          /* parent not part of request, add the key and set isfetched flag off 
             as this object has to do its own requests */
          IF pcDataSource = '' THEN
          DO:
            {fn addForeignKey}.
            {get QueryString cQuery}.
            {set DataIsFetched FALSE}.
            ASSIGN
              cForeignFields = '' 
              cRequest = 'FIRST':U. /* FetchOnOpen..*/
          END.
          ELSE  
          DO:
            {fn removeForeignKey}.
            {get QueryString cQuery}.
  
            /*  foreign fields across business entities need to be qualified 
                we also set request to 'FIRST' (first batch on child for one parent)*/
            IF cForeignFields > '':U AND pcDataSource <> cDatasetName THEN
            DO: 
              {set DataIsFetched FALSE}.
              cRequest = 'FIRST':U. /* FetchOnOpen..*/
              DO iField = 2 TO NUM-ENTRIES(cForeignfields) BY 2:
                ENTRY(iField,cForeignFields) = pcDataSource + '.':U 
                                            + ENTRY(iField,cForeignFields).
              END.
            END.
            ELSE  /* default prodataset retrieval turned off  */
            IF lDataIsFetched = FALSE THEN
              cRequest = 'FIRST':U.
            ELSE /* unknown or true  (default - all children for all parents) */
              ASSIGN
                cRequest     = 'ALL':U
                iRowsToBatch = 0. /* no batching in default child retrieval*/
          END. 
        END. /* datasource */
        ELSE /* Default for top is first batch  
               (retrieveBatch will override this for the first table of the request) */
          ASSIGN
            cRequest = 'FIRST':U
            cForeignFields = '':U.
        
          /* Look for a single SDF target, an SDF source may have other targets, 
           typically another SDF source.
           if this is a request for all data then this info is irrelevant */         
        IF iRowsToBatch <> 0 THEN
        FieldLoop:
        DO iTarget = 1 TO NUM-ENTRIES(cTargets):
          hTarget =  WIDGET-HANDLE(ENTRY(iTarget,cTargets)).
          {get ObjectType cTargetType hTarget}.
          IF cTargetType = 'SmartDataField':U THEN
          DO:

            &SCOPED-DEFINE xp-assign
            {get LocalField lLocalField hTarget}
            {get FieldName cFieldName hTarget}
            {get KeyField cKeyField hTarget}
             .
            &UNDEFINE xp-assign

            /* there's not much we can do with a local field */
            IF NOT lLocalField THEN
            DO:
              IF pcViewerSource > '':U THEN  
                cPositionFields = cKeyField + ',':U
                                + (IF pcViewerSource <> cDatasetName
                                   THEN pcViewerSource + '.':U
                                   ELSE '':U)
                                + cFieldName.
              ELSE DO:
                {get ContainerSource hContainer hTarget}.
                {get DataSource hPositionSource hContainer}.
                /* avoid error if viewer run without its source */
                IF VALID-HANDLE(hDataSource) THEN
                  cRequest = 'WHERE ' + cKeyField + ' = ' 
                         + QUOTER({fnarg columnValue cFieldName hPositionSource}).
                
              END.
            END.
            LEAVE FieldLoop.
          END. /* SDF */
        END. /* if irowstobatch <> 0 do iTarget loop  */
        
        cBatch = STRING(iRowsToBatch).

        IF cQuery = '':U THEN
          {get QueryStringDefault cQuery}.

        &SCOPED-DEFINE xp-assign
        {get QueryTables cQueryTables}
        {get QueryColumns cQueryColumns}
         .
        &UNDEFINE xp-assign
        /* trim request query for tables not in expression or sort*/
        IF NUM-ENTRIES(cQueryTables) > 1 THEN
        DO:
          cSortExpression = {fnarg sortExpression cQuery}.
          DO iTable = 1 TO NUM-ENTRIES(cQueryTables):
            cTable = ENTRY(iTable,cQueryTables).
            /* Only pass secondary tables if explicitly in the query or 
               sort expression  */
            IF iTable = 1 
            OR INDEX(' ':U + cSortExpression,' ':U + cTable + '.':U) > 0
            OR INDEX(':':U + cQueryColumns,':' + cTable + ':':U) > 0 THEN
              cRequestQuery = cRequestQuery 
                    + (IF cRequestQuery = '':U THEN '':U ELSE ',':U)
                    + DYNAMIC-FUNCTION('bufferWhereClause':U IN TARGET-PROCEDURE,
                                        cTable,
                                        cQuery).
          END. /* DO iTable = 1 TO NUM-ENTRIES(cSortTables) */
          cQuery = LEFT-TRIM(cRequestQuery + ' ' + cSortExpression).
        END. 
      END.  /* open (already initialized or openoninit true )*/
      ELSE  /* don't open */
        ASSIGN 
          cBatch   = '?':U
          cRequest = 'DEFS':U
          cQuery   = 'DEFS':U.
    
      ASSIGN
        cDatasetTable = cDatasetName + '.':U + cDataTable 
        cDlm1 = (IF (pcDataTables = '':U) THEN '':U ELSE ',':U)
        cDlm2 = (IF (pcDataTables = '':U) THEN '':U ELSE cRequestDlm)
        pcDataTables     = pcDataTables  + cDlm1 + cDatasetTable
        pcBatchSizes     = pcBatchSizes  + cDlm1 + cBatch  
        pcContext        = pcContext     + cDlm2 + {fn obtainContextForServer}
        pcRequests       = pcRequests    + cDlm2 + cRequest
        pcQueries        = pcQueries     + cDlm2 + (IF cQuery = ? THEN '':U ELSE cQuery)
        /* Use semi-colon separators since there may be any number of fields 
           in the already comma-separated ForeignFields (theoretically also in 
           positionfields although not supported in default SDF implementation)*/
        pcForeignFields  = pcForeignFields + cDlm2 
                           + (IF cForeignFields > '':U THEN cForeignFields ELSE '':U)
        pcPositionFields = pcPositionFields + cDlm2 
                           + (IF cPositionFields > '':U THEN cPositionFields ELSE '':U)      
        .

      /* Add additional viewtables to list (except parent tables)         
        (Request 'ALL' = default dataset retrieval) */ 
      DO iTable = 2 TO NUM-ENTRIES(cViewTables):
        cTable = ENTRY(iTable,cViewTables).
        
        /* If the parent is in viewtables and in the same entity, 
           we don't need to retrieve it.  */ 
        IF cParentTable = cTable THEN
        DO:
          &SCOPED-DEFINE xp-assign
          {get BusinessEntity cParentEntity hDataSource}
          {get DatasetName cParentDataset hDataSource}
          .
          &UNDEFINE xp-assign 
          lParentInEntity = (cParentEntity = cBusinessentity) 
                            AND 
                            (cParentDataset = cDatasetName). 
        END.
        ELSE 
          lParentInEntity = FALSE.

        /* reposition tables are retrieved on first request (not open)  */
        IF NOT lParentInEntity
        AND (NOT lQueryOpen 
             OR (VALID-HANDLE(hDatasetSource) 
                 AND NOT {fnarg isReposition cTable hDatasetSource})
             ) THEN
          ASSIGN
            cDlm1            = ',':U
            cDlm2            = cRequestDlm
            pcDataTables     = pcDataTables  + cDlm1 
                             + cDatasetName + '.':U + cTable
            pcBatchSizes     = pcBatchSizes  + cDlm1
                             + '0':U  
            pcRequests       = pcRequests    + cDlm2
                             + (IF cRequest = 'DEFS':U 
                                THEN 'DEFS':U 
                                ELSE 'ALL':U)
            pcQueries        = pcQueries     + cDlm2 
                             + (IF cRequest = 'DEFS':U 
                                THEN 'DEFS':U 
                                ELSE 'FOR EACH ':U + cTable)
            pcForeignFields  = pcForeignFields  + cDlm2 + '':U
            pcPositionFields = pcPositionFields + cDlm2 + '':U
            .

      END. /* iTable loop additional tables */   
      
      IF LOOKUP(cDatasetName,pcEntityNames) = 0 THEN
        ASSIGN
          cDlm1            = (IF (pcEntities = '':U) THEN '':U ELSE ',':U)
          pcEntities       = pcEntities    + cDlm1 + cBusinessEntity
          pcEntityNames    = pcEntityNames + cDlm1 + cDatasetName 
          pcDatasetSources = pcDatasetSources + cDlm1 
                           + (IF VALID-HANDLE(hDatasetSource) 
                              THEN STRING(hDatasetSource)
                              ELSE '?':U).
    END. /* not skip */
    
    PUBLISH "buildDataRequest":U FROM TARGET-PROCEDURE
                               (INPUT phOwner,
                                INPUT cDatasetName,
                                INPUT pcViewerSource,
                                INPUT-OUTPUT pcRequests, 
                                INPUT-OUTPUT pcDataTables,
                                INPUT-OUTPUT pcQueries,
                                INPUT-OUTPUT pcBatchSizes,
                                INPUT-OUTPUT pcForeignFields,
                                INPUT-OUTPUT pcPositionFields,
                                INPUT-OUTPUT pcContext,
                                INPUT-OUTPUT pcDatasetSources,
                                INPUT-OUTPUT pcEntities,
                                INPUT-OUTPUT pcEntityNames).
 
  END. /* IF cBusinessEntity > '' AND cDataTable > '' */

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-commitTransaction) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE commitTransaction Procedure 
PROCEDURE commitTransaction :
/*------------------------------------------------------------------------------
  Purpose:   Save all dataset changes.   
  Parameters:  
  Notes:     This includes all child data.  
  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE lCancel       AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lOk           AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cUpdateSource AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hUpdateSource AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cDummy        AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cKeyWhere     AS CHAR       NO-UNDO.
  /* Record changes that haven't been saved must be saved before a commit.*/
  /* Visual dataTargets subscribes to this */
  PUBLISH 'confirmCommit':U FROM TARGET-PROCEDURE (INPUT-OUTPUT lCancel).
  IF lCancel THEN 
    RETURN 'ADM-ERROR':U.
  
  {get keyWhere cKeyWhere}. 

  lOk = {fn submitData}.
  IF lOk THEN  
  DO:
    IF cKeyWhere = ? THEN
      cKeyWhere = ''.
    ELSE
      cKeyWhere = 'WHERE ':U + cKeyWhere.
    {fnarg openDataQuery cKeyWhere}.
    RUN rowChanged IN TARGET-PROCEDURE ('RESET':U).
  END.
  ELSE DO:  
    /* If there were errors, get the Update-Source to deal with them. */
    {get UpdateSource cUpdateSource}. 
    hUpdateSource = WIDGET-HANDLE(ENTRY(1,cUpdateSource)).
    IF VALID-HANDLE (hUpdateSource) THEN      
      RUN showDataMessagesProcedure IN hUpdateSource (OUTPUT cDummy).
  END.
  
END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-confirmCommit) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE confirmCommit Procedure 
PROCEDURE confirmCommit :
/*------------------------------------------------------------------------------
  Purpose: Checks the state of all data-targets too se if it's ok to commit.
           It's not OK to commit if a data-target is Modified or the 
           in these case the I-O parameter should return cancel = TRUE. 
           The visual objects (visual.p) will, however, offer the user the 
           opportunity to save/cancelRecord in order to be able to commit.   
                  
Parameters: INPUT-OUTPUT  pioCancel (logical) 
                 Will return true if it's NOT ok to commit.  
  Notes:   
------------------------------------------------------------------------------*/
   DEFINE INPUT-OUTPUT PARAMETER pioCancel AS LOGICAL NO-UNDO.  
   
   /* don't ask data-targets if already cancelled */  
   IF NOT pioCancel THEN
     PUBLISH "confirmCommit":U FROM TARGET-PROCEDURE (INPUT-OUTPUT pioCancel).

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-confirmContinue) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE confirmContinue Procedure 
PROCEDURE confirmContinue :
/*------------------------------------------------------------------------------
  Purpose: Checks the state of all data-targets too se if it's ok to continue.
           It's not OK to continue if a data-target is Modified or the 
           RowUpdateState equals 'rowUpdated', in these case the I-O parameter 
           should return cancel = TRUE. The visual objects (visual.p) 
           will, however, offer the user the opportunity to save/cancelRecord or 
           commit/undo in order to be able to continue.   
                  
Parameters: INPUT-OUTPUT  pioCancel (logical) 
                 Will return true if it's NOT ok to continue.  
  Notes:   This method should be called from any method that may change the 
           result set somewhere in the data-source chain like openQuery or 
           navigation actions.
           
           Currently called from the filter-source to see if new criteria can 
           be applied.  
                 
        -  Currently Navigation actions are disabled whenever a state
           that may disallow continuation is set to true. A less modal 
           could be achieved by always enable navigation and calling this 
           from fetch* methods.
------------------------------------------------------------------------------*/
   DEFINE INPUT-OUTPUT PARAMETER pioCancel AS LOGICAL NO-UNDO.  
   
   /* don't ask data-targets if already cancelled */  
   IF NOT pioCancel THEN
     PUBLISH "confirmContinue":U FROM TARGET-PROCEDURE (INPUT-OUTPUT pioCancel).

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-confirmUndo) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE confirmUndo Procedure 
PROCEDURE confirmUndo :
/*------------------------------------------------------------------------------
  Purpose: Checks the state of all data-targets too se if it's ok to Undo.
           It's not OK to undo if a data-target is Modified or in AddMode.  
           In these case the I-O parameter should return cancel = TRUE. 
           The visual objects (visual.p) will, however, warn the user 
           that unsaved changes will be cancelled.   
                  
Parameters: INPUT-OUTPUT  pioCancel (logical) 
                 Will return true if it's NOT ok to commit.  
  Notes:   
------------------------------------------------------------------------------*/
   DEFINE INPUT-OUTPUT PARAMETER pioCancel AS LOGICAL NO-UNDO.  
   
   /* don't ask data-targets if already cancelled */  
   IF NOT pioCancel THEN
     PUBLISH "confirmUndo":U FROM TARGET-PROCEDURE (INPUT-OUTPUT pioCancel).
END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-createObjects) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE createObjects Procedure 
PROCEDURE createObjects :
/*------------------------------------------------------------------------------
  Purpose:  CreateObjects defines the object and its handles    
  Notes:    Should only be called once at runtime
          -
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hDataContainer AS HANDLE     NO-UNDO.
  
  DEFINE VARIABLE cDataTable          AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hBuffer             AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hDatasetSource      AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hDataHandle         AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cColumns            AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE iTable              AS INTEGER    NO-UNDO.
  DEFINE VARIABLE hChild              AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cChild              AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cUpdatableColumns   AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cViewTables         AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE iCol                AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cTable              AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cTables             AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cTableColumns       AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cContext            AS CHARACTER  NO-UNDO.

  &SCOPED-DEFINE xp-assign 
  {get DatasetSource hDatasetSource}
  {get DataTable cDataTable}
  {get RowObject hBuffer}
  .
  &UNDEFINE xp-assign
  
  /* The intention is to support any TT by just setting the Rowobject 
     (as of current not supported as other logic still require a dataset) */
  IF NOT VALID-HANDLE(hBuffer) THEN  
  DO:
    IF NOT VALID-HANDLE(hDatasetSource) AND {fn addDatasetSource} THEN
      {get DatasetSource hDatasetSource}.

    IF VALID-HANDLE(hDatasetSource) AND cDataTable > '' THEN
    DO:
      cContext = {fnarg tableContext cDataTable hDatasetSource}. 
      IF cContext > '' THEN
        {fnarg applyContextFromServer cContext}.

      hBuffer = {fnarg createBuffer cDataTable hDatasetSource}.
      {set RowObject hBuffer}.
    END.
  END.

  IF VALID-HANDLE(hBuffer) AND VALID-HANDLE(hDatasetSource) THEN
  DO:
    {get QueryTables cTables}.
    CREATE QUERY hDataHandle.
    hDataHandle:ADD-BUFFER(hBuffer).
    /* Start on 2nd, the 1st table is the Datatable and is added above */
    DO iTable = 2 TO NUM-ENTRIES(cTables):
      ASSIGN
        cChild = ENTRY(iTable,cTables)
        hChild = {fnarg createBuffer cChild hDatasetSource}
        .
      IF VALID-HANDLE(hChild) THEN
        hDataHandle:ADD-BUFFER(hChild).
    END.

    {get UpdatableColumns cUpdatableColumns}.
     
    cColumns = {fnarg dataColumns cDataTable hDatasetSource}.
    /* if updatableColumns not defined (from context ..) then set them from
       columns */  
    IF cUpdatableColumns = ? THEN
      {set UpdatableColumns cColumns}.

    {get ViewTables cViewTables}.  
    /* Start on 2nd, the 1st table is the Datatable and is handled above */
    DO iTable = 2 TO NUM-ENTRIES(cViewTables):
      ASSIGN 
        cTable        = ENTRY(iTable,cViewTables)
        cTableColumns = {fnarg dataColumns cTable hDatasetSource} 
        cColumns     = cColumns 
                      + (IF cColumns <> '' AND cTableColumns <> '' THEN ',' ELSE '') 
                      + cTableColumns.
    END. /* do itable = 2 to num-entries */
    
    &SCOPED-DEFINE xp-assign
    {set DataColumns cColumns}
    {set DataHandle hDataHandle}
    .
    &UNDEFINE xp-assign
    
    IF hBuffer:TABLE-HANDLE:DYNAMIC OR VALID-HANDLE(hBuffer:TABLE-HANDLE:BEFORE-TABLE) THEN
      hBuffer:TABLE-HANDLE:TRACKING-CHANGES = TRUE.
  END. /* valid buffer and datasetsource */
  
  RETURN.

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-dataAvailable) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE dataAvailable Procedure 
PROCEDURE dataAvailable :
/*------------------------------------------------------------------------------
  Purpose:   Receives dataavailable events from data-source as well as 
             data-targets     
  Parameters:  pcMode  
                 DIFFERENT - open query  
                 RESET     - open query if foreign key changed
                 VALUE-CHANGED -  row change only (browse navigation) 
  
  Notes:       
------------------------------------------------------------------------------*/
  DEFINE INPUT  PARAMETER pcMode AS CHARACTER  NO-UNDO.

  DEFINE VARIABLE hRowObject   AS HANDLE     NO-UNDO.
  DEFINE VARIABLE iRel         AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cWhereString AS CHARACTER  NO-UNDO.

  DEFINE VARIABLE hDataset            AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hRel                AS HANDLE     NO-UNDO.
  DEFINE VARIABLE iColumn             AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cValues             AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cChildQuery         AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cTarget             AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hDataHandle         AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hDataSource         AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cForeignFields      AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE iField              AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cDatatable          AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cQueryString        AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hDataSetsource      AS HANDLE     NO-UNDO.
  DEFINE VARIABLE lInitialized        AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lParentOpen         AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lOpen               AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lDataIsFetched      AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lClose              AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lQueryOpen          AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cForeignValues      AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE lFetchedByParent    AS LOGICAL    NO-UNDO.

  &SCOPED-DEFINE xp-assign
  {get DataTarget cTarget}
  {get ObjectInitialized lInitialized}
  {get QueryOpen lQueryOpen}
  {get RowObject hRowObject}
  .
  &UNDEFINE xp-assign
  
  IF NOT lInitialized OR pcMode = 'SAME':U THEN 
    RETURN.

  /* Support browser publish of whatever.. */  
  IF CAN-DO(cTarget,STRING(SOURCE-PROCEDURE)) THEN
    pcMode = 'VALUE-CHANGED':U.

  IF pcMode <> 'VALUE-CHANGED':U THEN
  DO:
    lOpen = TRUE.
    {get DataSource hDataSource}.
    IF VALID-HANDLE(hDataSource)  THEN
    DO: 
      /* builddatarequest will applyforeignkey for standalone child 
         request, but removes foreign key otherwise, so an unknown value 
         means that the parent has retrieved the data 
         (used when dataisfetched is false below) */                                               
      {get ForeignValues cForeignValues}.
      lFetchedByParent = (cForeignValues = ?).
         
      {get QueryOpen lOpen hDataSource}.
      IF lOpen THEN
      DO:
        /* if parent is in newmode set close flag */ 
        {get NewMode lClose hDataSource}. 
        IF NOT lClose THEN
        DO:
          IF pcMode = 'RESET':U THEN
          DO:
            IF {fn hasForeignKeyChanged} THEN
              pcMode = 'DIFFERENT':U.
          END.
          IF pcMode <> 'RESET':U OR NOT lQueryOpen THEN 
            {fn addForeignKey}.
        END.
      END. 
      /* set close flag if parent is closed (probably because its parent is new ) */
      ELSE IF lQueryOpen THEN
        lClose = TRUE.
    END.
  END. /* mode <> 'value-changed' */  

  /* This OpenOnInit flag is set to true unconditionally in opendataView, 
     so we can safely check this here.  
     This ensures that a child with openoninit false not is opened when 
     the parent navigates */
  IF lOpen THEN 
  DO:
    {get OpenOnInit lOpen}.
    /* we are on our own from now on and must retrieve data on next request */
    IF NOT lOpen THEN
      {set DataIsFetched NO}.     
  END.
  IF lClose THEN
    {fn closequery}.

  ELSE IF lOpen THEN
  DO:
    &SCOPED-DEFINE xp-assign
    {get DataIsFetched lDataIsFetched}   
    {get ObjectInitialized lInitialized}
    {get DatasetSource hDatasetSource}
    .
    &UNDEFINE xp-assign  

    IF (lDataIsFetched = FALSE AND lFetchedByParent = FALSE AND pcMode <> 'RESET':U) 
    OR NOT VALID-HANDLE(hDatasetSource) THEN
      {fn openQuery}.                                                 
    ELSE IF pcMode <> 'RESET':U OR NOT lQueryOpen THEN
      {fn openDataView}.
    ELSE 
      RUN rowChanged IN TARGET-PROCEDURE('RESET':U).
  END.
  ELSE 
    RUN rowChanged IN TARGET-PROCEDURE('DIFFERENT':U).
 
END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-describeSchema) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE describeSchema Procedure 
PROCEDURE describeSchema :
/*------------------------------------------------------------------------------
  Purpose:     
  Parameters:  <none>
  Notes:       
------------------------------------------------------------------------------*/
DEFINE INPUT PARAMETER pcFieldList    AS CHARACTER                    NO-UNDO.
DEFINE OUTPUT PARAMETER TABLE-HANDLE hTTSchema.

DEFINE VARIABLE iCol                    AS INTEGER    NO-UNDO.
DEFINE VARIABLE hColumn                 AS HANDLE     NO-UNDO.
DEFINE VARIABLE cUpdatableColumnList    AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cDataColumns            AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cColumnRef              AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cColumnName             AS CHARACTER  NO-UNDO.

DEFINE VARIABLE iColumn                 AS INTEGER    NO-UNDO.
DEFINE VARIABLE iColumnSequence         AS INTEGER    NO-UNDO.
DEFINE VARIABLE iIndexSequence          AS INTEGER    NO-UNDO.
DEFINE VARIABLE iIdxFldSeq              AS INTEGER    NO-UNDO.
DEFINE VARIABLE cBusinessEntity         AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cWordIndexedFields      AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cIndexInformation       AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cThisIndex              AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cLogicalSDOName         AS CHARACTER  NO-UNDO.
DEFINE VARIABLE hContainer              AS HANDLE     NO-UNDO.
DEFINE VARIABLE hEntityBuffer           AS HANDLE     NO-UNDO.
DEFINE VARIABLE hTranslatedBuffer       AS HANDLE     NO-UNDO.
DEFINE VARIABLE lTranslateColumnLabel   AS LOGICAL    NO-UNDO.
DEFINE VARIABLE cDataTable              AS CHARACTER  NO-UNDO.

    EMPTY TEMP-TABLE ttSchema.
    hTtSchema = TEMP-TABLE ttSchema:HANDLE.

    &SCOPED-DEFINE xp-assign
    {get DataTable cDataTable}
    {get LogicalObjectName cLogicalSDOName}
    {get UpdatableColumns cUpdatableColumnList}
    {get BusinessEntity cBusinessEntity}
    {get WordIndexedFields cWordIndexedFields}
    {get IndexInformation cIndexInformation}
    .
    &UNDEFINE xp-assign

    lTranslateColumnLabel = VALID-HANDLE(gshRepositoryManager).
    
    IF cLogicalSDOName EQ "":U OR cLogicalSDOName EQ ? THEN
        ASSIGN cLogicalSDOName = TARGET-PROCEDURE:FILE-NAME.

    DO iCol = 1 TO NUM-ENTRIES(pcFieldList):
       cColumnRef = ENTRY(iCol,pcFieldList).
       /* Currently only returns datatable columns */ 
       IF INDEX(cColumnRef,'.':U) > 0 
       AND NOT cColumnRef BEGINS cDataTable + '.' THEN
         NEXT.
       hColumn = {fnarg columnHandle cColumnRef}.
       /* If the buffer-field is not in the list of fields we want, */
       CREATE ttSchema.
       ASSIGN
          ttSchema.sdo_name               = cLogicalSDOName
          ttSchema.column_sequence        = iCol
          ttSchema.column_case_sensitive  = hColumn:CASE-SENSITIVE
          ttSchema.column_dataType        = hColumn:DATA-TYPE
          ttSchema.column_format          = hColumn:FORMAT
          ttSchema.column_label           = hColumn:COLUMN-LABEL           
          ttSchema.column_mandatory       = hColumn:MANDATORY
          ttSchema.column_name            = cColumnRef
          ttSchema.column_width_chars     = hColumn:WIDTH-CHARS
          ttSchema.column_updatable       = (LOOKUP(hColumn:NAME, cUpdatableColumnList) > 0)
          ttSchema.adm_column             = NO 
          /* initially assign all fields as calculated, except rowobject, then, when assigning the table name, assign calculated_field = NO  */
/*           ttSchema.calculated_field       = IF ttSchema.adm_column THEN NO ELSE YES  */
          /* Set calculated field flag based on field name being in calculatedColumns psuedo-property */
          ttSchema.calculated_field       = NO 
          ttSchema.word_index             = (LOOKUP(hColumn:NAME, cWordIndexedFields) > 0)
          ttSchema.COLUMN_indexed         = ttSchema.word_index
          ttSchema.sdo_order              = 1
          ttSchema.sdo_handle             = TARGET-PROCEDURE
          ttSchema.DATABASE_name          = cBusinessEntity
          ttSchema.TABLE_name             = hColumn:TABLE
          ttSchema.FIELD_name             = ttSchema.column_name
          .
    END.
    
    ASSIGN iIndexSequence  = 1
           iColumnSequence = 0.

    IF lTranslateColumnLabel THEN
    DO:
      hEntityBuffer = DYNAMIC-FUNCTION("getCacheEntityObject":U IN gshRepositoryManager, 
                                       cDataTable).
      IF VALID-HANDLE(hEntityBuffer) AND hEntityBuffer:AVAILABLE THEN
        ASSIGN hColumn = hEntityBuffer:BUFFER-FIELD("EntityBufferHandle":U)
               hTranslatedBuffer = IF VALID-HANDLE(hColumn) THEN WIDGET-HANDLE(hColumn:BUFFER-VALUE) ELSE ?.
      ELSE
        hTranslatedBuffer = ?.
      DO iCol = 1 TO NUM-ENTRIES(pcFieldList):
        cColumnRef = ENTRY(iCol,pcFieldList).
        FIND FIRST ttSchema WHERE ttSchema.column_name = cColumnRef NO-ERROR.
        IF AVAILABLE ttSchema THEN
        DO:
          /* Translate ttSchema.column_label */
          IF lTranslateColumnLabel AND VALID-HANDLE(hTranslatedBuffer) THEN
          DO:
            IF INDEX(cColumnRef,'.':U) > 0 THEN
              cColumnName = ENTRY(2,cColumnRef,'.':U).
            ELSE 
              cColumnName = cColumnRef.
            hColumn = hTranslatedBuffer:BUFFER-FIELD(cColumnName).                    
            IF VALID-HANDLE(hColumn) THEN
               ttSchema.column_label = hColumn:COLUMN-LABEL. /* Assign column_label from entity cache */
          END.
        END.
      END.
    END.
    IF cIndexinformation NE '' THEN
    DO iCol = 1 TO NUM-ENTRIES(cIndexinformation,CHR(1)):
        ASSIGN 
          cThisIndex = ENTRY(iCol,cIndexinformation,CHR(1))
          iIdxFldSeq = 0
          .            
        DO iColumn = 5 TO NUM-ENTRIES(cThisIndex):
            FIND FIRST ttSchema WHERE ttSchema.column_name = ENTRY(iColumn, cThisIndex) NO-ERROR.
            IF AVAILABLE ttSchema THEN
                ASSIGN iIdxFldSeq = iIdxFldSeq + 1
                       ttSchema.COLUMN_indexed = YES
                       ttSchema.INDEX_position = ttSchema.INDEX_position
                                               + (IF ttSchema.INDEX_position = '' THEN '' ELSE ',')
                                               + STRING(iIndexSequence) + '.' + STRING(iIdxFldSeq).
        END.
        iIndexSequence = iIndexSequence + 1.
    END.
   /* Lastly, mark all with no index as "None" */
    FOR EACH ttSchema WHERE INDEX_position = "":U:
      ttSchema.INDEX_position = "None":U.        
    END.              
END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-destroyObject) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE destroyObject Procedure 
PROCEDURE destroyObject :
/*------------------------------------------------------------------------------
  Purpose:     
  Parameters:  <none>
  Notes:       
------------------------------------------------------------------------------*/
 DEFINE VARIABLE lDbAware AS LOGICAL    NO-UNDO.
 /*
 {get DbAware lDbaware}.
  
 IF NOT lDbAware THEN
 */
 {fn destroyView}.
 
 RUN SUPER.

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-exportData) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE exportData Procedure 
PROCEDURE exportData :
/*------------------------------------------------------------------------------
  Purpose:     Eports the contents of the SDO to an external source/tool 
  Parameters:  input 'Excel' or 'Crystal'.
               input field list or leave blank for all (no table prefix)
               input include object fields yes/no
               input use existing running excel yes/no
               input maximum records to process
  Notes:    -  The external tool's exportData will do a call back to the 
               data object's tableout procedure for the actual retrieval of the data.    
            -  Data: Always excludes rowobject specific fields,
               e.g. RowNum,RowIdent,RowMod
------------------------------------------------------------------------------*/
 DEFINE INPUT  PARAMETER pcExportType   AS CHARACTER  NO-UNDO.
 DEFINE INPUT  PARAMETER pcFieldList      AS CHARACTER  NO-UNDO.
 DEFINE INPUT  PARAMETER plIncludeObj     AS LOGICAL    NO-UNDO.
 DEFINE INPUT  PARAMETER plUseExisting    AS LOGICAL    NO-UNDO.
 DEFINE INPUT  PARAMETER piMaxRecords     AS INTEGER    NO-UNDO.
   
 DEFINE VARIABLE hObject AS HANDLE     NO-UNDO.

 DO ON STOP UNDO,LEAVE:
   RUN adm2/exportdata.p PERSISTENT SET hObject.
 END.
 IF VALID-HANDLE(hObject) THEN
 DO:
   RUN exportData IN hObject (TARGET-PROCEDURE,
                              pcExportType,
                              pcFieldList,
                              plIncludeObj,
                              plUseExisting,
                              piMaxRecords).

   RUN destroyObject IN hObject.
 END. 

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-fetchBatch) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE fetchBatch Procedure 
PROCEDURE fetchBatch :
/*------------------------------------------------------------------------------
  Purpose:     To transfer another "batch" of rows from the data provider to 
               the Temp-Table query, without changing the current 
               record position.
  Parameters:
    INPUT plForwards - TRUE if we should retrieve a batch of rows after the current rows,
                       FALSE if before.
  Notes:       Run from a Browser to get another batch of rows from the database
               query appended to the RowObject temp-table query (when the 
               browser scrolls to the end).
               fetchBatch does some checking and sets up the proper parameters
               to sendRows, but sendRows is called to do the actual work.  
------------------------------------------------------------------------------*/
  DEFINE INPUT PARAMETER plForwards AS LOGICAL NO-UNDO.
 
  DEFINE VARIABLE hDataQuery AS HANDLE     NO-UNDO.
 
  DYNAMIC-FUNCTION('retrieveBatch':U IN TARGET-PROCEDURE,
                    IF plForwards THEN 'NEXT':U ELSE 'PREV':U,?).

  /* retrievebatch currently does a get-next or get-prev, which is not noticed
     by the browse, so we synch the browse here. 
    (See comment in retrievBatch explaining alternative approach that could 
     move reposition to retrieveBatch */  
  {get DataHandle hDataQuery}.
  /* this is a synch-browse statement.. moves cursor back 1 position, so
     the browser's implicit record-avail gets correct record. */
  hDataQuery:REPOSITION-BACKWARDS(1).

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-fetchFirst) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE fetchFirst Procedure 
PROCEDURE fetchFirst :
/*------------------------------------------------------------------------------
  Purpose:     To reposition the RowObject temp-table to the first record, or
               to the row matching the QueryRowIdent property (if it has been
               set.)  If the first record has not been fetched (from the db) 
               yet, then calls sendRows to get the first batch of RowObject 
               records of the SDO and then reposition the RowObject Temp-Table
               to the first row.
 
  Parameters:  <none>
------------------------------ ------------------------------------------------*/
  DEFINE VARIABLE hDataQuery    AS HANDLE    NO-UNDO.
  DEFINE VARIABLE iRowNum       AS INTEGER   NO-UNDO.
  DEFINE VARIABLE lRebuild      AS LOGICAL   NO-UNDO.
  DEFINE VARIABLE cRowState     AS CHARACTER NO-UNDO.
  DEFINE VARIABLE lCancel       AS LOGICAL    NO-UNDO.
 
  &SCOPED-DEFINE xp-assign
  {get DataHandle hDataQuery}
  {get FirstRowNum iRowNum}
  .
  &UNDEFINE xp-assign
  
  IF iRowNum = ? THEN       /* First row hasn't been retrieved yet. */      
  DO:
    {get RowObjectState cRowState}.
    IF cRowState = 'RowUpdated':U THEN 
      RUN confirmContinue IN TARGET-PROCEDURE (INPUT-OUTPUT lCancel).
    IF NOT lCancel THEN
      DYNAMIC-FUNCTION('retrieveBatch':U IN TARGET-PROCEDURE,'FIRST':U,?).
  END.   /* END IF iRowNum = ? */
  ELSE 
    hDataQuery:GET-FIRST().
 
  /* Update queryposition and publish dataAvailable whether there's a record 
     or not; if not, the recipients will close queries or clear frames. */
  RUN rowChanged IN TARGET-PROCEDURE ("FIRST":U).     
    
  RETURN.
END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-fetchLast) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE fetchLast Procedure 
PROCEDURE fetchLast :
/*------------------------------------------------------------------------------
  Purpose:     To reposition the temp-table query to the last row of the dataset.
               If the last row has not yet been retrieved, then fetchLast gets 
               the last batch of records and repositions the temp-table query 
               to the last row.
  Parameters:  <none>
  Notes:       IF RebuildOnReposition is false and the last row has not been 
               fetch yet, fetchLast will ask for the rest of the data and 
               append it to the current data. 
               If RebuildOnReposition is true and the last row from the db query
               has not been fetch yet, all temp-table records are discarded and
               just the last batch is fetched.  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hDataQuery    AS HANDLE  NO-UNDO.
  DEFINE VARIABLE iLastRow      AS INTEGER NO-UNDO.
  DEFINE VARIABLE lReposAvail   AS LOGICAL   NO-UNDO.
  DEFINE VARIABLE cRowState     AS CHARACTER NO-UNDO.
  DEFINE VARIABLE lOk           AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lCancel       AS LOGICAL    NO-UNDO.
    
  &SCOPED-DEFINE xp-assign
  {get DataHandle hDataQuery}
  {get LastRowNum iLastRow}
  .
  &UNDEFINE xp-assign
  
  IF iLastRow = ? THEN        /* Last row not been retrieved yet.*/
  DO:
    {get RowObjectState cRowState}.
    IF cRowState = 'RowUpdated':U THEN 
      RUN confirmContinue IN TARGET-PROCEDURE (INPUT-OUTPUT lCancel).

    IF lCancel THEN
      RETURN.
    
    RUN changeCursor IN TARGET-PROCEDURE('WAIT':U).   
    PUBLISH 'fetchDataSet':U FROM TARGET-PROCEDURE ('LastStart':U).
    lOk = DYNAMIC-FUNCTION('retrieveBatch':U IN TARGET-PROCEDURE,'LAST':U,?).
    PUBLISH 'fetchDataSet':U FROM TARGET-PROCEDURE ('LastEnd':U).  
    RUN changeCursor IN TARGET-PROCEDURE('':U).
    IF NOT lok THEN
      RETURN.
  END.
  ELSE
    hDataQuery:GET-LAST(). 

  /* Signal row change in any case. */
  RUN rowChanged IN TARGET-PROCEDURE("LAST":U).      
  
  RETURN.  
END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-fetchNext) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE fetchNext Procedure 
PROCEDURE fetchNext :
/*------------------------------------------------------------------------------
  Purpose:     To reposition the RowObject query to the next row.  If a new 
               batch is required to do so, then sendRows is called to get the
               new batch.
  
  Parameters:  <none>
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hDataQuery   AS HANDLE  NO-UNDO. 
  DEFINE VARIABLE hRowObject   AS HANDLE  NO-UNDO.
  DEFINE VARIABLE iRow         AS INTEGER NO-UNDO.
  DEFINE VARIABLE cQueryPos    AS CHARACTER NO-UNDO.
  DEFINE VARIABLE cRowState    AS CHARACTER NO-UNDO.
  DEFINE VARIABLE lFirstDeleted AS LOGICAL  NO-UNDO.
  DEFINE VARIABLE lOk           AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lCancel       AS LOGICAL    NO-UNDO.

    {get DataHandle hDataQuery}.
    IF NOT hDataQuery:IS-OPEN THEN 
      RETURN.
      
    hRowObject = hDataQuery:GET-BUFFER-HANDLE(1).

    IF hRowObject:AVAILABLE THEN   /* Make sure we're positioned to some row. */
    DO:
      {get LastRowNum iRow}.
      /* Already on the last row. */
      IF iRow = INT(hRowObject:RECID) THEN 
        RETURN.
    END. /* if hRowObject:available */
    ELSE DO:  /* if no record is avail, but queryposition is first we 
                 must have deleted it */ 
      {get QueryPosition cQueryPos}.
      /* This seems to be  handled in updateQueryPos ..
      IF cQueryPos = 'LastRecord':U THEN
         lLastDeleted = TRUE. */  
      IF cQueryPos = 'FirstRecord':U THEN
         lFirstDeleted = TRUE.
    END.

    hDataQuery:GET-NEXT().
   
    IF NOT hRowObject:AVAILABLE THEN
    DO:    
      {get RowObjectState cRowState}.
      IF cRowState = 'RowUpdated':U THEN 
        RUN confirmContinue IN TARGET-PROCEDURE (INPUT-OUTPUT lCancel).
      IF NOT lCancel THEN
      DO:
        /* No data so ask the Query. */
        PUBLISH 'fetchDataSet':U FROM TARGET-PROCEDURE ('NextStart':U).
        lOk = DYNAMIC-FUNCTION('retrieveBatch':U IN TARGET-PROCEDURE,'NEXT',?).  
        PUBLISH 'fetchDataSet':U FROM TARGET-PROCEDURE ('NextEnd':U).
      END.
      IF NOT lok THEN
      DO:
        /* pretend nothing happened */
        hDataQuery:GET-PREV().
        RETURN.
      END.
    END.       /* END DO IF no next record AVAILABLE  */
    
    IF lFirstDeleted AND hRowObject:AVAILABLE THEN  
    DO:
      iRow = INT(hRowObject:RECID).
      {set FirstRowNum iRow}.
    END.

    RUN rowChanged IN TARGET-PROCEDURE("NEXT":U). 

    RETURN.  
END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-fetchPrev) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE fetchPrev Procedure 
PROCEDURE fetchPrev :
/*------------------------------------------------------------------------------
  Purpose:     To reposition the RowObject query to the previous row.  If a new
               batch is needed to do so, then sendRows is called to get the new
               batch.  (Getting a new batch will only be necessary when the 
               RebuildOnReposition property is set to true.)
 
  Parameters:  <none>
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hDataQuery   AS HANDLE  NO-UNDO.
  DEFINE VARIABLE hRowObject   AS HANDLE  NO-UNDO.
  DEFINE VARIABLE iRow         AS INTEGER NO-UNDO.
  DEFINE VARIABLE lAutoCommit  AS LOGICAL  NO-UNDO.
  DEFINE VARIABLE lRebuild     AS LOGICAL  NO-UNDO.
  DEFINE VARIABLE cRowState    AS CHARACTER NO-UNDO.
  DEFINE VARIABLE lCancel      AS LOG    NO-UNDO.
  DEFINE VARIABLE lOk          AS LOGICAL    NO-UNDO.

    {get DataHandle hDataQuery}.

    IF NOT hDataQuery:IS-OPEN        
      THEN RETURN.
      
    ASSIGN hRowObject = hDataQuery:GET-BUFFER-HANDLE(1).
        
    IF hRowObject:AVAILABLE THEN   /* Make sure we're positioned to some row. */
    DO:
      {get FirstRowNum iRow}.
      IF iRow = INT(hRowObject:RECID) THEN 
        RETURN.
    END.
    
    hDataQuery:GET-PREV().
    
    IF NOT hRowObject:AVAILABLE THEN
    DO: 
      /* If we are rebuilding the query from the end or some middle point,
         then we have to check to see if there are more rows in the dataset.*/      
      {get RebuildOnRepos lRebuild}.

      IF lRebuild THEN
      DO:
        {get RowObjectState cRowState}.
        IF cRowState = 'RowUpdated':U THEN 
          RUN confirmContinue IN TARGET-PROCEDURE (INPUT-OUTPUT lCancel).
        IF NOT lCancel THEN
        DO:
          PUBLISH 'fetchDataSet':U FROM TARGET-PROCEDURE ('PrevStart':U).
          lOk = DYNAMIC-FUNCTION('retrieveBatch':U IN TARGET-PROCEDURE,'PREV':U,?).
          PUBLISH 'fetchDataSet':U FROM TARGET-PROCEDURE ('NextEnd':U).
        END.
      END. /* if lRebuild */

      /*  no more records */
      IF NOT lok THEN
      DO:
        hDataQuery:GET-FIRST().        
        RETURN. 
      END. /* IF ReturnRows = 0 */
    END. /* IF not hRowObject:available */    
    RUN rowChanged IN TARGET-PROCEDURE ("PREV":U). 
   
  RETURN.  
END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-filterContainerHandler) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE filterContainerHandler Procedure 
PROCEDURE filterContainerHandler :
/*------------------------------------------------------------------------------
  Purpose:     Adds the Filter link between itself and a Filter container.  
               Called from startFilter after the Filter container is 
               contructed.  
  Parameters:  phFilterContainer AS HANDLE - handle of the Filter container
  Notes:       The code to add the Filter link has been separated from 
               startFilter so that filterContainerHandler can be overridden
               to add other links between this object and the Filter container.
------------------------------------------------------------------------------*/
DEFINE INPUT PARAMETER phFilterContainer AS HANDLE NO-UNDO.

  RUN addLink IN TARGET-PROCEDURE ( phFilterContainer , 'Filter':U , TARGET-PROCEDURE  ).

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-initializeObject) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE initializeObject Procedure 
PROCEDURE initializeObject :
/*------------------------------------------------------------------------------
  Purpose:     initialize the dataview (before the data request).
  Parameters:  <none>
  Notes:       Initialization of the dataview may happen before the actual 
               data definition, data retrieval and query opening.  
             - The definitions may arrive together with the data later. 
             - When the dataview is on a container data are retrieved as part
               of the container's initialization after all dataviews has been
               initialized. 
             - An override can manipulate query properties or other request 
               related information, but should not assume that any table or 
               field definitions are available. The startObject captures the 
               event of first time retieval of definitions as well as data, 
               unless OpenOnInit is false.
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hContainerSource      AS HANDLE     NO-UNDO.
  DEFINE VARIABLE lOpen                 AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE hSource               AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hCommitSource         AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cDataTable            AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cTables               AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE lInitialized          AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lContainerInitialized AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lHideOnInit           AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cFetchOnOpen          AS CHARACTER  NO-UNDO.

  &SCOPED-DEFINE xp-assign
  {get ObjectInitialized lInitialized}
  {get ContainerSource hContainerSource}
  {get DataTable cDataTable}
  {get Tables cTables}
  {get DataSource hSource}
  {get CommitSource hCommitSource}
  {get HideOnInit lHideOnInit}.
  .
  &UNDEFINE xp-assign
  /* sorry not again */
  IF lInitialized THEN
    RETURN.
  
  IF NOT lHideOnInit THEN 
  DO:
    /* The Objecthidden is set and used also for non-visual objects */
    {set ObjectHidden NO}.
    PUBLISH "LinkState":U FROM TARGET-PROCEDURE ('active':U).  
  END.
  ELSE DO:
    /* The Objecthidden is set and used also for non-visual objects */
    {set ObjectHidden YES}.
    PUBLISH "LinkState":U FROM TARGET-PROCEDURE ('inactive':U).  
  END.

  /* If this object has a Commit-Source (a Commit Panel or the like) then
     we set the AutoCommit flag off.  */
  IF VALID-HANDLE(hCommitSource) THEN
    {set AutoCommit NO}.

  /* The tools will set Tables and DataQueryString, but this ensures runtime 
     default of single table retrieval for runtime instances that only 
     defines BusinessEntity and DataTable.   
     (getViewTables, getQueryTables and getQueryStringDefault will reflect this)
     This may very well change in the future (implementation and/or behavior)*/
  IF cTables = '':U THEN
    {set Tables cDataTable}.

  IF VALID-HANDLE(gshProfileManager) THEN
    RUN retrieveFilter IN TARGET-PROCEDURE.
  
  IF VALID-HANDLE(hContainerSource) THEN
    {get ObjectInitialized lContainerInitialized hContainerSource}.
  
  IF NOT VALID-HANDLE(hContainerSource) 
  OR lContainerInitialized THEN
  DO:
    {get FetchOnOpen cFetchOnOpen}.
    DYNAMIC-FUNCTION('retrieveData':U IN TARGET-PROCEDURE,cFetchOnOpen,YES,?).
    RUN startObject IN TARGET-PROCEDURE. 
  END.  
END.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-isUpdateActive) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE isUpdateActive Procedure 
PROCEDURE isUpdateActive :
/*------------------------------------------------------------------------------
  Purpose: Received from container source to check if contained objects have 
           unsaved or uncommitted changes, including addMode.           
    Notes: This is published thru the container link from canExit for 
           close logic ( ok, cancel, exit).
          (It is very similar to canNavigate -> isUpdatePending which is 
           published thru the data link)
         - WE currently ONLY check rowObjectState as the other states are 
           checked in the visual objects.      
--------------------------------------------------------------------------------*/
  DEFINE INPUT-OUTPUT PARAMETER plActive AS LOGICAL NO-UNDO.
  DEFINE VARIABLE cRowObjectState AS CHARACTER  NO-UNDO.

  IF NOT plActive THEN 
  DO:
    {get RowObjectState cRowObjectState}.
    plActive = (cRowObjectState = 'RowUpdated':U).
  END.

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-isUpdatePending) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE isUpdatePending Procedure 
PROCEDURE isUpdatePending :
/*------------------------------------------------------------------------------
  Purpose:  Published through data-targets to check if any updates are pending.   
  Parameters: input-output plUpdate 
              Returns TRUE and stops the publishing if update is pending. 
  Notes:      New is included as a pending update. 
              Called from canNavigate, which is used by navigating objects to 
              check if they can trust an updateState('updatecomplete') message
          NB! This check is only valid from a DataSource point of view. 
              Use canNavigate to check an actual object.  
------------------------------------------------------------------------------*/
   DEFINE INPUT-OUTPUT PARAMETER plUpdate AS LOGICAL    NO-UNDO.

   DEFINE VARIABLE lNew            AS LOGICAL    NO-UNDO.
   DEFINE VARIABLE lDataModified   AS LOGICAL    NO-UNDO.
   DEFINE VARIABLE lFetched        AS LOGICAL    NO-UNDO.
   DEFINE VARIABLE cRowObjectState AS CHARACTER  NO-UNDO.
   /* No need to check a pending update was found somewhere else */
   IF NOT plUpdate THEN
   DO:

     &SCOPED-DEFINE xp-assign
     {get DataModified lDataModified}
     {get NewMode lNew}
     {get DataIsFetched lFetched}
      .
     &UNDEFINE xp-assign
     
      /* if child on client only for single parent then we cannot navigate 
         if the record has uncomitted changes, so updatepending need to be true */             
     IF lFetched = FALSE THEN
     DO:
       {get RowObjectState cRowObjectState}.
       plUpdate = (cRowObjectstate = 'RowUpdated':U).
     END.

     IF NOT plUpdate THEN
     DO:
       /* unknown is no (NewRow is sometimes ?) */
       plUpdate = (lNew = TRUE) OR (lDataModified = TRUE). 
     
       IF NOT plUpdate THEN 
         PUBLISH 'isUpdatePending':U FROM TARGET-PROCEDURE (INPUT-OUTPUT plUpdate).
     END.
   END. /* not plUpdate */

   RETURN. 
END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-linkState) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE linkState Procedure 
PROCEDURE linkState :
/*------------------------------------------------------------------------------
  Purpose:     Run LinkStateHandler in source(pcState) if ToggleDataTargets
               And publish the state with a potential appended 'Target' 
               Recieved from DataTargets.                                
  Parameters:  pcState AS CHARACTER -- 'active'/'inactive'
               The event is republished up through a groupAssignSource and 
               a DataSource.
             - The logic is separated into processLinkState in order to allow 
               the data class to override this without duplicating all logic.     
------------------------------------------------------------------------------*/
  DEFINE INPUT PARAMETER pcState  AS CHARACTER NO-UNDO.
  
  RUN processLinkState IN TARGET-PROCEDURE(SOURCE-PROCEDURE,pcState).
  
END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-linkStateHandler) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE linkStateHandler Procedure 
PROCEDURE linkStateHandler :
/*------------------------------------------------------------------------------
  Purpose: Override inorder to run dataAvailable when a dataSource link 
           is made active      
  Parameters: see base version in smart.p
  Notes:   Publish dataavailable after a datasource link is activated in order
           to synchronize with the datasource if the link is inactive and the
           datasource does not have an inactive datasource link of its own in
           which case we'll just wait for its publish of dataavailable.   
         - dbaware objects is currently checked to avoid certain logic 
           for objects that inherits from this and run super in order 
           to reach smart. (This class should never be dbaware, so this may be 
           changed to call a method that hides this difference and is complety 
           overriden in dbaware objects or the base smart may be moved to a 
           method that is called directly from the override)                            
------------------------------------------------------------------------------*/
  DEFINE INPUT PARAMETER pcState   AS CHARACTER  NO-UNDO.
  DEFINE INPUT PARAMETER phObject  AS HANDLE     NO-UNDO.
  DEFINE INPUT PARAMETER pcLink    AS CHARACTER  NO-UNDO.

  DEFINE VARIABLE lDataInactive   AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cObjectType     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cDatasetName    AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hDatasetSource     AS HANDLE     NO-UNDO.
  DEFINE VARIABLE iPos            AS INTEGER    NO-UNDO.
   
  IF pcState = 'remove':U AND pcLink = 'DataTarget':U  THEN 
  DO:
    {get ObjectType cObjectType phObject}.
    IF cObjectType = 'SmartDataBrowser':U THEN
    DO:
      {get DatasetSource hDatasetSource}.
      IF VALID-HANDLE(hDatasetSource) THEN
        {fn removeDatasetClone}.     
    END.
  END.

  IF pcState = 'add':U AND pcLink = 'DataTarget':U  THEN 
  DO:
    {get ObjectType cObjectType phObject}.
    IF cObjectType = 'SmartDataBrowser':U THEN
       IF {fn getScrollable} = FALSE THEN 
        {fn addDatasetClone}.     
  END.
 
  IF pcState = 'active':U AND pcLink = 'DataSource':U  THEN
  DO:
    /* if the source is inactive then wait for the dataavailable that it will 
       publish when it becomes active, otherwise check if this object's 
       datasource link was inactive in order to publish dataavailable after 
       the link has been activated  */ 
    IF NOT DYNAMIC-FUNCTION('isLinkInactive':U IN phObject,'DataSource':U,?) THEN 
      lDataInactive = DYNAMIC-FUNCTION('isLinkInactive':U IN TARGET-PROCEDURE,
                                       'DataSource':U,phObject).
  END.
  
  RUN SUPER(pcState,phObject,pcLink).
  
  IF lDataInactive THEN
    RUN dataAvailable IN TARGET-PROCEDURE('RESET':U).
    
END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-obtainExpressionEntries) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE obtainExpressionEntries Procedure 
PROCEDURE obtainExpressionEntries :
/*------------------------------------------------------------------------------
  Purpose:    Obtain one entry of column, operator and value to add to a query 
              for a specific buffer from comma separated lists of columns
              buffers and values    
  Parameters: pcBuffer          - Buffer name to check against 
                                  - 'RowObject' means SDO query which means that 
                                     all columns will be returned with the 
                                     rowObject name. (see NOTES below) 
              piColumn          - Entry to lookup in the lists
              pcColumnList      - Comma separated list of columns 
                                  (see assignQuerySelection )
              pcValueList       - CHR(1) separated list of values 
              pcOperatorList    - Comma separate list of operators 
                                  or single operator for all columns             
                                  The single operator can have an optional 
                                  string operator 'ge/BEGINS 
              output pcColumn   - Column name, resolved with correct 
                                  qualification. 
              output pcOperator - Operator. 
              output pcValue    - Value (with quotes) 
                                - or '?' as ?                         
  Notes:  The optional string operator is not supported before the object is 
          initialized. (datatype is not known)   
       -  Unqualified columns are assumed to be datatable references  
       -  'RowObject' qualified columns are assumed to be datatable references  
------------------------------------------------------------------------------*/
  DEFINE INPUT  PARAMETER pcBuffer       AS CHARACTER  NO-UNDO.
  DEFINE INPUT  PARAMETER piColumn       AS INTEGER    NO-UNDO.
  DEFINE INPUT  PARAMETER pcColumnList   AS CHARACTER  NO-UNDO.
  DEFINE INPUT  PARAMETER pcValueList    AS CHARACTER  NO-UNDO.
  DEFINE INPUT  PARAMETER pcOperatorList AS CHARACTER  NO-UNDO.

  DEFINE OUTPUT PARAMETER pcColumn    AS CHARACTER  NO-UNDO.
  DEFINE OUTPUT PARAMETER pcOperator  AS CHARACTER  NO-UNDO.
  DEFINE OUTPUT PARAMETER pcValue     AS CHARACTER  NO-UNDO.

  DEFINE VARIABLE cStringOperator AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cQuote          AS CHARACTER  NO-UNDO.

  pcColumn = {fnarg resolveColumn "ENTRY(piColumn,pcColumnList)"}.  
  
  IF pcColumn BEGINS pcBuffer + ".":U THEN 
    ASSIGN
      pcValue         = (IF pcValueList <> ? 
                         THEN ENTRY(piColumn,pcValueList,CHR(1))  
                         ELSE "?":U)
      /* Add ~ to single quotes, as we use single quote around the value) */
      pcValue         = (IF pcValue <> "":U 
                         THEN REPLACE(pcValue,"'":U,"~~~'":U)
                         ELSE " ":U)  
      /* Get the operator for this valuelist. 
         Support '',? and '/begins' as default */                                                  
      pcOperator      = IF NUM-ENTRIES(pcOperatorList) > 1 
                        THEN ENTRY(piColumn,pcOperatorList) 
                        ELSE IF pcOperatorList BEGINS "/":U 
                             OR pcOperatorList = ?                       
                             OR pcOperatorList = '':U
                             THEN "=":U 
                             ELSE ENTRY(1,pcOperatorList,"/":U)  
      /* Look for optional string operator if only one entry in operator */          
      cStringOperator = IF NUM-ENTRIES(pcOperatorList,"/":U) = 2  
                        THEN ENTRY(2,pcOperatorList,"/":U)                                                 
                        ELSE ' ':U 
      pcOperator      = IF cStringOperator = '':U 
                        THEN pcOperator
                        ELSE IF {fnarg columnDataType pcColumn} = 'CHARACTER':U
                             THEN cStringOperator
                             ELSE pcOperator
      /* We are quoting ALL values except ? to ensure that decimals behave in both 
         american and european format and to avoid having to check the datatype
         unless absolutely necessary (only if stringoperator is defined).  
         Unknown values must not be quoted for characters, we do not support '?' 
         unquoted works for all types (Matches and begins does not compile
         with ? so they are quoted) */ 

      cQuote          = (IF pcValue = "?":U 
                         AND pcOperator <> 'BEGINS':U 
                         AND pcOperator <> 'MATCHES':U 
                         THEN "":U 
                         ELSE "'":U)   
     
      /* From 9.1B the quotes are included in the value to avoid problems
         when replacing unquoted ? to a quoted value */     
      pcValue         = cQuote + pcValue + cQuote
      .
  ELSE
    pcColumn = ''. 

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-printToCrystal) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE printToCrystal Procedure 
PROCEDURE printToCrystal :
/*------------------------------------------------------------------------------
  Purpose:     Transfers the contents of the SDO to Crystal
  Parameters:  input field list or leave blank for all (no table prefix)
               input include object fields yes/no
               input maximum records to process
  Notes:      
------------------------------------------------------------------------------*/
  DEFINE INPUT PARAMETER pcFieldList            AS CHARACTER    NO-UNDO.
  DEFINE INPUT PARAMETER plIncludeObj           AS LOGICAL      NO-UNDO.
  DEFINE INPUT PARAMETER piMaxRecords           AS INTEGER      NO-UNDO.
  
  RUN exportData IN TARGET-PROCEDURE ('Crystal':U,
                                      pcFieldList,
                                      plIncludeObj,
                                      ?,  /* use existing currently ignored for Crystal*/
                                      piMaxRecords).

  RETURN.

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-processLinkState) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE processLinkState Procedure 
PROCEDURE processLinkState :
/*------------------------------------------------------------------------------
  Purpose:     Processes the passed linkState event received from the passed 
               datatarget. 
               Publishes the state with a potential appended 'Target' 
  Parameters:  phDataTarget - Publisher of linkstate 
               pcState      - 'active'/'inactive'
      Notes:   Separated out of linkState primarily to allow data extentions to 
               override linkState without duplicating all logic. 
               See linkState for external info.            
------------------------------------------------------------------------------*/
  DEFINE INPUT  PARAMETER phDataTarget AS HANDLE     NO-UNDO.
  DEFINE INPUT  PARAMETER pcState      AS CHARACTER  NO-UNDO.
  
  DEFINE VARIABLE cTargets         AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE iTarget          AS INTEGER    NO-UNDO.
  DEFINE VARIABLE hTarget          AS HANDLE     NO-UNDO.
  DEFINE VARIABLE lRePublish       AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cObjectType      AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hContainer       AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hGASource        AS HANDLE     NO-UNDO.  
  DEFINE VARIABLE lHidden          AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lVisualSource    AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lToggleTargets   AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lActiveTarget    AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lInitialized     AS LOGICAL    NO-UNDO.
  
  {get ObjectInitialized lInitialized}.
  IF NOT linitialized THEN
     RETURN.

  /* Ignore 'activeTarget' and 'inactiveTarget' published from child SDOs/SBOs 
     to only reach the navigationSource */
  IF NOT CAN-DO('active,inactive':U,pcState ) THEN
    RETURN.

  {get ContainerHandle hContainer phDataTarget}.
  lVisualSource = VALID-HANDLE(hContainer).
  IF lVisualSource THEN
  DO:
    /* Ignore this if it's from a GA Target. 
      (it is published up through the GA-link and will reach us from the source)*/ 
    {get GroupAssignSource hGaSource phDataTarget} NO-ERROR.
    IF VALID-HANDLE(hGaSource) THEN
       RETURN.
    
    /* Ignore an 'inactive' message from a visual object if it or any of the 
       GAtargets are visible (or will become visible) */
    IF pcState = 'inactive':U THEN
    DO:
      {get GroupAssignHidden lHidden phDataTarget} NO-ERROR.
      IF NOT lHidden THEN
        RETURN.
    END.
  END.
  /* Check if we are supposed to toggle DataTarget links active/inactive */ 
  {get ToggleDataTargets lToggleTargets}.
  
  /* If toggle and state is 'inactive' set to NOT toggle if cannavigate false*/ 
  IF lToggleTargets 
  AND pcState = 'inactive':U THEN 
  DO:                     
    lToggleTargets = {fn canNavigate phDataTarget} NO-ERROR. 
    IF lToggleTargets = ? THEN 
      lToggleTargets = TRUE.
  END.
  
  IF lToggleTargets THEN
  DO:
    /* We keep the SDB active since it is to be disabled on changes
       from below and it also is more of a hazzle to reposition it if we 
       did disable it */
    {get ObjectType cObjectType phDataTarget}.
    IF cObjectType <> 'SmartDataBrowser':U THEN
    DO:
      RUN linkStateHandler IN phDataTarget 
                  (pcState,TARGET-PROCEDURE,'DataSource':U).
    END.
  END.
  
  /* If 'inactive' we must verify that all the targets also are 'inactive' */         
  IF pcState = 'inactive':U AND lToggleTargets THEN
  DO:
    {get DataTarget cTargets}.
    DO iTarget = 1 TO NUM-ENTRIES(cTargets):
      hTarget = WIDGET-HANDLE(ENTRY(iTarget,cTargets)). 
      /* skip the publisher */
      IF hTarget = phDataTarget THEN
        NEXT.
      
      /* Is this a visual target?  */
      {get ContainerHandle hContainer hTarget}.
      IF VALID-HANDLE(hContainer) THEN
      DO:
        /* Don't check GATargets */
        {get GroupAssignSource hGaSOurce hTarget} NO-ERROR.
        IF NOT VALID-HANDLE(hGaSource) THEN
        DO:
          {get GroupAssignHidden lHidden hTarget} NO-ERROR.
          /* Ignore the message if 'inactive' and a visual object or any of
             its Group Assign targets are visible (or will become visible)*/
        END.
      END. /* valid Containerhandle  (visual) */
      ELSE 
        lHidden = DYNAMIC-FUNCTION('isLinkInactive':U IN hTarget,
                                   'DataSource':U,
                                   TARGET-PROCEDURE).
      
      IF NOT lHidden THEN
      DO:
        /* If an active target and the message is from a non-visual object 
           just get out as there is no need to republish */
        IF NOT lVisualSource THEN
          RETURN.

        lActiveTarget = TRUE.
        LEAVE.
      END.
    END. /* DataTarget loop */
  END. /* state = 'inactive' ans lToggleSource  */
  /* active */
  ELSE IF pcState = 'active':U AND NOT lVisualSource THEN
  DO:
    /* No need to republish an active message from a non-visual target if the 
       link already is active */
    IF NOT DYNAMIC-FUNCTION('isLinkInactive':U IN TARGET-PROCEDURE,
                            'DataSource':U,?) THEN
      RETURN.
  END.

  /* If not toggleDataTargets or any active target found for an 'inactive' 
     state then append 'target' so the DataSource ignores it, but the 
     Navigationsource reacts to it */ 
  IF NOT lToggleTargets OR lActiveTarget THEN
    pcState = pcstate + 'Target':U.
  
  PUBLISH 'linkState':U FROM TARGET-PROCEDURE (pcState). 

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-refreshDataQuery) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE refreshDataQuery Procedure 
PROCEDURE refreshDataQuery :
/*------------------------------------------------------------------------------
  Purpose: Open the data query     
  Parameters:  
  Notes:   buildDataRequest subscribes this to the requestor's 
           "dataRequestComplete" event in case the normal post request flow 
           won't open/refresh this object. 
           (for example for a lookup not opened at initialization)               
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cPublisherType AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hDatasetSource AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cContext       AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cDataTable     AS CHARACTER  NO-UNDO.

  &SCOPED-DEFINE xp-assign
  {get DatasetSource hDatasetSource}
  {get DataTable cDataTable}
  .
  &UNDEFINE xp-assign

  cContext = {fnarg tableContext cDataTable hDatasetSource}.

  {fnarg applyContextFromServer cContext}.

  cPublisherType = {fn getObjectType SOURCE-PROCEDURE} NO-ERROR.
  IF cPublisherType <> 'SUPER':U THEN
    UNSUBSCRIBE PROCEDURE TARGET-PROCEDURE TO 'DataRequestComplete':U IN SOURCE-PROCEDURE. 
   
  {fnarg openDataQuery ''}.
   
  RETURN.

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-refreshRow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE refreshRow Procedure 
PROCEDURE refreshRow :
/*------------------------------------------------------------------------------
  Purpose:     To retrieve the current database values for a row already
               in the RowObject table.

  Parameters:  <none>
  
  Notes:       PUBLISHes dataAvailable ('SAME') to cause a SDViewer or
               Browser to display the latest values.
------------------------------------------------------------------------------*/

  DEFINE VARIABLE hDataQuery      AS HANDLE    NO-UNDO.
  DEFINE VARIABLE hRowObject      AS HANDLE    NO-UNDO.
  DEFINE VARIABLE iRows           AS INTEGER   NO-UNDO.
  DEFINE VARIABLE cRowIdent       AS CHARACTER NO-UNDO.
  DEFINE VARIABLE cRowState       AS CHARACTER NO-UNDO.
  DEFINE VARIABLE iRowNum         AS INTEGER   NO-UNDO.
  DEFINE VARIABLE lNewRow         AS LOG       NO-UNDO.
  DEFINE VARIABLE rRowid          AS ROWID     NO-UNDO.
  DEFINE VARIABLE lDeleted        AS LOGICAL   NO-UNDO.
  
  DEFINE VARIABLE iTarget         AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cTargets        AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hTarget         AS HANDLE     NO-UNDO.
  DEFINE VARIABLE lQueryObject    AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cDisabled       AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE lOk             AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lMessage        AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lTracking       AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lRebuild        AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cKeyWhere       AS CHARACTER  NO-UNDO.

   /* Nothing to refresh ..  */
  &SCOPED-DEFINE xp-assign
  {get NewRow lNewRow}    
  {get DataHandle hDataQuery}
  {get RowObject  hRowObject}
  {get RowObjectState cRowState}
  {get KeyWhere cKeyWhere}
  .
  &UNDEFINE xp-assign
  
  IF cRowState = 'RowUpdated':U THEN
  DO: /* if updates are in progress, can not continue */
     DYNAMIC-FUNCTION("showMessage":U IN TARGET-PROCEDURE, "24":U).
     RUN showMessageProcedure IN TARGET-PROCEDURE 
                 ('24':U, OUTPUT lMessage).
     RETURN.
  END.  /* if cRowState = rowupdated */
  
  IF lNewRow THEN 
    RETURN.  
  IF NOT hRowObject:AVAILABLE THEN
    RETURN.


  ASSIGN
    lTracking = hRowObject:TABLE-HANDLE:TRACKING-CHANGES
    hRowObject:TABLE-HANDLE:TRACKING-CHANGES = FALSE.

  hRowObject:BUFFER-DELETE().      /* remove the old copy of the row. */
  
  /** find the prev rec as we want to position to it in case the refresh is
      gone (so why not next? at least in a browse this is less slick and
      makes it easier to see that weird stuff happened...maybe...? ) */ 
  hDataQuery:GET-PREV. 
  IF NOT hRowObject:AVAIL THEN
    hdataQuery:GET-FIRST.

  rRowid = hRowObject:ROWID.

  /* deactivate links to child objects  */
 {get Datatarget cTargets}.
  DO iTarget = 1 TO NUM-ENTRIES(cTargets):
    hTarget = WIDGET-HANDLE(ENTRY(iTarget,cTargets)).
    IF VALID-HANDLE(hTarget) THEN
    DO:
      {get QueryObject lQueryObject hTarget}.
      IF lQueryObject THEN 
      DO:
        RUN linkStateHandler IN hTarget ("inactive":U,
                                         TARGET-PROCEDURE,
                                         "DataSource":U).
        cDisabled = cDisabled
                  + (IF iTarget = 1 THEN '':U ELSE ',':U)
                  + STRING(hTarget).
      END. /* QueryObject*/
    END. /* valid datatarget */
  END. /* Do iTarget = 1 to NUM */
  /**/
  
  {get RebuildOnRepos lRebuild}.
  /* retrieveBatch empties child TTs if rebuild, so turn it off if necessary 
     (A more specific refreshfromserver method could possibly be added  *)*/
  IF lRebuild THEN
    {set RebuildOnRepos FALSE}.

  lOk = DYNAMIC-FUNCTION('retrieveBatch':U IN TARGET-PROCEDURE,cKeyWhere,1).
  
  IF lRebuild THEN
    {set RebuildOnRepos TRUE}.

  IF lTracking THEN
    hRowObject:TABLE-HANDLE:TRACKING-CHANGES = TRUE.


  /* reactivate links that was deactivated before the request */
  DO iTarget = 1 TO NUM-ENTRIES(cDisabled):
    hTarget = WIDGET-HANDLE(ENTRY(iTarget,cDisabled)).
    IF VALID-HANDLE(hTarget) THEN
       RUN linkStateHandler IN hTarget ("active":U,
                                         TARGET-PROCEDURE,
                                         "DataSource":U).
  END. /* do iTarget = 1 to */
  
  /* If nothing to refresh resort to plan B */
  IF NOT lOk THEN
  DO:
    /* Get rid of the non existing row from the browse 
      (this is probably only necessary when no reposition has been done) */
    PUBLISH 'refreshBrowse':U FROM TARGET-PROCEDURE.
    lDeleted  = TRUE.
    IF rRowid <> ? THEN
      hdataQuery:REPOSITION-TO-ROWID(rRowid).
  END.

  /* Tell everyone we have a new copy of the same row. */
  RUN rowChanged IN TARGET-PROCEDURE(IF lDeleted THEN 'DIFFERENT':U ELSE 'SAME':U).

  RETURN.
END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-retrieveFilter) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE retrieveFilter Procedure 
PROCEDURE retrieveFilter :
/*------------------------------------------------------------------------------
  Purpose:     
  Parameters:  <none>
  Notes:       
------------------------------------------------------------------------------*/
DEFINE VARIABLE hContainerSource                AS HANDLE       NO-UNDO.
DEFINE VARIABLE cContainerName                  AS CHARACTER    NO-UNDO.
DEFINE VARIABLE cSdoName                        AS CHARACTER    NO-UNDO.
DEFINE VARIABLE cSdoSignature                   AS CHARACTER    NO-UNDO.
DEFINE VARIABLE rRowid                          AS ROWID        NO-UNDO.
DEFINE VARIABLE cFilterSettings                 AS CHARACTER    NO-UNDO.
DEFINE VARIABLE cRUnAttribute                   AS CHARACTER    NO-UNDO.
DEFINE VARIABLE cFieldNames                     AS CHARACTER    NO-UNDO.
DEFINE VARIABLE cFieldValues                    AS CHARACTER    NO-UNDO.
DEFINE VARIABLE cFieldOperators                 AS CHARACTER    NO-UNDO.
DEFINE VARIABLE lSuccess                        AS LOGICAL      NO-UNDO.
DEFINE VARIABLE cAssignQuerySelection           AS CHARACTER    NO-UNDO.
DEFINE VARIABLE iLoop                           AS INTEGER      NO-UNDO.
DEFINE VARIABLE cEntry                          AS CHARACTER    NO-UNDO.
DEFINE VARIABLE iRowsToBatch                    AS INTEGER      NO-UNDO.
DEFINE VARIABLE lRebuildOnRepos                 AS LOGICAL      NO-UNDO.
DEFINE VARIABLE iCnt                            AS INTEGER      NO-UNDO.
DEFINE VARIABLE cField                          AS CHARACTER    NO-UNDO.
DEFINE VARIABLE lFilterActive                   AS LOGICAL      NO-UNDO.
DEFINE VARIABLE cColumnSelection                AS CHARACTER  NO-UNDO.
    
    IF VALID-HANDLE(gshProfileManager) THEN
    DO: 
      {get ContainerSource hContainerSource}.
      IF VALID-HANDLE(hContainerSource) THEN
      DO:
        {get ObjectName cSdoName}. 
        {get LogicalObjectName cContainerName hContainerSource}.
        IF cContainerName EQ "":U OR cContainerName EQ ? THEN
            ASSIGN cContainerName = hContainerSource:FILE-NAME.
        
        ASSIGN   /* Keep signature similar to sbo/sdo */ 
          cSdoSignature = cSdoName + ",":U + '':U + ",":U + cContainerName + ",":U + cRunAttribute
          rRowid        = ?.
        
        RUN getProfileData IN gshProfileManager (
            INPUT "BrwFilters":U,
            INPUT "FilterSet":U,
            INPUT cSdoSignature,
            INPUT NO,
            INPUT-OUTPUT rRowid,
            OUTPUT cFilterSettings).
        
        IF cFilterSettings <> "" AND NUM-ENTRIES(cFilterSettings,CHR(3)) = 3 THEN
        DO:
            ASSIGN
              cFieldNames     = ENTRY(1,cFilterSettings,CHR(3))
              cFieldValues    = ENTRY(2,cFilterSettings,CHR(3))
              cFieldOperators = ENTRY(3,cFilterSettings,CHR(3))
              .
            /* if assignQuerySelection already is set with this field 
               then ignore the profile setting 
               (The fact that the field is in the profile will make the 
                field available in the filter even if it also is assigned
                from elsewhere ) */
            DO iCnt = 1 TO NUM-ENTRIES(cFieldNames):
              ASSIGN 
                cField           = ENTRY(iCnt, cFieldNames).
                cColumnSelection = DYNAMIC-FUNCTION("ColumnQuerySelection":U IN TARGET-PROCEDURE,
                                                    cField).

              IF cColumnSelection > '' THEN
              DO:
                ASSIGN 
                  cFieldNames  = DYNAMIC-FUNCTION("deleteEntry":U IN TARGET-PROCEDURE,
                                                 iCnt,cFieldNames,",":U)
                  cFieldValues = DYNAMIC-FUNCTION("deleteEntry":U IN TARGET-PROCEDURE,
                                                  iCnt,cFieldValues,CHR(1))
                  cFieldOperators = DYNAMIC-FUNCTION("deleteEntry":U IN TARGET-PROCEDURE,
                                                      iCnt,cFieldOperators,",":U)
                  .
              END.
            END.
            
            /* Set FilterActive property true if filter was applied */
            IF cFieldNames <> "":U THEN 
            DO:
              {set FilterActive TRUE}.           
              /* assign the retrieved criteria */                                                  
              lSuccess = DYNAMIC-FUNC("assignQuerySelection":U IN TARGET-PROCEDURE,
                                       cFieldNames,
                                       cFieldValues,
                                       cFieldOperators).
            END.                   
        END.

        /* Store the current (default) rowsToBatch and rebuildOnRepos settings in case *
         * used in filter when resetting default SDO values.         */
        &SCOPED-DEFINE xp-assign
        {get rowsToBatch iRowsToBatch}
        {get rebuildOnRepos lRebuildOnRepos}
        .
        &UNDEFINE xp-assign
        
        RUN setProfileData IN gshProfileManager (
            INPUT "SDO":U,
            INPUT "Attributes":U,
            INPUT cSDOSignature + ",defAttrs":U,
            INPUT ?,
            INPUT STRING(iRowsToBatch) + CHR(3) + STRING(lRebuildOnRepos),
            INPUT NO,
            INPUT "SES":U). /* We NEVER want to save this profile permanently, always session only */
      END. /* Valid container */
    END.  /* valid profile manager */
END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-rowChanged) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE rowChanged Procedure 
PROCEDURE rowChanged :
/*------------------------------------------------------------------------------
  Purpose: Event procedure called on any change or reposition.      
  Parameters:  pcMode - Event modifier to pass along to data-targets.                         
                       (This modifier is currently just passed on to 
                        dataAvailable and is somewhat irrelevant for this
                        event)
                        
  Notes:   This event encapsulates the events that all linked objects 
           (data-targets and navigation-sources) subscribes to in order to 
           reflect the current state of the object.
         - This diagram shows how these two event reaches all involved objects 
           including indirectly linked objects like a data-target's tableio-source 
           
           updateQueryPosition  
            -> QueryPosition 
                [datavis]    - enable/disable 
                             -> [tableio] - reset 
                [navigation] - reset
           -> DataAvailable  
                [datavis]    - display 
                               - setDataValue[field] - findRowWhere
                                                       - rowChanged  
                [dataview]   - add foreign key 
                             - open* - fetch* 
                                       - rowChanged       
                                        
------------------------------------------------------------------------------*/
  DEFINE INPUT  PARAMETER pcMode AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cValue          AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hBuffer         AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hDatasetSource  AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cRelationfields AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE iField          AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cChildField     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cParentField    AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cParentValue    AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cChildValue     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cWhere          AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE lPos            AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE hQuery          AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hQueryBuffer    AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hRowObject      AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cViewTables     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cQueryTables    AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE iTable          AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cTable          AS CHARACTER  NO-UNDO.
  
  /* Set QueryPosition from FirstRowNum, LastRowNum  */
  RUN updateQueryPosition IN TARGET-PROCEDURE.
  
  &SCOPED-DEFINE xp-assign
  {get DatasetSource hDatasetSource}
  {get DataHandle hQuery}
  {get QueryTables cQueryTables}
  {get ViewTables cViewTables}
  {get RowObject hRowObject}
  {get DatasetSource hDatasetSource}
   .
  &UNDEFINE xp-assign
  
  /* position view tables not in the query */
  IF VALID-HANDLE(hDatasetSource) THEN 
  DO iTable = 2 TO NUM-ENTRIES(cViewTables):
    cTable = ENTRY(iTable,cViewTables).
    IF LOOKUP(cTable,cQueryTables) = 0 THEN
    DO:
      hBuffer = {fnarg dataTableHandle cTable hDatasetSource}.
      IF hRowObject:AVAILABLE THEN
      DO:
        cRelationFields = DYNAMIC-FUNCTION("relationFields":U IN hDatasetSource,
                                            hRowObject:NAME,
                                            cTable).

        ASSIGN 
          lPos   = TRUE  /* assume correct position */
          cWhere = '':U.
        DO iField = 1 TO NUM-ENTRIES(cRelationFields) BY 2:
          ASSIGN
            cParentField = ENTRY(1,cRelationFields)
            cChildField  = ENTRY(2,cRelationFields)
            cParentValue = QUOTER(hRowObject:BUFFER-FIELD(ENTRY(2,cParentField,'.':U)):BUFFER-VALUE)
            cChildValue  = IF hBuffer:AVAIL 
                           THEN QUOTER(hBuffer:BUFFER-FIELD(ENTRY(2,cChildField,'.':U)):BUFFER-VALUE)
                           ELSE '?':U
            cWhere       = cWhere 
                         + (IF ifield = 1 THEN 'WHERE ':U ELSE ' AND ':U)
                         + cChildField + ' = ':U + cParentValue 
            lPos         = IF lPos THEN (cChildValue = cParentValue) ELSE FALSE.
        END.
        IF NOT lPos THEN
          hBuffer:FIND-UNIQUE(cWhere) NO-ERROR.
      END. /* rowobject avail */
      ELSE 
        hBuffer:BUFFER-RELEASE().
    END.  /* table not in query */
  END. /* do itable = 2 to num-entires viewtables */

  PUBLISH 'dataAvailable':U FROM TARGET-PROCEDURE (pcMode).

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-rowObjectState) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE rowObjectState Procedure 
PROCEDURE rowObjectState :
/*------------------------------------------------------------------------------
  Purpose:    To pass on the flag which indicates when a SmartDataObject row 
              has been changed locally but not committed. This gets passed on 
              until it reaches the Commit Panel or other first Commit-Source. 
  Parameters:
    INPUT pcState - the new state
  
  Notes:    - The event is ignored for autocommit objects  
            - As of current we check the publisher and ignore the state 
              if it is from a separate entity instance. 
             (The event is published up the data-source chain so we may
              get this event from children on different enitities)
            - On the other hand, if the publisher is not an SDO we currently 
              accept the event.. (assuming this must be someone knowing 
              what their doing...as this would not be default).       
------------------------------------------------------------------------------*/
  DEFINE INPUT PARAMETER pcState AS CHARACTER NO-UNDO.
  
  DEFINE VARIABLE lAutoCommit        AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cPublisherType     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hDatasetSource     AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hPublisherDSSource AS HANDLE     NO-UNDO.

  &SCOPED-DEFINE xp-assign
  {get DatasetSource hDatasetSource}
  {get AutoCommit lAutoCommit}
  .
  &UNDEFINE xp-assign
  
  IF NOT lAutoCommit AND VALID-HANDLE(hDatasetSource) THEN
  DO:
    {get ObjectType cPublisherType SOURCE-PROCEDURE}.
    IF cPublisherType = 'SmartDataObject':U THEN 
    DO:
      /* Actively ignore if from a separate entity */
      {get DatasetSource hPublisherDSSource SOURCE-PROCEDURE}.
      IF hPublisherDSSource <> hDataSetSource THEN
        RETURN.
    END. /* cPublisherType = 'SmartDataObject':U */
    {set RowObjectState pcState}.  
  END. 

  RETURN.

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-startFilter) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE startFilter Procedure 
PROCEDURE startFilter :
/*------------------------------------------------------------------------------
  Purpose:     View/Start the filter-source
  Parameters:  <none>
  Notes:       
------------------------------------------------------------------------------*/
   DEFINE VARIABLE hFilterSource    AS HANDLE    NO-UNDO.
   DEFINE VARIABLE hWindow          AS HANDLE    NO-UNDO.
   DEFINE VARIABLE lHide            AS LOGICAL   NO-UNDO.
   DEFINE VARIABLE hFilterContainer AS HANDLE    NO-UNDO.
   DEFINE VARIABLE hMyContainer     AS HANDLE    NO-UNDO.
   DEFINE VARIABLE cFilterWindow    AS CHARACTER NO-UNDO.
      
   {get FilterSource hFilterSource}.
   
   IF VALID-HANDLE(hFilterSource) THEN 
   DO:
     {get ContainerSource hFilterContainer hFilterSource}.
     {get ContainerSource hMyContainer}.    
     IF hMyContainer <> hFilterContainer THEN
     DO:
       {set FilterWindow hFilterContainer:FILE-NAME}.
       {get HideOnInit lHide hFilterContainer}. 
     
       /* Workaround to make it visible if it's hideoninit */
       IF lHide THEN 
        RUN destroyObject in hFilterContainer.
     END.
   END.
   
   IF NOT VALID-HANDLE(hFilterContainer) THEN 
   DO:
     {get FilterWindow cFilterWindow}.     
     IF cFilterWindow <> '':U THEN
     DO:
       {get ContainerSource hMyContainer}.    
       {get ContainerHandle hWindow}.
      
       RUN constructObject IN hMyContainer (
             INPUT  cFilterWindow,
             INPUT  hWindow,
             INPUT  'HideOnInit' + CHR(4) + 'no' + CHR(3) 
                    + 
                    'DisableOnInit' + CHR(4) + 'no' + CHR(3) 
                    + 
                    'ObjectLayout' + CHR(4),
             OUTPUT hFilterContainer).
      /* filterContainerHandler adds the Filter link between this object
         and the Filter container */
       RUN filterContainerHandler IN TARGET-PROCEDURE ( hFilterContainer ).
       RUN initializeObject IN hFilterContainer.  
     END.
   END.    
   
   RUN viewObject IN hFilterContainer.
   
END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-startObject) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE startObject Procedure 
PROCEDURE startObject :
/*------------------------------------------------------------------------------
  Purpose: Start the object after data and/or definitions have been retrieved.
  Parameters:  <none>
  Notes:   This event completes the initialization of the object.  
         - Sets ObjectInitialized to true to reflect that definitions are 
           present and all handle properties are defined and that the object is 
           ready for action.  
         - It can be overridden to deal with logic that require that the
           definitions and handles are present (after SUPER). 
         - The dataview's initializeObject is a pre-request event that does not 
           retrieve data or definitions when the dataview instance is managed by
           a container and should only be overidden to manipulate query 
           properties or other request related information.
         - It will be called as part of object initialization either by the 
           container or by the object itself and should not be called by 
           application code. 
         - Framework code must ensure that initializeObject is being run and
           that the dataset (data is optional) are available in the 
           datacontainer before calling this.       
         - This may be called on receival of an asynchronous data request.  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hDataSource        AS HANDLE     NO-UNDO.
  DEFINE VARIABLE lParentInitialized AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lScrollable        AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lOpen              AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lOpened            AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cPublisherType     AS CHARACTER  NO-UNDO.

  &SCOPED-DEFINE xp-assign
  {get DataSource hDataSource}
  {get OpenOnInit lOpen}
   /* This completes the initialization, so set the flag accordingly */
  {set ObjectInitialized TRUE}
  .
  &UNDEFINE xp-assign
  
  cPublisherType = {fn getObjectType SOURCE-PROCEDURE} NO-ERROR.
  IF cPublisherType <> 'SUPER':U THEN
    UNSUBSCRIBE PROCEDURE TARGET-PROCEDURE TO 'DataRequestComplete':U IN SOURCE-PROCEDURE. 

  RUN createObjects IN TARGET-PROCEDURE.

  IF lOpen THEN 
  DO:
    IF VALID-HANDLE(hDataSource) THEN
    DO:
      {get ObjectInitialized lParentInitialized hDataSource}.
      /* If parent is not initted then just wait for its publish dataAvailable */
      IF lParentInitialized THEN
        RUN dataAvailable IN TARGET-PROCEDURE ('RESET':U).
    END.
    ELSE DO: 
      {get Scrollable lScrollable}.
      /* Only open query for scrollable objects 
        (findRowwhere handles positioning for non-scrollable) */
      IF lScrollable THEN
        {fn openDataView}.
    END.
  END. /* openononit */

  /*
  ELSE 
    RUN rowChanged IN TARGET-PROCEDURE('RESET':U).
  */


END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-tableOut) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE tableOut Procedure 
PROCEDURE tableOut :
/*-----------------------------------------------------------------------------
  Purpose:     Output requested fields of SDO in standard temp-table
  Parameters:  pcFieldList    - input field list
                   - !exclude-1,!exclude-2,...,!exclude-n,*
                   - field-1,field-2,...,field-n,!exclude-1,...,!exclude-n

               plIncludeObj   - input include object fields yes/no
               piMaxRecords   - input maximum records to process
               ttTable        - output temp-table of data from sdo
               iExtractedRecs - output number of records extracted
  
  Notes:       Temp table is defined in afttsdoout.i
               Fields passed in are checked with a can-do so support * for all
               or !field to exclude a field, e.g.
               "!RowNum,!RowIdent,!RowMod, *" would use all non SDO specific
               fields.           
------------------------------------------------------------------------------*/

DEFINE INPUT  PARAMETER pcFieldList                AS CHARACTER  NO-UNDO.
DEFINE INPUT  PARAMETER plIncludeObj               AS LOGICAL    NO-UNDO.
DEFINE INPUT  PARAMETER piMaxRecords               AS INTEGER    NO-UNDO.
DEFINE OUTPUT PARAMETER TABLE FOR ttTable.
DEFINE OUTPUT PARAMETER iExtractedRecs            AS INTEGER    NO-UNDO.

DEFINE VARIABLE iRowNum                           AS INTEGER    NO-UNDO.
DEFINE VARIABLE iColNum                           AS INTEGER    NO-UNDO.
DEFINE VARIABLE iField                            AS INTEGER    NO-UNDO.
DEFINE VARIABLE lAvailable                        AS LOGICAL    NO-UNDO.

DEFINE VARIABLE iRowsToBatch                      AS INTEGER    NO-UNDO.
DEFINE VARIABLE iNumRecords                       AS INTEGER    NO-UNDO.
DEFINE VARIABLE cRowIdent                         AS CHARACTER  NO-UNDO.

/* Variables for Security Check of Fields */
DEFINE VARIABLE cQueryPosition      AS CHARACTER  NO-UNDO.
DEFINE VARIABLE hContainerHandle    AS HANDLE     NO-UNDO.
DEFINE VARIABLE cRunAttribute       AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cContainerName      AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cSecuredFields      AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cHiddenFields       AS CHARACTER  NO-UNDO.
DEFINE VARIABLE iLoop               AS INTEGER    NO-UNDO.
DEFINE VARIABLE cFieldName          AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cNewFieldList       AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cCanDoList          AS CHARACTER  NO-UNDO.

DEFINE VARIABLE hBrowser            AS HANDLE                   NO-UNDO.
DEFINE VARIABLE hBrowseColumn       AS HANDLE                   NO-UNDO.
DEFINE VARIABLE hDataTarget         AS HANDLE                   NO-UNDO.
DEFINE VARIABLE cDataTargets        AS CHARACTER                NO-UNDO.
DEFINE VARIABLE cColumnNames        AS CHARACTER                NO-UNDO.
DEFINE VARIABLE cColumnHandles      AS CHARACTER                NO-UNDO.
DEFINE VARIABLE hNavSource          AS HANDLE                   NO-UNDO.
DEFINE VARIABLE cColumn             AS CHARACTER                NO-UNDO.
DEFINE VARIABLE cDataColumns        AS CHARACTER                NO-UNDO.

DEFINE VARIABLE lLOBMessageDisplayed AS LOGICAL                  NO-UNDO.

/* Start of Security check */
ASSIGN hContainerHandle = TARGET-PROCEDURE.

IF VALID-HANDLE(gshSecurityManager) THEN
DO:
  {get ContainerSource hContainerHandle}.
  IF VALID-HANDLE(hContainerHandle) THEN 
  DO:
    {get LogicalObjectName cContainerName hContainerHandle} NO-ERROR.
    cRunAttribute = DYNAMIC-FUNCTION('getRunAttribute' IN hContainerHandle) NO-ERROR.  
    IF cContainerName = "":U THEN
        ASSIGN cContainerName = hContainerHandle:FILE-NAME.
  END.
  ELSE
    cContainerName = "":U.

  IF cContainerName <> "":U THEN
    ASSIGN cContainerName = REPLACE(cContainerName,"~\":U,"/":U)
           cContainerName = SUBSTRING(cContainerName,R-INDEX(cContainerName,"/":U) + 1,LENGTH(cContainerName)).

  RUN fieldSecurityGet IN gshSecurityManager (INPUT hContainerHandle, /* If not valid cContainerName will be used */
                                              INPUT cContainerName,
                                              INPUT cRunAttribute,
                                              OUTPUT cSecuredFields).
END.

/* Check if security on fields have been set */
IF INDEX(cSecuredFields,"Hidden":U) > 0 THEN
DO iLoop = 1 TO NUM-ENTRIES(cSecuredFields):
  IF ENTRY(iLoop + 1,cSecuredFields) = "Hidden":U THEN
    ASSIGN cHiddenFields = IF cHiddenFields = "":U 
                           THEN ENTRY(iLoop,cSecuredFields)
                           ELSE cHiddenFields + ",":U + ENTRY(iLoop,cSecuredFields).
           iLoop         = iLoop + 1. /* Skip One */
END.

{get DataColumns cDataColumns}.
IF LOOKUP('*':U, pcFieldList) > 0  THEN
  ENTRY(LOOKUP('*':U, pcFieldList),pcFieldList) = cDataColumns.

/* Remove hidden and _obj fields from pcFieldList */
DO iLoop = 1 TO NUM-ENTRIES(pcFieldList):
  cFieldName = ENTRY(iLoop,pcFieldList).
  IF CAN-DO(cDataColumns,cFieldName) THEN
  DO:
    /* We seem to have supported can-do in a previous variation of this
       (different loop logic, due to direct use of buffer ), 
       so use lookup to check if this entry is a wildcard entry.  */
    IF LOOKUP(cFieldName,cDataColumns) = 0 THEN
    DO:
      cCanDoList = ''.
      DO iField = 1 TO NUM-ENTRIES(cDataColumns):
        IF CAN-DO(ENTRY(iField,cDataColumns),cFieldName) 
        AND LOOKUP(ENTRY(iField,cDataColumns),cNewFieldList) = 0 THEN
          cCanDoList = cCanDoList 
                     + (IF cCanDoList = '' THEN '' ELSE ',')
                     + ENTRY(iField,cDataColumns).
      END.
      IF cCanDoList = '' THEN
        NEXT. 
      /* make the first entry the current field and extend the loop list
         with all found entries  */
      ASSIGN
        cFieldName = ENTRY(1,cCanDolist)
        ENTRY(iLoop,pcFieldList) = cCanDoList.
    END. /* lookup = 0  */

    IF LOOKUP(cFieldName,cHiddenFields) > 0 THEN
      NEXT.
  
    IF plIncludeObj = NO AND cFieldName MATCHES "*_obj":U THEN
      NEXT.
  
    cNewFieldList = IF cNewFieldList = "":U
                    THEN cFieldName
                    ELSE cNewFieldList + ",":U + cFieldName.
  END.
END.
pcFieldList = cNewFieldList.


ASSIGN piMaxRecords = (IF piMaxRecords > 0 THEN piMaxRecords ELSE 99999999)
       iNumRecords  = 0.

/* Store current position in query */
cRowident = DYNAMIC-FUNCTION('getRowIdent':U IN TARGET-PROCEDURE) NO-ERROR.

/* We need to do all this to ensure we don't pick up dataAvailable messages, queryPosition subscribes etc. */

PUBLISH 'fetchDataSet':U FROM TARGET-PROCEDURE ('BatchStart':U).

{get NavigationSource hNavSource}.
RUN linkStateHandler IN TARGET-PROCEDURE(INPUT "Inactive":U,
                                         INPUT hNavSource,
                                         INPUT "NavigationSource":U).

/* Get the browser handle that this request came from. If we are performing this request from a browser, *
 * then we must use the browser's column labels, particularly because they may have been translated.     */

{get DataTarget cDataTargets}.

DATA-TARGET-LOOP:
DO iLoop = 1 TO NUM-ENTRIES(cDataTargets):
    ASSIGN hDataTarget = WIDGET-HANDLE(ENTRY(iLoop, cDataTargets)) NO-ERROR.

    IF VALID-HANDLE(hDataTarget) THEN 
    DO:
        IF NOT VALID-HANDLE(hBrowser)
        AND {fn getObjectType hDataTarget} = 'SmartDataBrowser':U THEN
            {get BrowseHandle hBrowser hDataTarget}.

        /* While we're here, disable the data link to improve performance */
        RUN linkStateHandler IN hDataTarget (INPUT "inactive":U,
                                             INPUT TARGET-PROCEDURE,
                                             INPUT "dataSource":U).
    END.
END.

/* Once we have found the browser, build a list of the browse column names and their handles. This is because
 * the only way to retrieve the browser column handle is to use the GET-BROWSE-COLUMN() method, and this uses
 * an ordinal value. We can not depend on the order of the browser columns being the same as the prder of the 
 * fields in the DataObject, so we need to determine the browser column handle from our pre-built lists.    */
IF VALID-HANDLE(hBrowser) THEN 
DO:
    DO iLoop = 1 TO hBrowser:NUM-COLUMNS:
      /* local calc fields cannot be exported*/ 
      hBrowseColumn = hBrowser:GET-BROWSE-COLUMN(iLoop).
      IF hBrowseColumn:TABLE <> ? THEN
        ASSIGN cColumnNames   = cColumnNames 
                              + (IF INDEX(pcFieldList,'.':U) > 0
                                 THEN hBrowseColumn:TABLE + '.'
                                 ELSE '')
                              + hBrowseColumn:NAME + ",":U
               cColumnHandles = cColumnHandles + STRING(hBrowseColumn) + ",":U
               .
    END.    /* loop through browser columns */
    ASSIGN cColumnNames   = RIGHT-TRIM(cColumnNames, ",":U)
           cColumnHandles = RIGHT-TRIM(cColumnHandles, ",":U)
           .
END.    /* valid browser. */

/* Ensure temp-table is empty to start */
EMPTY TEMP-TABLE ttTable.

/* set rows to batch very high as we will read all the data */
&SCOPED-DEFINE xp-assign
{get rowsToBatch iRowsToBatch}
{set rowsToBatch piMaxRecords}
.
&UNDEFINE xp-assign

/* start at the beginning */
RUN fetchFirst IN TARGET-PROCEDURE.

/* check if any records */
lAvailable = {fnarg rowAvailable '':U}.
IF lAvailable THEN
DO:

  ASSIGN iNumRecords = 1 .
  /* loop through sdo fields and create TT records for field labels, names, datatypes and widths */

  field-loop:
  DO iField = 1 TO NUM-ENTRIES(pcFieldList):
    cColumn = ENTRY(iField,pcFieldList).
    
    ASSIGN iColNum       = iColNum + 1
           hBrowseColumn = ?.

    IF VALID-HANDLE(hBrowser) THEN
      ASSIGN hBrowseColumn = WIDGET-HANDLE(ENTRY(LOOKUP(cColumn, cColumnNames), cColumnHandles)) NO-ERROR.
    
    /* Store labels in row 0 */
    CREATE ttTable.
    ASSIGN ttTable.cCell = IF VALID-HANDLE(hBrowseColumn) 
                           THEN TRIM(hBrowseColumn:LABEL)
                           ELSE {fnarg columnColumnLabel cColumn}
           ttTable.iRow  = 0
           ttTable.iCol  = iColNum.

    /* Store field names in row 1 */
    CREATE ttTable.
    ASSIGN ttTable.cCell = cColumn
           ttTable.iRow  = 1
           ttTable.iCol  = iColNum.

    /* Store datatypes in row 2 */
    CREATE ttTable.
    ASSIGN ttTable.cCell = {fnarg columnDataType cColumn}
           ttTable.iRow  = 2
           ttTable.iCol  = iColNum.
    
    /* Store widths in row 3 */
    CREATE ttTable.
    ASSIGN ttTable.cCell = {fnarg columnWidth cColumn}
           ttTable.iRow  = 3
           ttTable.iCol  = iColNum.

    /* Store format in row 4 */
    CREATE ttTable.
    ASSIGN ttTable.cCell = {fnarg columnFormat cColumn}
           ttTable.iRow = 4
           ttTable.iCol  = iColNum.

  END. /* Loop through the requested fields */


  iRowNum = 9.  /* >9 = data */
 
  /* now loop through all available records */
  DO WHILE TRUE:
    
    ASSIGN iRowNum = iRowNum + 1.

    field-loop2:
    DO iField = 1 TO NUM-ENTRIES(pcFieldList):
      cColumn = ENTRY(iField,pcFieldList).
      
      CREATE ttTable.
      ASSIGN ttTable.iRow  = iRowNum
             ttTable.iCol  = iField.

      IF LOOKUP({fnarg columnDataType cColumn},'CLOB,BLOB':U) > 0 THEN
      DO:
         IF NOT lLOBMessageDisplayed THEN
         DO:
            MESSAGE SUBSTITUTE({fnarg MessageNumber 95},PROGRAM-NAME(1),
                                                     cColumn,
                                                     {fnarg columnDataType cColumn})
                    VIEW-AS ALERT-BOX WARNING.
            lLOBMessageDisplayed = YES.
         END.
         ttTable.cCell = "":U.
      END.
      ELSE
         ttTable.cCell = {fnarg columnStringValue cColumn}.
    END. /* Loop through the buffer fields */
    
    iNumRecords    = iNumRecords + 1.

    IF {fnarg rowAvailable 'NEXT':U} AND iNumRecords <= piMaxRecords THEN
      RUN fetchNext IN TARGET-PROCEDURE.
    ELSE
      LEAVE.
  END. /* Loop through all available records */ 
END.  /* lAvailable = true */

/* reposition back to previously selected record */
IF cRowIdent <> ? AND cRowIdent <> "":U THEN
  DYNAMIC-FUNCTION('fetchRowIdent' IN TARGET-PROCEDURE, cRowIdent, '':U) NO-ERROR.

iExtractedRecs = iNumRecords - 1.

/* Enable everything we disabled */
DATA-TARGET-LOOP:
DO iLoop = 1 TO NUM-ENTRIES(cDataTargets):
    ASSIGN hDataTarget = WIDGET-HANDLE(ENTRY(iLoop, cDataTargets)) NO-ERROR.

    IF VALID-HANDLE(hDataTarget) THEN
        RUN linkStateHandler IN hDataTarget (INPUT "active":U,
                                             INPUT TARGET-PROCEDURE,
                                             INPUT "dataSource":U).
END.

RUN linkStateHandler IN TARGET-PROCEDURE(INPUT "active":U,
                                         INPUT hNavSource,
                                         INPUT "NavigationSource":U).

PUBLISH 'fetchDataSet':U FROM TARGET-PROCEDURE ("BatchEnd":U).

RUN updateQueryPosition IN TARGET-PROCEDURE.
/* reset rows to batch back */
{set rowsToBatch iRowsToBatch}.


END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-transferToExcel) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE transferToExcel Procedure 
PROCEDURE transferToExcel :
/*------------------------------------------------------------------------------
  Purpose:     Transfers the contents of the SDO to Excel
  Parameters:  input field list or leave blank for all (no table prefix)
               input include object fields yes/no
               input use existing running excel yes/no
               input maximum records to process
  Notes:       Always excludes rowobject specific fields,
               e.g. RowNum,RowIdent,RowMod
               Uses tableout procedure defined in here also.
------------------------------------------------------------------------------*/
 DEFINE INPUT PARAMETER pcFieldList      AS CHARACTER            NO-UNDO.
 DEFINE INPUT PARAMETER plIncludeObj     AS LOGICAL              NO-UNDO.
 DEFINE INPUT PARAMETER plUseExisting    AS LOGICAL              NO-UNDO.
 DEFINE INPUT PARAMETER piMaxRecords     AS INTEGER              NO-UNDO.
 
 RUN exportData IN TARGET-PROCEDURE ('Excel':U,
                                     pcFieldList,
                                     plIncludeObj,
                                     plUseExisting,
                                     piMaxRecords).

 RETURN.

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-undoTransaction) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE undoTransaction Procedure 
PROCEDURE undoTransaction :
/*------------------------------------------------------------------------------
  Purpose:     To undo any uncommitted changes to the RowObject table when the
               "Undo" button is pressed in the commit panel.

  Parameters:  <none>

  Notes:       undoTransaction calls doUndoTrans to restore the RowObject 
               Temp-Table and empty the RowObjUpd Temp-Table.
------------------------------------------------------------------------------*/
  DEFINE VARIABLE rRowObject     AS ROWID   NO-UNDO.
  DEFINE VARIABLE hDataQuery     AS HANDLE  NO-UNDO.
  DEFINE VARIABLE hRowObject     AS HANDLE  NO-UNDO.
  DEFINE VARIABLE hCommitSource  AS HANDLE  NO-UNDO. 
  DEFINE VARIABLE hDatasetSource AS HANDLE  NO-UNDO.
  DEFINE VARIABLE lCancel        AS LOGICAL NO-UNDO.
  DEFINE VARIABLE cDataTable     AS CHARACTER  NO-UNDO.
  
  &SCOPED-DEFINE xp-assign
  {get CommitSource hCommitSource}
  {get DatasetSource hDatasetSource}
  {get DataTable cDataTable}.
  &UNDEFINE xp-assign
  
  IF VALID-HANDLE(hDatasetSource) THEN
  DO:
    /* If record changes haven't been saved, confirm that it is ok to Cancel 
       these also. 
       Make this check if it came from the Commit Panel, but skip if it 
       came locally or from an SBO. */
    IF SOURCE-PROCEDURE = hCommitSource THEN
    DO:
       /* Visual dataTargets subscribes to this */
      PUBLISH 'confirmUndo':U FROM TARGET-PROCEDURE (INPUT-OUTPUT lCancel).
      IF lCancel THEN RETURN 'ADM-ERROR':U.
    END.    /* END IF hSource  */
    
    {get DataHandle hDataQuery}.
    hRowObject = hDataQuery:GET-BUFFER-HANDLE(1).

    /* The rowid of new records may get reused if there are deleted records */
    IF hRowobject:ROW-STATE <> ROW-CREATED  THEN
      rRowObject = hRowObject:ROWID.
    
    RUN undoTransaction IN hDatasetSource (cDataTable).

    /* Now reopen the RowObject query, in order to refresh any dependent 
       SmartDataBrowser, reposition to the previously current row, and do
       dataAvailable to refresh that row in SmartDataViewers and other objects. */
    {fnarg openDataQuery STRING(rRowObject)}.
    /* The record we had may have been new and uncommitted.. and thus been 
       deleted as part of the undo, behave as normal delete and find next 
       or last if no recs after  */
    IF NOT hRowObject:AVAILABLE THEN
      hDataQuery:GET-NEXT().   /* next if needed (for Viewer, not Browser target)*/
    
    IF NOT hRowObject:AVAILABLE THEN
      hDataQuery:GET-LAST().   /* next if needed (for Viewer, not Browser target)*/

    {set RowObjectState 'NoUpdates':U}.
    RUN rowChanged IN TARGET-PROCEDURE ("RESET":U).
  END.

  RETURN.
END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-updateQueryPosition) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE updateQueryPosition Procedure 
PROCEDURE updateQueryPosition :
/*------------------------------------------------------------------------------
  Purpose: Reset the QueryPosition property after a record navigation.  
    Notes: The assumption is that LastRowNum and FirstRowNum stores the 
           id of the first and last record in the database query when this is 
           called. 
         - Some of the logic here is duplicated in data's override.  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hRowObject   AS HANDLE     NO-UNDO.
  DEFINE VARIABLE iLastRow     AS INT        NO-UNDO.
  DEFINE VARIABLE iFirstRow    AS INT        NO-UNDO.  
  DEFINE VARIABLE lLast        AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cQueryPos    AS CHAR       NO-UNDO.
  DEFINE VARIABLE lNew         AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE hDataSource  AS HANDLE     NO-UNDO.
  DEFINE VARIABLE lQuery       AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE iROwNum      AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cParentPos   AS CHARACTER  NO-UNDO.

  {get RowObject hRowObject}.
  IF VALID-HANDLE(hRowObject) AND hRowObject:AVAILABLE THEN
  DO:
    &SCOPED-DEFINE xp-assign
    {get FirstRowNum iFirstRow}
    {get LastRowNum iLastRow}.
    &UNDEFINE xp-assign
     
    ASSIGN
      iRowNum   = INT(hRowObject:RECID)
      /* Are we on the last record?  */
      lLast     = (iRowNum = iLastRow)
      cQueryPos = IF iRowNum = iFirstRow                   
                  THEN (IF NOT lLast 
                        THEN 'FirstRecord':U 
                        ELSE 'OnlyRecord':U) /* first AND last is ONLY */
                  ELSE (IF NOT lLast 
                        THEN 'NotFirstOrLast':U /* not first and not last */ 
                        ELSE 'LastRecord':U)
      .   

  END. /* If hRowObject:available */
  ELSE DO:

    /* Check for a DataSource. If there is a data source then we check
       the parent's queryPosition. */
    {get DataSource hDataSource}.     
    IF VALID-HANDLE(hDataSource) THEN 
    DO:
      {get QueryObject lQuery hDataSource}.
      IF lQuery THEN
      DO:
        {get QueryPosition cParentPos hDataSource}.
        IF cParentPos BEGINS 'NoRecordAvailable':U THEN
          cQueryPos = 'NoRecordAvailableExt':U.

        IF cQueryPos = '':U THEN
        DO:
          /* Check if dataSource has an unsaved new record */
          {get NewMode lNew hDataSource}.
          IF lNew THEN
            cQueryPos = 'NoRecordAvailableExt':U.
        END. /* cQueryPos = '' */
      END. /* query */
      ELSE /* if datasource not query object ( possibly pass-thru) then
               assume nothing is available (yet) */ 
         cQueryPos = 'NoRecordAvailableExt':U.
    END.  /* valid DataSource */     
    /* If not set above set the cQueryPos variable to NoRecordAvailable */ 
    IF cQueryPos = '':U THEN
      cQueryPos = 'NoRecordAvailable':U.
  END.  /* else (not avail)*/
  
  {set QueryPosition cQueryPos}.
  
  RETURN.

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-updateState) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE updateState Procedure 
PROCEDURE updateState :
/*------------------------------------------------------------------------------
  Purpose:     To pass along update-related messages (to its 
               Navigation-Source, e.g) and to adjust the DataModified property.
               
  Parameters:  
    INPUT pcState - A indicator of the state of a an updatable record. Valid
                    values are:
                      'UpdateBegin'    -  The user has indicated that an update
                                          will take place (either by pressing
                                          the Update button in a panel, or by
                                          entering an updatable field in a
                                          browser.)
                      'Update'         -  An update is in progress in another
                                          object (a viewer or browser.)
                      'UpdateEnd'      -  A save has completed (same as
                                          'UpdateComplete'.)
                      'UpdateComplete' -  Any changes to the RowObject
                                          Temp-Table have either been 
                                          committed or backed out.
                      'Reset'          -  Changes to the roewObject has been
                                          reset, passed on as 'UpdateComplete'  
                      'Delete'         -  An uncommitted delete, which we 
                                          pass on as 'update'.  
                      'Updatable'      - called from UpdateMode when switching modes                      
                        
   Notes:   -  The SmartDataObject also saves its own "copy" of the 
               DataModified property, set true when updateState is 'Update' 
               and false when updateState is 'UpdateComplete', so that it 
               can be queried by other objects (such as other dataTargets).  
            -  For visual objects the updateState is both a DataSourceEvent 
               and DataTargetEvent. In order to not bounce messages back to the 
               dataTargets that are both subscribers and publishers, we 
               set the CurrentUpdateSource so the DataTarget can avoid 
               republishing the event.                
               Note that even if we did send the message back to the visual
               object it would not get back to us as visual object only does 
               publish updatestate from internal events, including GAtargets    
------------------------------------------------------------------------------*/
  DEFINE INPUT PARAMETER pcState AS CHARACTER NO-UNDO.
   
  DEFINE VARIABLE hDataSource       AS HANDLE    NO-UNDO.
  DEFINE VARIABLE lModified         AS LOGICAL   NO-UNDO INIT ?.
  DEFINE VARIABLE lAsynchronous     AS LOGICAL   NO-UNDO.
  DEFINE VARIABLE lAutoCommit       AS LOGICAL   NO-UNDO.
  DEFINE VARIABLE hContainerSource  AS HANDLE    NO-UNDO.
  DEFINE VARIABLE cUpdateSource     AS CHARACTER NO-UNDO.
  DEFINE VARIABLE cTargetSrcEvents  AS CHARACTER NO-UNDO.
 
  /* Ensure that the browse is updated. This needs to be done even if Asynch. 
     Refresh will make the current record in the browse available, so although 
     it is possible to do this very late in submitRow  (after submitCommit 
     publish of data available) we really don't want to change position during 
     the update, so we wait until the update-source does setDataModified(false), 
     which will publish this. */ 
  IF pcState = 'UpdateComplete':U THEN
    PUBLISH 'refreshBrowse':U FROM TARGET-PROCEDURE.
  
  /* If a row is deleted when autoCommit is off it publishes 'delete' in order     
     NOT to disable its nav-source or browse data-target, but still get the 
     message to its data-source, (which in this case will be us). 
     Note: Navsources does not really need this anymore as they use 
           canNavigate  to check the validity of the message, but browsers still 
           disables on 'update' and does nothing on 'delete' and only use
           canNavigate to validate 'updateComplete'.
          (they could be changed to use canNavigate for all states)           
     The data source republishes this as 'update', so that all nav-source and 
     data-target browsers ABOVE the uncommitted delete is disabled. */          
  IF pcState = 'Delete':U THEN
    pcState = 'Update':U.

  /* Reset is passed as a workaround from visual objects to avoid that a 
     tableio with updatemode publishes updatemode('updateend'). */ 
  IF pcState = 'Reset':U THEN
    pcState = 'UpdateComplete':U.
  
  /* The setting of DataModified can probably be removed ....
     The sdo sets it to no in submitCommit and getDataModified always checks
     updateSources, canNavigate is used to check all children, so we don't need 
     to set this based on children (which would be wrong anyways with many 
     children in tree branches ) */  
  IF pcState = 'Update':U THEN
    lModified = yes.

  ELSE IF pcState = 'UpdateComplete':U THEN
    lModified = no.
    
  /* Ensure that Modified State is only set when valid state is sent. */
  IF lModified <> ? THEN
    {set DataModified lModified}.
  
  /* If the SOURCE is DataTarget that also subscribes, set currentUpdateSource
     so the source can avoid republish the event  */ 
  {get UpdateSource cUpdateSource}.
  IF CAN-DO(cUpdateSource,STRING(SOURCE-PROCEDURE)) THEN
     {set CurrentUpdateSource SOURCE-PROCEDURE}.
  PUBLISH 'updateState':U FROM TARGET-PROCEDURE (pcState).
  {set CurrentUpdateSource ?}.
  
  RETURN.
END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

/* ************************  Function Implementations ***************** */

&IF DEFINED(EXCLUDE-activateHiddenFetchChildren) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION activateHiddenFetchChildren Procedure 
FUNCTION activateHiddenFetchChildren RETURNS CHARACTER PRIVATE
  (   ) :
/*------------------------------------------------------------------------------
  Purpose: Return all dependant childrent that are deactivated, but 
           that we are responsible to retrieve data for.     
    Notes:  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hTarget        AS HANDLE     NO-UNDO.
  DEFINE VARIABLE iTarget        AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cTarget        AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cDataTargets   AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cChildren      AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cGrandChildren AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE lQuery         AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lIsFetched     AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lOpenOnInit    AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cInactiveLinks AS CHARACTER  NO-UNDO.

  {get DataTarget cDataTargets}.

  DO iTarget = 1 TO NUM-ENTRIES(cDataTargets):
    ASSIGN 
      cTarget = ENTRY(iTarget,cDataTargets)
      hTarget = WIDGET-HANDLE(cTarget).

    IF VALID-HANDLE(hTarget) THEN
    DO:
      {get QueryObject lQuery hTarget}.
      IF lQuery THEN
      DO:
        &SCOPED-DEFINE xp-assign
        {get DataIsFetched lIsFetched hTarget}
        {get InactiveLinks cInactiveLinks hTarget}
        {get OpenOnInit lOpenOnInit hTarget}.
        &UNDEFINE xp-assign
        
        IF lOpenOnInit THEN
        DO:
          cGrandChildren = {fn activateHiddenFetchChildren hTarget}.
          
          IF LOOKUP(STRING(TARGET-PROCEDURE),cInactiveLinks) > 0
          AND (lIsFetched <> FALSE OR cGrandChildren > '') THEN
          DO:
            cChildren = cChildren 
                      + (IF cChildren = '' THEN '' ELSE ',')
                      + STRING(hTarget).
            RUN linkStateHandler IN hTarget
                        ('ACTIVE':U,TARGET-PROCEDURE,'DataSource':U).
          END.
  
          IF cGrandChildren > '' THEN
            cChildren = cChildren 
                      + (IF cChildren = '' THEN '' ELSE ',')
                      + cGrandChildren.

        END. /* openoninit */
      END. /* queryobject */
    END. /* valid htarget*/ 
  END. /* cDataTargets */

  RETURN cChildren.   

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-addDatasetClone) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION addDatasetClone Procedure 
FUNCTION addDatasetClone RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:  
    Notes:  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hDatasetSource AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hDataContainer AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cNewName       AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hBuffer        AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cDataTable     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cTables        AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hDataHandle    AS HANDLE     NO-UNDO.
  DEFINE VARIABLE iTable         AS INTEGER    NO-UNDO.
  DEFINE VARIABLE hChild         AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cChild         AS CHARACTER  NO-UNDO.


  {get DatasetSource hDatasetSource}.
  {get DataTable cDataTable}.

  IF VALID-HANDLE(hDatasetSource) THEN
  DO:
    {get DataContainerHandle hDataContainer}.
    cNewName = {fnarg cloneDataset hDatasetSource hDataContainer}.
    IF cNewName > '' THEN
    DO:
      {set DatasetName cNewName}.
      {fn addDatasetSource}.
      {get DatasetSource hDatasetSource}.
      IF VALID-HANDLE(hDatasetSource) THEN
      DO:
        hBuffer  = {fnarg dataTableHandle cDataTable hDatasetSource}.
        {set RowObject hBuffer}.
      END.
    END.
  END.

  IF VALID-HANDLE(hBuffer)  THEN
  DO:
    {get QueryTables cTables}.
    {get DataHandle hDataHandle}.
    hDataHandle:SET-BUFFERS(hBuffer).
    DO iTable = 2 TO NUM-ENTRIES(cTables):
      ASSIGN
        cChild = ENTRY(iTable,cTables)
        hChild = {fnarg dataTableHandle cChild hDatasetSource}
        .
      IF VALID-HANDLE(hChild) THEN
      DO:
        hDataHandle:ADD-BUFFER(hChild).
      END. 
    END.
    RETURN TRUE.
  END.

  RETURN FALSE. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-addDatasetSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION addDatasetSource Procedure 
FUNCTION addDatasetSource RETURNS LOGICAL
  (   ) :
/*------------------------------------------------------------------------------
 Purpose:    Attaches the dataset procedure to the dataview 
 Parameters:  <none>
 Notes:      This will be typically be called after the first data request at
             runtime, so the dataset will already be present in the 
             datacontainer .
           - At design time the datacontainer will call the service to
             retrieve the dataset.     
------------------------------------------------------------------------------*/
 DEFINE VARIABLE hDataContainer  AS HANDLE     NO-UNDO.
 DEFINE VARIABLE hRequestor      AS HANDLE     NO-UNDO.
 DEFINE VARIABLE cBusinessEntity AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE cDataTable      AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE cDataSetName    AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE hDatasetSource  AS HANDLE     NO-UNDO.
 DEFINE VARIABLE cRequestTable   AS CHARACTER  NO-UNDO.

 &SCOPED-DEFINE xp-assign
 {get BusinessEntity cBusinessEntity}
 {get DatasetName cDataSetName}
 {get RequestHandle hRequestor}
 {get DataContainerHandle hDataContainer}
 .
 &UNDEFINE xp-assign
 
 IF cDatasetName = '' THEN 
   cDatasetName = cBusinessEntity. 
   
 /* We allow no table for definitions (at design time) */
 IF cBusinessEntity > '' THEN 
 DO:
   RUN retrieveDataset IN hDataContainer
                         (hRequestor,
                          cBusinessEntity,
                          cDataSetName,
                          OUTPUT hDatasetSource) NO-ERROR.
   
   IF ERROR-STATUS:ERROR OR NOT VALID-HANDLE(hDatasetSource) THEN
   DO:
     MESSAGE 'Retrieval of definitions for Business Entity "'
             + cBusinessEntity + '"' 'failed'
             +  if return-value = '' THEN '.' ELSE ':' 
             SKIP(1)  RETURN-VALUE
             VIEW-AS ALERT-BOX ERROR.
     RETURN FALSE.
   END. 
   {set DatasetSource hDatasetSource}.
 END.

 RETURN VALID-HANDLE(hDatasetSource).

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-addForeignKey) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION addForeignKey Procedure 
FUNCTION addForeignKey RETURNS LOGICAL
  ( ) :
/*------------------------------------------------------------------------------
  Purpose: Assign the ForeignKey to the query string. 
    Notes: The ForeignKey consists of ForeignKeys and ForeignValues. 
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cLocalFields   AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cSourceFields  AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hDataSource    AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cForeignFields AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cForeignValues AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE iField         AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cField         AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cValue         AS CHARACTER  NO-UNDO.

  &SCOPED-DEFINE xp-assign
  {get DataSource hDataSource}
  {get ForeignFields cForeignFields}
  .
  &UNDEFINE xp-assign
  
  IF NOT VALID-HANDLE(hDataSource) OR cForeignFields = '':U OR cForeignFields = ? THEN
    RETURN FALSE.
  
  DO iField = 1 TO NUM-ENTRIES(cForeignFields) BY 2:
    ASSIGN
                      /* 2nd of each pair is parent fld  */
      cField         = ENTRY(iField + 1, cForeignFields)
      cForeignValues = cForeignValues 
                     + (IF iField = 1 THEN "":U ELSE ",":U)
                       /* unknown is dealt with below */
                     + {fnarg columnValue cField hDataSource}
      cLocalFields   = cLocalFields 
                      /* 1st of each pair is local fld  */
                     + (IF iField = 1 THEN "":U ELSE ",":U)
                     + ENTRY(iField, cForeignFields)
      .
  END.

  /* set all values to unknown if not avail parent if more than one field... 
    (should rather close the query or something..)  */
  IF cForeignValues = ? AND NUM-ENTRIES(cForeignFields) > 2 THEN
    cForeignValues = RIGHT-TRIM(FILL('?':U + CHR(1),INT(NUM-ENTRIES(cForeignFields) / 2)),',').
  
  {set ForeignValues cForeignValues}. 

  RETURN DYNAMIC-FUNCTION("assignQuerySelection":U IN TARGET-PROCEDURE, 
                           cLocalFields,
                           cForeignValues,
                           '':U).  

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-addRow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION addRow Procedure 
FUNCTION addRow RETURNS CHARACTER
  ( pcViewColList AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:     Creates a new RowObject temp-table record, initializes it, and
               returns CHR(1) delimited list of values for the requested 
               columns (in pcViewColList) of the new RowObject row.
               The first entry in the list is the RowObect ROWID and db RowIds
               separated with commas. (The db Rowids are blank as the record 
               has not been created)    
  Parameters:
    INPUT pcViewColList - comma-separated list of columns names that are to
                          be displayed in the SmartDataViewer that called
                          addRow.
------------------------------------------------------------------------------*/
  DEFINE VARIABLE iCol           AS INTEGER    NO-UNDO.
  DEFINE VARIABLE hColumn        AS HANDLE     NO-UNDO.
  DEFINE VARIABLE iColCount      AS INTEGER    NO-UNDO.
  DEFINE VARIABLE hRowObject     AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cColList       AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cRowid         AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hDataQuery     AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cForFields     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cForValues     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cField         AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hDatasetSource AS HANDLE     NO-UNDO.
  DEFINE VARIABLE rRowid         AS ROWID      NO-UNDO.
  DEFINE VARIABLE cDataTable     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hDataHandle    AS HANDLE     NO-UNDO.
  DEFINE VARIABLE iBuf           AS INTEGER    NO-UNDO.
  &SCOPED-DEFINE xp-assign
  {get RowObject hRowObject}
  {get ForeignFields cForFields}
  {get DataColumns cColList}
  {get DatasetSource hDatasetSource}
  {get DataTable cDataTable}
  {get DataHandle hDataHandle}
  .
  &UNDEFINE xp-assign
  
  IF NOT VALID-HANDLE(hRowObject) OR NOT VALID-HANDLE(hDatasetSource) THEN
    RETURN ?.

  /* Save off the "current" rowid in case the add is cancelled. 
     If there's no RowObject record available, it's because we're
     being browsed from outside, so use the Browser's RowIdent. */
  IF hRowObject:AVAILABLE THEN
    {set CurrentRowid hRowObject:ROWID}. 
  ELSE /* currently used as getNewRow flag so set to blank if no 
          record avail  */
    {set CurrentRowid TO-ROWID('0x':U)}.

  rRowid = {fnarg createRow cDataTable hDatasetSource}.

  IF rRowid <> ? THEN
  DO:
    hRowObject:FIND-BY-ROWID(rRowid).
    DO ibuf = 2 TO hDataHandle:NUM-BUFFERS:
      hDataHandle:GET-BUFFER-HANDLE(iBuf):BUFFER-RELEASE.
    END.

    /* scope to control row-updated firing  (may change) */
    IF cForFields NE "":U THEN
    DO TRANSACTION:
      {get ForeignValues cForValues}.
      /* Each ForField pair is db name, RowObject name */
      DO iCol = 1 TO NUM-ENTRIES(cForFields) BY 2:
        cField = ENTRY(iCol, cForFields).
        hColumn = hRowObject:BUFFER-FIELD(ENTRY(NUM-ENTRIES(cField, ".":U), cField, ".":U)).
        IF VALID-HANDLE(hColumn) THEN  
          hColumn:BUFFER-VALUE = ENTRY(INT((iCol + 1) / 2), cForValues, CHR(1)).
      END.  /* END DO iCol */
    END.    /* END DO IF cForFields NE "" */

    PUBLISH "dataAvailable":U FROM TARGET-PROCEDURE ('DIFFERENT':U).    
 
    RETURN {fnarg colValues pcViewColList}.
  END. /* rRowid */

  RETURN ?.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-applyContextFromServer) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION applyContextFromServer Procedure 
FUNCTION applyContextFromServer RETURNS LOGICAL
  ( pcContext AS CHAR) :
/*------------------------------------------------------------------------------
  Purpose: Apply context returned from server after a server call
Parameter: CHR(4) separated paired list with attributename and value.
    Notes: Receives values returned from the service adapter's optional context
------------------------------------------------------------------------------*/
 DEFINE VARIABLE cValue             AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE cProperty          AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE iLoop              AS INTEGER    NO-UNDO.

 DO iLoop = 1 TO NUM-ENTRIES(pcContext,CHR(4)) BY 2:
   ASSIGN
     cProperty = ENTRY(iLoop,pcContext,CHR(4))
     cValue    = ENTRY(iLoop + 1,pcContext,CHR(4))
     cValue    = IF cValue = '?' THEN ? ELSE cValue.
   DYNAMIC-FUNCTION("set":U + cProperty IN TARGET-PROCEDURE, cValue) NO-ERROR.  
 END.

 RETURN TRUE.    

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-assignColumnColumnLabel) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION assignColumnColumnLabel Procedure 
FUNCTION assignColumnColumnLabel RETURNS LOGICAL
  ( pcColumn      AS CHARACTER,
    pcColumnLabel AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:     Assign the columnlabel of the specified column.  
              
   Parameters: INPUT pcColumn 
                    - DataTable qualified column name.
                    - Unqualified column name of the DataTable.                    
                    - Column name qualified with "RowObject" is valid reference 
                      to the DataTable.   
              INPUT pcColumnLabel  - The new Column Label               
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hCol       AS HANDLE NO-UNDO.

  hCol = {fnarg columnHandle pcColumn}. 

  IF hCol NE ? THEN 
    hCol:COLUMN-LABEL = pcColumnLabel.  

  RETURN IF hCol = ? THEN FALSE ELSE TRUE.  

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-assignColumnFormat) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION assignColumnFormat Procedure 
FUNCTION assignColumnFormat RETURNS LOGICAL
  ( pcColumn AS CHARACTER,
    pcFormat AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:     Assign the FORMAT of the specified column.  
              
   Parameters: INPUT pcColumn 
                    - DataTable qualified column name.
                    - Unqualified column name of the DataTable.                    
                    - Column name qualified with "RowObject" is valid reference 
                      to the DataTable.   
              INPUT pcformat - new format         
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hCol       AS HANDLE NO-UNDO.

  hCol = {fnarg columnHandle pcColumn}. 

  IF hCol NE ? THEN 
    hCol:FORMAT = pcFormat.
  
  RETURN IF hCol = ? THEN FALSE ELSE TRUE.  

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-assignColumnHelp) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION assignColumnHelp Procedure 
FUNCTION assignColumnHelp RETURNS LOGICAL
  ( pcColumn AS CHARACTER,
    pcHelp   AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:     Assign the help string of the specified column.  
              
   Parameters: INPUT pcColumn 
                    - DataTable qualified column name.
                    - Unqualified column name of the DataTable.                    
                    - Column name qualified with "RowObject" is valid reference 
                      to the DataTable.   
               INPUT pcHelp - new help string         
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hCol       AS HANDLE NO-UNDO.

  hCol = {fnarg columnHandle pcColumn}. 
  
  IF hCol NE ? THEN 
    hCol:HELP = pcHelp.

  RETURN IF hCol = ? THEN FALSE ELSE TRUE.  

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-assignColumnLabel) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION assignColumnLabel Procedure 
FUNCTION assignColumnLabel RETURNS LOGICAL
  ( pcColumn AS CHARACTER,
    pcLabel  AS CHARACTER) :
/*------------------------------------------------------------------------------
      Purpose:  Assign the label of the specified column.  
              
   Parameters: INPUT pcColumn 
                    - DataTable qualified column name.
                    - Unqualified column name of the DataTable.                    
                    - Column name qualified with "RowObject" is valid reference 
                      to the DataTable.   
               INPUT pcLabel - New label       
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hCol       AS HANDLE NO-UNDO.

  hCol = {fnarg columnHandle pcColumn}. 
  
  IF hCol NE ? THEN 
    hCol:LABEL = pcLabel.

  RETURN IF hCol = ? THEN FALSE ELSE TRUE.  

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-assignColumnPrivateData) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION assignColumnPrivateData Procedure 
FUNCTION assignColumnPrivateData RETURNS LOGICAL
  ( pcColumn      AS CHARACTER, 
    pcPrivateData AS CHARACTER ) :
/*------------------------------------------------------------------------------
      Purpose:  Assign the label of the specified column.  
              
   Parameters: INPUT pcColumn 
                    - DataTable qualified column name.
                    - Unqualified column name of the DataTable.                    
                    - Column name qualified with "RowObject" is valid reference 
                      to the DataTable.   
               INPUT pcPrivateData - New private data       
------------------------------------------------------------------------------*/
 DEFINE VARIABLE hCol       AS HANDLE NO-UNDO.

 hCol = {fnarg columnHandle pcColumn}. 
  
 IF hCol NE ? THEN 
   hCol:PRIVATE-DATA = pcPrivateData.

 RETURN IF hCol = ? THEN FALSE ELSE TRUE.  

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-assignQuerySelection) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION assignQuerySelection Procedure 
FUNCTION assignQuerySelection RETURNS LOGICAL
  (pcColumns   AS CHARACTER,   
   pcValues    AS CHARACTER,    
   pcOperators AS CHARACTER):
/*------------------------------------------------------------------------------   
   Purpose: Assigns selection criteria to the query and distributes the 
            column/value pairs to the corresponding buffer's where-clause. 
            Each buffer's expression will always be embedded in parenthesis.
   Parameters: 
     pcColumns   - Column names (Comma separated) 
                   
                   Fieldname of a table in the query in the form of 
                   TBL.FLDNM or DB.TBL.FLDNM (only if qualified with db is specified),
                   (RowObject.FLDNM should be used for SDO's)  
                   If the fieldname isn't qualified it checks the tables in 
                   the TABLES property and assumes the first with a match.
                   
     pcValues    - corresponding Values (CHR(1) separated)
     pcOperators - Operator - one for all columns
                              - blank - defaults to (EQ)  
                              - Use slash to define alternative string operator
                                EQ/BEGINS etc..
                            - comma separated for each column/value       
   Notes:  Can be called before initialization, but the alternative string 
           operator is not supported before the object is initialized. 
           (datatype is not known)   
         -  This procedure is designed to be called several times to build up
            the the query's where clause 
            (storing intermediate results in the QueryString property) before 
            it is finally used in a Query-Prepare method. 
         -  openDataQuery takes care of the preparation of the QueryString 
            property.
         -  The QueryColumns property is used to ensure that each column and 
            operator only will be added once to the QueryString. The property is 
            also used to store the offset and length of the corresponding values.
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cQueryString   AS CHARACTER NO-UNDO.
    
  DEFINE VARIABLE cBufferList    AS CHAR      NO-UNDO.
  DEFINE VARIABLE cBuffer        AS CHARACTER NO-UNDO.
  
  /* We need the columns name and the parts */  
  DEFINE VARIABLE cColumn        AS CHARACTER NO-UNDO.
  DEFINE VARIABLE cColumnName    AS CHARACTER NO-UNDO.
    
  DEFINE VARIABLE iBuffer        AS INTEGER   NO-UNDO.
  DEFINE VARIABLE iColumn        AS INTEGER   NO-UNDO.
  
  DEFINE VARIABLE cUsedNums      AS CHAR      NO-UNDO.
  
  /* Used to builds the column/value string expression */
  DEFINE VARIABLE cBufWhere      AS CHARACTER NO-UNDO.
  DEFINE VARIABLE cValue         AS CHAR      NO-UNDO.  
  DEFINE VARIABLE cOperator      AS CHARACTER NO-UNDO.
  DEFINE VARIABLE cAndOr         AS CHAR      NO-UNDO.
       
  /* Used to store and maintain offset and length */    
  DEFINE VARIABLE iValLength     AS INTEGER   NO-UNDO.
  DEFINE VARIABLE iValPos        AS INTEGER   NO-UNDO.
  DEFINE VARIABLE iExpPos        AS INTEGER   NO-UNDO.
  DEFINE VARIABLE iPos           AS INTEGER   NO-UNDO.
  DEFINE VARIABLE iDiff          AS INTEGER   NO-UNDO.
  DEFINE VARIABLE cQueryColumns  AS CHAR      NO-UNDO.
  DEFINE VARIABLE cQueryBufCols  AS CHAR      NO-UNDO.
  DEFINE VARIABLE cQueryColOp    AS CHAR      NO-UNDO.
  DEFINE VARIABLE cChangedValues AS CHARACTER NO-UNDO.
  DEFINE VARIABLE cChangedList   AS CHARACTER NO-UNDO.
  DEFINE VARIABLE iOldEntries    AS INTEGER   NO-UNDO.
  DEFINE VARIABLE iLowestChanged AS INTEGER   NO-UNDO.
  DEFINE VARIABLE iBufPos        AS INTEGER   NO-UNDO.
  DEFINE VARIABLE iColPos        AS INTEGER   NO-UNDO.
  DEFINE VARIABLE iWhereBufPos   AS INTEGER   NO-UNDO.
          
  &SCOPED-DEFINE xp-assign
  {get QueryTables cBufferList}    
  {get QueryString cQueryString}.      
  &UNDEFINE xp-assign
  
  /* If no QueryString use the default */ 
  IF cQueryString = "":U OR cQueryString = ? THEN
  DO:

    {get QueryStringDefault cQueryString}.    
  END.

  {get QueryColumns cQueryColumns}.
  /* cQueryColumns has the form of:
        BufName1:columns_of_buf1:BufName2:columns_of_buf2...
      
        Each columns_of_buf has the form of:
        ColumnName.Operator,ValuePosition,ValueLength
        
        The Operator is one of: ">=", "<=","<", ">", "=", "BEGINS", etc.
        The ValuePosition refers to the character position of the value
        in an expression: ColumnName Opr Value
        (The quote is considered part of the value)
        The length of the value is the number of characters in the string
        that represents the value (including quotes) */

  ASSIGN
    /* We only support AND in this function */
    cAndOr       = "AND":U. 
    /* remove bad white space */   
    cQueryString = REPLACE(cQueryString,CHR(10),' ':U).
 
  DO iBuffer = 1 TO NUM-ENTRIES(cBufferList):  
    ASSIGN
      cBufWhere      = "":U
      cBuffer        = ENTRY(iBuffer,cBufferList)
      iBufPos        = LOOKUP(cBuffer,cQueryColumns,":":U)
      cQueryBufCols  = IF iBufPos > 0 
                       THEN ENTRY(iBufPos + 1,cQueryColumns,":":U) 
                       ELSE "":U
      iOldEntries    = NUM-ENTRIES(cQueryBufCols) / 3    
      cChangedValues = FILL(CHR(1),iOldEntries - 1)
      cChangedList   = "":U
      iLowestChanged = 0.
      
    ColumnLoop:    
    DO iColumn = 1 TO NUM-ENTRIES(pcColumns):
             
      IF CAN-DO(cUsedNums,STRING(iColumn)) THEN 
        NEXT ColumnLoop.      
        
      RUN obtainExpressionEntries IN TARGET-PROCEDURE
                         (cBuffer,
                          iColumn,
                          pcColumns,
                          pcValues,
                          pcOperators,
                          OUTPUT cColumn, 
                          OUTPUT cOperator,
                          OUTPUT cValue).
     
      IF cColumn = '':U THEN
        NEXT.

      ASSIGN
        cUsedNums  = cUsedNums
                   + (IF cUsedNums = "":U THEN "":U ELSE ",":U)
                   + STRING(iColumn) 
        /* The Column and operator are unique entries so we must mak sure that  
           that blank or different styles doesn't get misinterpreted  */
        cQueryColOp = cOperator
        cQueryColOp = TRIM(     IF cQueryColOp = "GE":U THEN ">=":U
                           ELSE IF cQueryColOp = "LE":U THEN "<=":U
                           ELSE IF cQueryColOp = "LT":U THEN "<":U
                           ELSE IF cQueryColOp = "GT":U THEN ">":U
                           ELSE IF cQueryColOp = "EQ":U THEN "=":U
                           ELSE    cQueryColOp)
        cColumnName = ENTRY(NUM-ENTRIES(cColumn,'.':U),cColumn,'.':U)  

        /* Have the column and operator been added to the querystring
           (by this function) */  
        iPos        = LOOKUP(cColumnName + ".":U + cQueryColOp,cQueryBufCols).
          
      /* If the column + operator was found in the list
         we build a list of the new values to use when we insert the data
         into the QueryString further down.
         We also build a list of the changed numbers, to check if any change 
         has occured. (The list of new values cannot be checked because any 
         data may be new data and we don't know the old value) */         
      IF iPos > 0 THEN
        ASSIGN
          ENTRY(INT((iPos - 1) / 3 + 1),cChangedValues,CHR(1)) = cValue    
          iLowestChanged = MIN(iPos,IF iLowestChanged = 0 
                                    THEN iPos 
                                    ELSE iLowestChanged)
          cChangedList  = cChangedList 
                        + (IF cChangedList = "":U THEN "":U ELSE ",":U)
                        + STRING(INT((iPos - 1) / 3 + 1)).     
      ELSE DO: /* This is a new column + operator so we build the new 
                  expression and add the column and offset info to the list 
                  that will be stored as a part of QueryColumns */   
        ASSIGN          
          cBufWhere  = cBufWhere 
                     + (If cBufWhere = "":U 
                        THEN "":U 
                        ELSE " ":U + cAndOr + " ":U)
                     + cColumn 
                     + " ":U
                     + cOperator
                     + " ":U
                     + cValue
                                             
         /* Calculate the temporary offset of this columns value. 
            We (Who are we?) will justify it after the expression has been 
            added to the whereclause, because even if we know the buffer's 
            position, the expression may or may not need and/where */
         iValPos   = LENGTH(cBufWhere) - LENGTH(cValue)         
                    
           /* Store the ColumName and operator with period as delimiter and 
              add the position and length as separate entries*/
         cQueryBufCols = cQueryBufCols 
                       + (IF cQueryBufCols <> "":U THEN ",":U ELSE "":U)
                       + cColumnName 
                       + ".":U 
                       + cQueryColOp 
                       + ",":U
                       + STRING(iValPos)  
                       + ",":U
                       + STRING(LENGTH(cValue))
           
           /* Ensure that the list used to log changes have correct number of
              entries (Probably only necessary if the SAME column and operator
                       appears a second time in the same call, which is unlikely)
                       */                
         cChangedValues = cChangedValues + CHR(1).                
      END. /* else do =(ipos = 0) */
    END. /* do iColumn = 1 to num-entries(pColumns) */  
    
    /* Get the buffers position in the where clause (always the
       first entry in a dynamic query because there's no 'of <external>')*/ 
    ASSIGN
      iWhereBufPos = INDEX(cQueryString + " "," ":U + cBuffer + " ":U)
      iPos         = INDEX(cQueryString,      " ":U + cBuffer + ",":U)
      iWhereBufPos = (IF iWhereBufPos > 0 AND iPos > 0
                      THEN MIN(iPos,iWhereBufPos) 
                      ELSE MAX(iPos,iWhereBufPos))
                      + 1
      iDiff        = 0.                          

    /* We have a new expression */                               
    IF cBufWhere <> "":U THEN
    DO: 
      
      ASSIGN 
        cQueryString = DYNAMIC-FUNCTION('newWhereClause':U IN TARGET-PROCEDURE,
                                         cBuffer,
                                         cBufWhere,
                                         cQueryString,
                                         'AND':U) 
        /* get the offset of the new expression */
        iExpPos      = INDEX(cQuerystring,cBufwhere,iWhereBufPos).
      
      /* Store the offset from the buffer's offset */  
      DO iColumn =((iOldEntries + 1) * 3) - 2 TO NUM-ENTRIES(cQueryBufCols) BY 3:
        ENTRY(iColumn + 1,cQueryBufCols) = 
                            STRING(INT(ENTRY(iColumn + 1,cQueryBufCols)) 
                                   + (iExpPos - iWhereBufPos)
                                   ).                 
      END. /* do icolumn = 1 to num-entries */        
    END. /* if cbufwhere <> '' do */  
    
    IF iLowestChanged > 0 THEN 
    DO iColumn = iLowestChanged TO NUM-ENTRIES(cQueryBufCols) BY 3:       
      ASSIGN
        iValPos    = INT(ENTRY(iColumn + 1,cQueryBufCols))
        iValLength = INT(ENTRY(iColumn + 2,cQueryBufCols))
        iValPos    = iValPos + iDiff.                    
                     
      IF CAN-DO(cChangedList,STRING(INT((iColumn - 1) / 3 + 1))) THEN       
      DO:
        ASSIGN
          cValue     = ENTRY(INT((iColumn - 1) / 3 + 1),cChangedValues,CHR(1)) 
          SUBSTR(cQueryString,iValPos + iWhereBufPos,iValLength) = cValue
          idiff      = iDiff + (LENGTH(cValue) - iValLength)
          iValLength = LENGTH(cValue).   
      END. /* can-do(changelist,string(..) */          
      ASSIGN      
        ENTRY(iColumn + 1,cQueryBufCols) = STRING(iValPos)
        ENTRY(iColumn + 2,cQueryBufCols) = STRING(iVallength).      
    END. /* else if ilowestchanged do icolumn = ilowestChanged to num-entries */  
    
    /* If the buffer has no entry in QueryColumns we append the new entry 
       The order in Querycolumns is NOT dependent of the order in the query */              
    IF cQueryBufCols <> "":U THEN
    DO:    
      IF iBufPos = 0 THEN   
         cQueryColumns = cQueryColumns 
                         + (IF cQueryColumns = "":U THEN "":U ELSE ":":U)
                         + cBuffer + ":" + cQueryBufCols.
      
      ELSE /* There is already a entry for this buffer */
        ENTRY(iBufPos + 1,cQueryColumns,":":U) = cQueryBufCols.        
    END. /* cQueryBufCols <> '' */

  END. /* do iBuffer = 1 to hQuery:num-buffers */
  
  &SCOPED-DEFINE xp-assign
  {set QueryColumns cQueryColumns}
  {set QueryString cQueryString}.
  &UNDEFINE xp-assign
  
  RETURN TRUE. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-bufferWhereClause) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION bufferWhereClause Procedure 
FUNCTION bufferWhereClause RETURNS CHARACTER
  (pcBuffer AS CHAR,
   pcWhere  AS CHAR) :
/*------------------------------------------------------------------------------
  Purpose:     Returns the complete query where clause for a specified buffer
               INCLUDING leading and trailing blanks.
               EXCLUDING commas and period.                            
  Parameters:  pcBuffer     - Buffer. See notes
               pcWhere      - A complete query:prepare-string.
                            - ? use the current query                              
  Notes:       This is supported as a 'utility function' that doesn't use any 
               properties. 
               if target-procedure = super the passed buffer's qualification 
               MUST match the query's. 
               If target-procedure <> super the buffer will be corrected 
               IF it exists in the object's query.  
            -  RETURNs the expression immediately when found. 
               RETURNs '' at bottom if nothing is found. 
------------------------------------------------------------------------------*/
 DEFINE VARIABLE iComma      AS INT        NO-UNDO. 
 DEFINE VARIABLE iCount      AS INT        NO-UNDO.
 DEFINE VARIABLE iStart      AS INT        NO-UNDO.
 DEFINE VARIABLE cString     AS CHAR       NO-UNDO.
 DEFINE VARIABLE cFoundWhere AS CHAR       NO-UNDO.
 DEFINE VARIABLE cNextWhere  AS CHAR       NO-UNDO.
 DEFINE VARIABLE cTargetType AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE cBuffer     AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE iUseIdxPos  AS INT        NO-UNDO.        
 DEFINE VARIABLE iByPos      AS INT        NO-UNDO.        
 DEFINE VARIABLE iIdxRePos   AS INT        NO-UNDO.  
 DEFINE VARIABLE iOptionPos  AS INTEGER    NO-UNDO.

 /* If unkown value is passed used the existing query string */
 IF pcWhere = ? THEN
 DO:
   /* The QueryString contains data if the query is being currently worked on 
      by this method or addQuerywhere over many calls. */
   {get QueryString pcWhere}.      
   /* If no QueryString find the current query */ 
   IF pcWhere = "":U OR pcWhere = ? THEN
     {get QueryStringDefault pcWhere}.    
 END. /* pcWhere = ? */

 ASSIGN
   cString = RIGHT-TRIM(pcWhere," ":U)  
   iStart  = 1.

 /* Keep our promises and ensure that trailing blanks BEFORE the period are 
    returned, but remove the period and trailing blanks AFTER it. 
    If the length of right-trim with blank and blank + period is the same 
    then there is no period, so just use the passed pcWhere as is. 
    (Otherwise the remaining period is right-trimmed with comma further down)*/  
 IF LENGTH(cString) = LENGTH(RIGHT-TRIM(pcWhere,". ":U)) THEN
   cString = pcWhere.

 /* This is the guts of what used to be in newQueryWhere, which used to be 
    called without IN TARGET-PROCEDURE... so if target is a super we just keep 
    the old requirement of correct qual, otherwise we try to resolve it,
    but we continue the search also if it is not found in the current query 
    in order to support this and newQueryWhere as utilities for any buffer and 
    query.  */ 
 cTargetType = DYNAMIC-FUNCTION('getObjectType':U IN TARGET-PROCEDURE).
 
 IF cTargetType <> 'SUPER':U THEN
 DO:
   cBuffer = {fnarg resolveBuffer pcBuffer}. 
 
   IF cBuffer <> '':U AND cBuffer <> ? THEN
     pcBuffer = cBuffer.
 END. /* TARGET = SUPER */

 DO WHILE TRUE:
   iComma  = INDEX(cString,",":U). 
   
   /* If a comma was found we split the string into cFoundWhere and cNextwhere */  
   IF iComma <> 0 THEN 
     ASSIGN
       cFoundWhere = cFoundWhere + SUBSTR(cString,1,iComma)
       cNextWhere  = SUBSTR(cString,iComma + 1)     
       iCount      = iCount + iComma.       
   ELSE      
     /* cFoundWhere is blank if this is the first time or if we have moved on 
        to the next buffer's where clause
        If cFoundwhere is not blank the last comma that was used to split 
        the string into cFoundwhere and cNextwhere was not a join, so we set 
        them together again.  */     
     cFoundWhere = IF cFoundWhere = "":U 
                   THEN cString
                   ELSE cFoundWhere + cNextwhere.
          
   /* We have a complete table whereclause if there are no more commas
      or the next whereclause starts with each,first or last */    
   IF iComma = 0 
   OR CAN-DO("EACH,FIRST,LAST":U,ENTRY(1,TRIM(cNextWhere)," ":U)) THEN
   DO:
     /* Remove comma or period before inserting the new expression */
     ASSIGN
       cFoundWhere = RIGHT-TRIM(cFoundWhere,",.":U). 
     
     IF {fnarg whereClauseBuffer cFoundWhere} = pcBuffer THEN
     DO:
       ASSIGN
         iByPos        = INDEX(cFoundWhere," BY ":U)    
         iUseIdxPos    = INDEX(cFoundWhere," USE-INDEX ":U)    
         iIdxRePos     = INDEX(cFoundWhere + " ":U," INDEXED-REPOSITION ":U)
         iOptionPos    = MIN(IF iByPos > 0     THEN iByPos     ELSE LENGTH(cFoundWhere),
                             IF iUseIdxPos > 0 THEN iUseIdxPos ELSE LENGTH(cFoundWhere),
                             IF iIdxRePos > 0  THEN iIdxRePos  ELSE LENGTH(cFoundWhere)
                            )
         .

       RETURN TRIM(SUBSTR(cFoundWhere,1,iOptionPos)).
     END.
     ELSE
       /* We're moving on to the next whereclause so reset cFoundwhere */ 
       ASSIGN      
         cFoundWhere = "":U                     
         iStart      = iCount + 1.      
     
     /* No table found and we are at the end so we need to get out of here */  
     IF iComma = 0 THEN 
       LEAVE.    
   END. /* if iComma = 0 or can-do(EACH,FIRST,LAST */
   cString = cNextWhere.  
 END. /* do while true. */

 RETURN '':U.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-cancelRow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION cancelRow Procedure 
FUNCTION cancelRow RETURNS CHARACTER
  ( ) :
/*------------------------------------------------------------------------------
  Purpose:     Cancels an Add, Copy, or Save operation.  
  Parameters:  <none>  
  Notes:       cancelRow restores the original values of a modified row from 
               the before-image record.
------------------------------------------------------------------------------*/
 DEFINE VARIABLE lNew          AS LOG        NO-UNDO.
 DEFINE VARIABLE rRowid        AS ROWID      NO-UNDO.
 DEFINE VARIABLE hRowObject    AS HANDLE     NO-UNDO.
 DEFINE VARIABLE hBefore       AS HANDLE     NO-UNDO.
 DEFINE VARIABLE hDataquery    AS HANDLE     NO-UNDO.
 
 &SCOPED-DEFINE xp-assign
 {get NewMode lNew}
 {get RowObject hRowObject}
 {set DataModified FALSE}.
 .
 &UNDEFINE xp-assign
 
 IF lNew THEN 
 DO:
   hBefore = hRowObject:BEFORE-BUFFER.
   hBefore:FIND-BY-ROWID(hRowObject:BEFORE-ROWID).
   
   /* transaction works around core bug/behavior that may cause row-updated to 
      fire at unexpected places */
   /* no-error -- already exists errors seen when default values 
                  clashes with existing data (probably core bug?) */
   DO TRANSACTION:
     hBefore:REJECT-ROW-CHANGES NO-ERROR.  
   END.

   &SCOPED-DEFINE xp-assign
   {get DataHandle hDataQuery}
   {get CurrentRowid rRowid}
   .
   &UNDEFINE xp-assign
   /* Tell a browse updateSource to get rid of the insert-row */
   PUBLISH 'cancelNew':U FROM TARGET-PROCEDURE.
 
   IF hDataQuery:IS-OPEN AND rRowid <> ? THEN 
   DO:
     hDataQuery:REPOSITION-TO-ROWID(rRowid) NO-ERROR.
     /* Next needed if not browser (Data-Target) */
     IF NOT hRowObject:AVAILABLE AND ERROR-STATUS:GET-MESSAGE(1) = '':U THEN  
        hDataQuery:GET-NEXT() NO-ERROR.
   END.  /* IF the query is open */
   {set CurrentRowid ?}.
 END.
 RUN rowChanged IN TARGET-PROCEDURE('DIFFERENT':U).

 RETURN '':U. /* This used to return a cError variable for some forgotten reason*/

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-canNavigate) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION canNavigate Procedure 
FUNCTION canNavigate RETURNS LOGICAL
  ( ) :
/*------------------------------------------------------------------------------
  Purpose: Check if this object or its children has any updates   
    Notes: You can navigate an object that has uncommiited changes, but not 
           if the children has uncommitted changes, so this publishes 
           IsUpdatePending to check children as this includes rowObjectState 
           in the check.
         - Navigating objects will typically call this to check if the object
           that they are navigating can be navigated. Nav objects receives
           updateState from the objects they navigate and will perform this 
           check in the source of any 'updateComplete' message. This is required
           because an 'updateComplete' may come from a branch of a data-link 
           tree while publish isUpdatePending will check the whole tree to 
           ensure that no branches has pending updates. 
         - This returns true if we can navigate while isUpdatePending is the 
           opposite and returns true if update is pending. 
          (The real reason: It's easier to have default false for i-o params)   
------------------------------------------------------------------------------*/
   DEFINE VARIABLE lDataModified   AS LOGICAL    NO-UNDO.
   DEFINE VARIABLE lUpdate         AS LOGICAL    NO-UNDO.
   DEFINE VARIABLE lNewMode        AS LOGICAL    NO-UNDO.  
   DEFINE VARIABLE lQueryOpen      AS LOGICAL    NO-UNDO.

   &SCOPED-DEFINE xp-assign
   {get DataModified lDataModified}      
   /* Use NewMode refers to the current Object's state, NOT newRow */ 
   {get NewMode lNewMode}  
   {get QueryOpen lQueryOpen}
   .
   &UNDEFINE xp-assign
   IF NOT lQueryOpen THEN
     RETURN FALSE.

   /* Use = TRUE to ensure that unknown is treated similar to false */
   lUpdate = (lDataModified = TRUE) OR (lNewMode = TRUE). 
   /* This object does not block navigation, check all targets, 
      updatePending does the same check, but it always checks rowObjectstate 
      also to see if there are any pending uncommitted changes */         
   IF NOT lUpdate THEN  
     PUBLISH 'isUpdatePending':U FROM TARGET-PROCEDURE (INPUT-OUTPUT lUpdate).
   
   RETURN NOT lUpdate.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-childForeignFields) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION childForeignFields Procedure 
FUNCTION childForeignFields RETURNS CHARACTER
  ( pcChild AS CHAR ) :
/*------------------------------------------------------------------------------
  Purpose: Return the foreignfields for a child relation  
    Notes:  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hDatasetSource AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cForeignFields AS CHARACTER  NO-UNDO.

  {get DatasetSource hDatasetSource}.
  IF VALID-HANDLE(hDatasetSource) THEN
  DO:
    cForeignFields = {fnarg foreignFields pcChild hDatasetSource}.
  END.

  RETURN cForeignFields.  

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-closeQuery) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION closeQuery Procedure 
FUNCTION closeQuery RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: Close the query 
    Notes:     
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hDataQuery     AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hDatasetSource AS HANDLE     NO-UNDO.
  DEFINE VARIABLE lIsFetched     AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cDataTable     AS CHARACTER  NO-UNDO.

  {get DataHandle hDataQuery}.
  IF VALID-HANDLE(hDataQuery) THEN
  DO:
    &SCOPED-DEFINE xp-assign
    {get DatasetSource hDatasetSource}
    {get DataIsFetched lIsFetched}
    {get DataTable cDataTable}
    {set FirstRowNum 0}
    {set LastRowNum 0}
     .
    &UNDEFINE xp-assign

    hDataQuery:QUERY-CLOSE().
     
    RUN rowChanged IN TARGET-PROCEDURE('DIFFERENT':U). 
    
    RETURN TRUE.  
  END.

  RETURN FALSE.  

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnColumnLabel) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION columnColumnLabel Procedure 
FUNCTION columnColumnLabel RETURNS CHARACTER
  ( pcColumn AS CHARACTER ) :
/*------------------------------------------------------------------------------
     Purpose: Returns the Progress ColumnLabel for a specified column.  
              
  Parameters: INPUT pcColumn 
                    - DataTable qualified column name.
                    - Unqualified column name of the DataTable.                    
                    - Column name qualified with "RowObject" is valid reference 
                      to the DataTable.   
      Notes:  This is the list oriented label, which is NOT the same as 
              the Label. 
              The Label is returned if columnlabel is not defined.  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hCol       AS HANDLE NO-UNDO.
  
  hCol = {fnarg columnHandle pcColumn}. 

  RETURN IF hCol = ?                   THEN ?
         ELSE IF hCol:COLUMN-LABEL = ? THEN {fnarg columnLabel pcColumn}
         ELSE                               hCol:COLUMN-LABEL.
END.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnDataType) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION columnDataType Procedure 
FUNCTION columnDataType RETURNS CHARACTER
  ( pcColumn AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:     Returns the Progress datatype of a specified column.  
              
   Parameters: INPUT pcColumn 
                    - DataTable qualified column name.
                    - Unqualified column name of the DataTable.                    
                    - Column name qualified with "RowObject" is valid reference 
                      to the DataTable.   
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hCol       AS HANDLE NO-UNDO.

  hCol = {fnarg columnHandle pcColumn}. 

  RETURN IF hCol = ? THEN ? ELSE hCol:DATA-TYPE.     
  
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnDefaultValue) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION columnDefaultValue Procedure 
FUNCTION columnDefaultValue RETURNS CHARACTER
  ( pcColumn AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:    Returns the Progress help text for a specified column.  
   Parameters: INPUT pcColumn 
                    - DataTable qualified column name.
                    - Unqualified column name of the DataTable.                    
                    - Column name qualified with "RowObject" is valid reference 
                      to the DataTable.   
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hCol       AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cValue     AS CHARACTER  NO-UNDO.

  hCol = {fnarg columnHandle pcColumn}. 
  IF VALID-HANDLE(hCol) THEN
  DO:
    cValue = hCol:DEFAULT-STRING.
    /* The default-string returns literals for now and today, 
       We treat this as the anticipated default-value (datatype =run-type) */  
    IF hCol:DATA-TYPE BEGINS 'DATE':U THEN
    DO:
      CASE cValue: 
        WHEN 'TODAY':U THEN
          cValue = STRING(TODAY).
        WHEN 'NOW' THEN
          cValue = STRING(NOW).
      END CASE.
    END.
    RETURN cValue.
  END.
  
  RETURN ?. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnFormat) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION columnFormat Procedure 
FUNCTION columnFormat RETURNS CHARACTER
  ( pcColumn AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:    Returns the format for a specified column.  
   Parameters: INPUT pcColumn 
                    - DataTable qualified column name.
                    - Unqualified column name of the DataTable.                    
                    - Column name qualified with "RowObject" is valid reference 
                      to the DataTable.   
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hCol       AS HANDLE NO-UNDO.

  hCol = {fnarg columnHandle pcColumn}. 
  
  RETURN IF hCol = ? THEN ? ELSE hCol:FORMAT.  

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnHandle) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION columnHandle Procedure 
FUNCTION columnHandle RETURNS HANDLE
  ( pcColumn AS CHAR) :
/*------------------------------------------------------------------------------
  Purpose:    Returns the handle of a temp-table column.  
  Parameters: INPUT pcColumn 
               - Unqualified column name of the DataTablefield.
               - Column name qualified with "RowObject".   
               - qualified temp-table column name. 
       Notes: Used by other column functions and the browse.  
------------------------------------------------------------------------------*/
 DEFINE VARIABLE hRowObject   AS HANDLE     NO-UNDO.
 DEFINE VARIABLE hColumn      AS HANDLE     NO-UNDO.
 DEFINE VARIABLE cDataTable   AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE cTable       AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE hBuffer      AS HANDLE     NO-UNDO.
 DEFINE VARIABLE hDataset     AS HANDLE     NO-UNDO.
 DEFINE VARIABLE hQuery       AS HANDLE     NO-UNDO.
 DEFINE VARIABLE cViewTables  AS CHARACTER  NO-UNDO.

 {get RowObject hBuffer}.
 IF NOT VALID-HANDLE(hBuffer) THEN
   RETURN ?.

 IF NUM-ENTRIES(pcColumn,".":U) = 2 THEN
 DO:
   IF pcColumn BEGINS 'RowObject.':U THEN
     pcColumn  = ENTRY(2,pcColumn,'.':U).
   ELSE DO:
     {get DataTable cDataTable}.
     IF cDataTable > '' THEN
     DO:
       cTable = ENTRY(1,pcColumn,'.':U).
       pcColumn  = ENTRY(2,pcColumn,'.':U).
       IF cTable <> cDataTable THEN
       DO:
         &SCOPED-DEFINE xp-assign
         {get DatasetSource hDataset}
         {get DataHandle hQuery}
         .
         &UNDEFINE xp-assign
         /* First check in query (defined in QueryTables) */
         hBuffer = hQuery:GET-BUFFER-HANDLE(cTable) NO-ERROR.
         IF NOT VALID-HANDLE(hBuffer) THEN
         DO:
           {get ViewTables cViewTables}.
           IF LOOKUP(cTable,cViewTables) > 0 THEN
           DO:
             hBuffer = {fnarg dataTableHandle cTable hDataset}.
           END.
         END. /* not in query */
       END.
     END. /* DataTable > '' */
   END.
 END.
 
 hColumn = hBuffer:BUFFER-FIELD(pcColumn) NO-ERROR.

 RETURN hColumn.   
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnHelp) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION columnHelp Procedure 
FUNCTION columnHelp RETURNS CHARACTER
  ( pcColumn AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:    Returns the Progress help text for a specified column.  
   Parameters: INPUT pcColumn 
                    - DataTable qualified column name.
                    - Unqualified column name of the DataTable.                    
                    - Column name qualified with "RowObject" is valid reference 
                      to the DataTable.   
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hCol       AS HANDLE NO-UNDO.

  hCol = {fnarg columnHandle pcColumn}. 
  
  RETURN IF hCol = ? THEN ? ELSE hCol:HELP.  

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnInitial) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION columnInitial Procedure 
FUNCTION columnInitial RETURNS CHARACTER
  ( pcColumn AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:   Returns the initial value for a specified field as a character
             string with the field FORMAT applied.
   Parameters: INPUT pcColumn 
                    - DataTable qualified column name.
                    - Unqualified column name of the DataTable.                    
                    - Column name qualified with "RowObject" is valid reference 
                      to the DataTable.   
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hCol       AS HANDLE NO-UNDO.

  hCol = {fnarg columnHandle pcColumn}. 
  
  RETURN IF hCol = ? THEN ? ELSE hCol:INITIAL.  

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnLabel) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION columnLabel Procedure 
FUNCTION columnLabel RETURNS CHARACTER
  ( pcColumn AS CHARACTER ) :
/*------------------------------------------------------------------------------
     Purpose: Returns the Progress ColumnLabel for a specified column.  
              
  Parameters: INPUT pcColumn 
                    - DataTable qualified column name.
                    - Unqualified column name of the DataTable.                    
                    - Column name qualified with "RowObject" is valid reference 
                      to the DataTable.   
      Notes:  The Name is returned if label not defined.  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hCol       AS HANDLE NO-UNDO.
  
  hCol = {fnarg columnHandle pcColumn}. 
  
  RETURN IF hCol = ?            THEN ? 
         ELSE IF hCol:LABEL = ? THEN hCol:NAME 
         ELSE                        hCol:LABEL.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnLongCharValue) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION columnLongCharValue Procedure 
FUNCTION columnLongCharValue RETURNS LONGCHAR
  ( pcColumn AS CHARACTER ) :
/*------------------------------------------------------------------------------
     Purpose: Returns the LONGCHAR value of a specified column in the 
              DataView DataTable buffer. 
              
  Parameters: INPUT pcColumn 
                    - DataTable qualified column name.
                    - Unqualified column name of the DataTable.                    
                    - Column name qualified with "RowObject" is valid reference 
                      to the DataTable.   
       Note:   ? in a CLOB is returned as blank!      
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hCol       AS HANDLE   NO-UNDO.
  DEFINE VARIABLE cLongValue AS LONGCHAR NO-UNDO.

  hCol = {fnarg columnHandle pcColumn}. 
  
  CASE hCol:DATA-TYPE:
    WHEN 'CLOB':U THEN
    DO:
      IF LENGTH(hCol:BUFFER-VALUE) > 0 THEN 
        COPY-LOB FROM hCol:BUFFER-VALUE TO cLongValue NO-ERROR.
      ELSE 
        cLongValue = ''.
    END.
    WHEN 'BLOB':U THEN
    DO:
      IF hCol:BUFFER-VALUE <> ? THEN
      DO:
        COPY-LOB FROM hCol:BUFFER-VALUE TO cLongValue NO-ERROR.
      /* just show the default progress error, but set return value to ? */ 
        IF ERROR-STATUS:ERROR THEN
        DO:
          MESSAGE ERROR-STATUS:GET-MESSAGE(1)
                  VIEW-AS ALERT-BOX ERROR.
          cLongValue = ''.
        END.
      END.
    END.
    WHEN 'CHARACTER':U THEN
      cLongValue = hCol:BUFFER-VALUE.
    OTHERWISE 
      cLongValue = STRING(hCol:BUFFER-VALUE).

  END CASE.

  RETURN cLongValue.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnName) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION columnName Procedure 
FUNCTION columnName RETURNS CHARACTER
  ( phHandle AS HANDLE) :
/*------------------------------------------------------------------------------
  Purpose: Resolves the external unique name of the column from the passed 
           field handle.  
    Notes:    
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cName   AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hColumn AS HANDLE     NO-UNDO.

  IF VALID-HANDLE(phHandle) THEN
  DO:
    /* Check if the handle can be found with this name  */  
    cName = phHandle:TABLE + '.':U + phHandle:NAME NO-ERROR.
    IF cName > '' THEN
      hColumn = {fnarg columnHandle cName}.
    
    IF phHandle = hColumn THEN
      RETURN cName.
  END.

  RETURN ''.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnPrivateData) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION columnPrivateData Procedure 
FUNCTION columnPrivateData RETURNS CHARACTER
  ( pcColumn AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:    Returns the Progress Private-Data attribute of a specified column. 
   Parameters: INPUT pcColumn 
                    - DataTable qualified column name.
                    - Unqualified column name of the DataTable.                    
                    - Column name qualified with "RowObject" is valid reference 
                      to the DataTable.   
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hCol       AS HANDLE NO-UNDO.

  hCol = {fnarg columnHandle pcColumn}. 

  RETURN IF hCol = ? THEN ? ELSE hCol:PRIVATE-DATA.  

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnQuerySelection) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION columnQuerySelection Procedure 
FUNCTION columnQuerySelection RETURNS CHARACTER
  ( pcColumn AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:     Returns a CHR(1) separated string with ALL operators and values 
               that has been added to the Query for this column using the 
               assignQuerySelection method. 
               
               Example: If the query contains 'custnum > 5 and custnum < 9' 
                        this function will return (chr(1) is shown as '|'): 
                        '>|5|<|9'    
                              
  Parameters:
   INPUT pcColumn - Fieldname of a table in the query in the form of 
                    TBL.FLDNM or DB.TBL.FLDNM (only if qualified with db),
                    If the fieldname isn't qualified it checks the tables in 
                    the TABLES property and assumes the first with a match.
 
  Notes:       The data returned reflects the QueryString/QueryColumns properties, 
               which is maintained by the assignQuerySelection. These values
               may not have been used in an openQuery yet.
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cQueryString   AS CHARACTER NO-UNDO.
  DEFINE VARIABLE cBuffer        AS CHARACTER NO-UNDO.
  DEFINE VARIABLE cBufferList    AS CHARACTER NO-UNDO.
  
  DEFINE VARIABLE cColumn        AS CHARACTER NO-UNDO.
    
  DEFINE VARIABLE iBuffer        AS INTEGER   NO-UNDO.
  DEFINE VARIABLE cValue         AS CHARACTER  NO-UNDO.  
  DEFINE VARIABLE cOperator      AS CHARACTER NO-UNDO.
        
  /* Used to store and maintain offset and length */    
  DEFINE VARIABLE iValLength     AS INTEGER   NO-UNDO.
  DEFINE VARIABLE iValPos        AS INTEGER   NO-UNDO.
  DEFINE VARIABLE cString        AS CHAR      NO-UNDO.
  DEFINE VARIABLE cQueryColumns  AS CHAR      NO-UNDO.
  DEFINE VARIABLE cQueryBufCols  AS CHAR      NO-UNDO.
  DEFINE VARIABLE iBufPos        AS INTEGER   NO-UNDO.
  DEFINE VARIABLE iColPos        AS INTEGER   NO-UNDO.
  DEFINE VARIABLE iPos           AS INTEGER   NO-UNDO.
  DEFINE VARIABLE iNumEnt        AS INTEGER   NO-UNDO.
  DEFINE VARIABLE cSelection     AS CHAR      NO-UNDO.
  DEFINE VARIABLE iWhereBufPos   AS INTEGER   NO-UNDO.
  
  &SCOPED-DEFINE xp-assign
  {get QueryString cQueryString}
  {get QueryColumns cQueryColumns}.
  &UNDEFINE xp-assign
  
  /* If the properties are blank we return immediately with blank */
  IF cQueryString = "":U OR cQueryColumns = "":U THEN 
    RETURN "":U.

  iNumEnt  = NUM-ENTRIES(pcColumn,".":U).
  
  /* If the column is qualified add the buffer part of it to the bufferlist
     which then will be the only entry in the list for the loop below */ 
  
  IF iNumEnt > 1 THEN
    ASSIGN
      cBufferList = SUBSTR(pcColumn,1,R-INDEX(pcColumn,".") - 1)
      cBufferList = {fnarg resolveBuffer cBufferList} 
      cColumn     = ENTRY(iNumEnt,pcColumn,".":U).
  
  ELSE DO:         
    cColumn = pcColumn.     
    {get QueryTables cBufferList}.    
  END.
  
  DO iBuffer = 1 TO NUM-ENTRIES(cBufferList):    
    ASSIGN
      cBuffer        = ENTRY(iBuffer,cBufferList)
      iBufPos        = LOOKUP(cBuffer,cQueryColumns,":":U)
      cQueryBufCols  = IF iBufPos > 0 
                       THEN ENTRY(iBufPos + 1,cQueryColumns,":":U) 
                       ELSE "":U
      iWhereBufPos   = INDEX(cQueryString + " ":U," ":U + cBuffer + " ":U)
      iPos           = INDEX(cQueryString,      " ":U + cBuffer + ",":U)
      iWhereBufPos   = (IF iWhereBufPos > 0 AND iPos > 0
                        THEN MIN(iPos,iWhereBufPos) 
                        ELSE MAX(iPos,iWhereBufPos))
                        + 1
      iColPos = 1.
      
    DO WHILE icolPos > 0:
      /* Add comma to cQueryBufCols to find first entry and search for ,column.*/
      iColPos = INDEX(",":U + cQueryBufCols,",":U + cColumn + ".":U,icolPos).
      IF iColpos > 0 THEN
      DO:
        ASSIGN
          iColPos    = iColPos + LENGTH(cColumn) + 1
          cString    = SUBSTR(cQueryBufCols,iColPos)
          cOperator  = ENTRY(1,cString)
          iValPos    = INT(ENTRY(2,cString)) 
          iValLength = INT(ENTRY(3,cString))
          cValue     = SUBSTR(cQueryString,iValPos + iWhereBufPos,iValLength)
           /* replace escaped single quotes */
          cValue     = (REPLACE(CValue,"~~'","'"))
          /* From 9.1B the quote is included in the pos/length */
          cValue     = IF NOT cValue BEGINS "'" THEN cValue
                       ELSE SUBSTR(cValue,2,LENGTH(cValue) - 2)
          cSelection = cSelection 
                       + CHR(1)
                       + cOperator
                       + CHR(1)
                       + cValue.                       
      END.  /* if icolpos > 0 */
    END. /* do while icolpos > 0 */    
    IF cSelection <> "":U THEN LEAVE.
  END. /* do ibuffer = 1 to num-entries */      
  
  RETURN LEFT-TRIM(cSelection,CHR(1)). 
  
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnReadOnly) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION columnReadOnly Procedure 
FUNCTION columnReadOnly RETURNS LOGICAL
  ( pcColumn AS CHARACTER ) :
/*------------------------------------------------------------------------------
      Purpose: Returns true if the specified column is read only
              
  Parameters: INPUT pcColumn 
                    - DataTable qualified column name.
                    - Unqualified column name of the DataTable.                    
                    - Column name qualified with "RowObject" is valid reference 
                      to the DataTable.   
  Notes:       A visualization may use this dynamically to determine whether 
               the field should be updatable on the screen.  Even still, there
               may be circumstances where it is desirable to have it updatable
               on the screen but if it is READ-ONLY in the SmartDataObject any
               changes sent back to the SmartDataObject will not be made in
               the RowObject temp-table and, therefore, in the database.
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cUpdatable   AS CHARACTER NO-UNDO.
  DEFINE VARIABLE cColumns     AS CHARACTER NO-UNDO.
  DEFINE VARIABLE cDataTable   AS CHARACTER  NO-UNDO.

  {get DataTable cDataTable}.

  IF NUM-ENTRIES(pcColumn,".":U) = 1 THEN
    ASSIGN
      pcColumn = cDataTable 
               + '.':U
               + pcColumn.
  ELSE IF pcColumn BEGINS "RowObject.":U THEN
    ASSIGN
      pcColumn = cDataTable 
               + '.':U
               + ENTRY(2,pcColumn,".":U).
             
  {get UpdatableColumns cUpdatable}.  

  RETURN LOOKUP(pcColumn,cUpdatable) > 0.
  

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnStringValue) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION columnStringValue Procedure 
FUNCTION columnStringValue RETURNS CHARACTER
  ( pcColumn AS CHARACTER ) :
/*------------------------------------------------------------------------------
      Purpose: Returns the formatted value of the specified column.
  Parameters: INPUT pcColumn 
                    - DataTable qualified column name.
                    - Unqualified column name of the DataTable.                    
                    - Column name qualified with "RowObject" is valid reference 
                      to the DataTable.   
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hCol       AS HANDLE NO-UNDO.

  hCol = {fnarg columnHandle pcColumn}. 
  IF VALID-HANDLE(hCol) THEN
  DO:
    IF hCol:DATA-TYPE = 'CLOB':U OR hCol:DATA-TYPE = 'BLOB':U THEN
    DO:
      /* Design time error .. */
      MESSAGE SUBSTITUTE({fnarg MessageNumber 95},PROGRAM-NAME(1),
                                             hCol:NAME,
                                             hCol:DATA-TYPE)
              VIEW-AS ALERT-BOX ERROR.
      RETURN ?.
    END.
    RETURN hCol:STRING-VALUE.
  END.

  RETURN ?.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnTable) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION columnTable Procedure 
FUNCTION columnTable RETURNS CHAR
  ( pcColumn AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:    Returns the table for a specified column.  
   Parameters: INPUT pcColumn 
                    - DataTable qualified column name.
                    - Unqualified column name of the DataTable.                    
                    - Column name qualified with "RowObject" is valid reference 
                      to the DataTable.   
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hCol AS HANDLE NO-UNDO.

  hCol = {fnarg columnHandle pcColumn}. 
 
  RETURN IF hCol = ? THEN ? ELSE hCol:TABLE.  

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnValue) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION columnValue Procedure 
FUNCTION columnValue RETURNS CHARACTER
  ( pcColumn AS CHARACTER ) :
/*------------------------------------------------------------------------------
      Purpose: Returns the unformatted value of the specified column.
  Parameters: INPUT pcColumn 
                    - DataTable qualified column name.
                    - Unqualified column name of the DataTable.                    
                    - Column name qualified with "RowObject" is valid reference 
                      to the DataTable.   
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hCol            AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hRowObject      AS HANDLE     NO-UNDO.
  DEFINE VARIABLE lDataTable      AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cColumnName     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cValue          AS CHARACTER  NO-UNDO.
  
  {get RowObject hRowObject}.
  IF NOT VALID-HANDLE(hRowObject) OR NOT hRowObject:AVAILABLE THEN
    RETURN ?.
   
  /* performance overrides reuse in this, function calls are expensive  */
  IF INDEX(pcColumn,'.':U) > 0 THEN
    ASSIGN 
      lDataTable  = ENTRY(1,pcColumn,'.':U) = hRowObject:NAME
      cColumnName = ENTRY(2,pcColumn,'.':U).
  ELSE
    ASSIGN
      lDataTable  = TRUE
      cColumnName = pcColumn.

  IF lDataTable THEN 
    hCol = hRowObject:BUFFER-FIELD(cColumnName) NO-ERROR.
  ELSE 
    hCol = {fnarg columnHandle pcColumn}. 

  IF VALID-HANDLE(hCol) THEN
  DO:
    IF hCol:DATA-TYPE = 'CLOB':U OR hCol:DATA-TYPE = 'BLOB':U THEN
    DO:
      /* Design time error .. */
      MESSAGE SUBSTITUTE({fnarg MessageNumber 95},PROGRAM-NAME(1),
                                             hCol:NAME,
                                             hCol:DATA-TYPE)
              VIEW-AS ALERT-BOX ERROR.
      RETURN ?.
    END.
    
    /* Expect no avail i.e. outer join */
    cValue = hCol:BUFFER-VALUE NO-ERROR.
 
    RETURN cValue.
  END.

  RETURN ?.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-columnWidth) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION columnWidth Procedure 
FUNCTION columnWidth RETURNS DECIMAL
  ( pcColumn AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:    Returns the width for a specified column.  
   Parameters: INPUT pcColumn 
                    - DataTable qualified column name.
                    - Unqualified column name of the DataTable.                    
                    - Column name qualified with "RowObject" is valid reference 
                      to the DataTable.   
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hCol       AS HANDLE NO-UNDO.

  hCol = {fnarg columnHandle pcColumn}. 
  
  RETURN IF hCol = ? THEN ? ELSE hCol:WIDTH.  

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-colValues) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION colValues Procedure 
FUNCTION colValues RETURNS CHARACTER
  ( pcViewColList AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:     Returns a CHR(1) delimited list of values for the requested
               columns (in pcViewColList) of the current row of the RowObject.
               The first value is the RowObect ROWID and RowIdent separated 
               with a comma.     
  Parameters:
    INPUT pcViewColList - Comma delimited list of RowObject column names
                        - SKIP means add blank value   
  Notes:       The form of the first value is:
                 <RowObject ROWID>,<DB Buffer1 ROWID>,<DB Buffer2 ROWID>,...
               This is used as a key to uniquely identify the row and its
               origins in the optimistic locking system.
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cColValues  AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE iCol        AS INTEGER    NO-UNDO.
  DEFINE VARIABLE hColumn     AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hBuffer     AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cBuffer     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE iColCount   AS INTEGER    NO-UNDO.
  DEFINE VARIABLE hRowObject  AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hDataSource AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cValue      AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cColumnRef  AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cColumn     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE lQueryOpen  AS LOGICAL    NO-UNDO.

  &SCOPED-DEFINE xp-assign
  {get RowObject hRowObject}     
  {get QueryOpen lQueryOpen}
  .
  &UNDEFINE xp-assign
  
  IF VALID-HANDLE(hrowObject) AND hRowObject:AVAILABLE AND lQueryOpen THEN 
  DO:    
    /* The first value passed back is always a "key" */
    ASSIGN 
      cColValues = STRING(hRowObject:ROWID) + CHR(1)
      iColCount  = NUM-ENTRIES(pcViewColList).
     
    DO iCol = 1 TO iColCount:
      cColumnRef = ENTRY(iCol, pcViewColList).
      IF cColumnRef <> 'SKIP':U THEN
      DO:
        ASSIGN
          cBuffer = (IF NUM-ENTRIES(cColumnRef ,'.':U) > 1 THEN
                     ENTRY(1,cColumnRef ,'.':U)
                     ELSE '':U)
          cColumn = (IF NUM-ENTRIES(cColumnRef ,'.':U) > 1 THEN
                     ENTRY(2,cColumnRef ,'.':U)
                     ELSE cColumnRef ).
        /* We don't call columnValue for performance, but there is 
           also a need to distinguish invalid column names from unknown values */
        IF cBuffer = hRowObject:NAME THEN
        DO:
          hColumn = hRowObject:BUFFER-FIELD(cColumn) NO-ERROR.
          IF hColumn:DATA-TYPE = 'CLOB':U OR hColumn:DATA-TYPE = 'BLOB':U THEN
          DO:
            /* Design time error .. */
            MESSAGE SUBSTITUTE({fnarg MessageNumber 95},PROGRAM-NAME(1),hColumn:NAME,hColumn:DATA-TYPE)
               VIEW-AS ALERT-BOX ERROR.
            RETURN ?.
          END.
          cValue  = RIGHT-TRIM(STRING(hColumn:BUFFER-VALUE)).

        END.
        ELSE IF NUM-ENTRIES(cColumnRef ,'.':U) > 1 THEN
        DO:
          cValue = {fnarg columnValue cColumnRef}.
          /* columnValue currently returns ? for invalid and unknown 
             (should probably just return '?' for unknown), so 
             check for validity */
          IF cValue = ? THEN 
          DO:
            hColumn = {fnarg columnHandle cColumnRef}.
            IF hColumn = ? THEN
              RETURN ?.
            /* just return blank for non available (unless logical or date)
               logicals are not very good at runtime conversions.. 
               date uses ? to display blank  */ 
            ELSE IF hColumn:DATA-TYPE = "LOGICAL":U THEN
              cValue = 'NO':U. 
            ELSE IF NOT hColumn:DATA-TYPE BEGINS "DATE":U THEN
              cValue = '':U.
          END.
        END.
        ELSE DO:
          /* If this is a <calc> field, make put a constant in so that the
             browser does not fail during displayFields */
          IF INDEX(ENTRY(iCol, pcViewColList), "<calc>":U) > 0 THEN
            cColValues = cColValues + CHR(4) + "<calc>":U + CHR(4). 
          ELSE 
            RETURN ?.
        END.       /* IF NOT VALID-HANDLE */
        cColValues = cColValues                         
                   + IF cValue = ? 
                     THEN "?":U 
                     ELSE cValue. 
      END. /* <> SKIP */
      IF iCol NE iColCount THEN cColValues = cColValues + CHR(1).
    END.  /* END iCol */
    RETURN cColValues.       
  END. /* valid and avail rowObject*/
  RETURN ?.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-copyLargeColumnToFile) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION copyLargeColumnToFile Procedure 
FUNCTION copyLargeColumnToFile RETURNS LOGICAL
  ( pcColumn   AS CHAR,
    pcFileName AS CHARACTER) :
/*------------------------------------------------------------------------------
   Purpose: Copy a large column to the passed filename. 
Parameters: pcColumn 
             - Unqualified column name of the field (qualified with table name).
            pcFileName - filename to copy the data to                      
     Notes:  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hCol       AS HANDLE NO-UNDO.
  
  hCol = {fnarg columnHandle pcColumn}. 
  
  IF VALID-HANDLE(hCol) THEN
  DO ON STOP UNDO,LEAVE ON ERROR UNDO,LEAVE:
    COPY-LOB FROM hCol:BUFFER-VALUE TO FILE pcFileName.
    RETURN TRUE.
  END.
  
  RETURN FALSE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-copyLargeColumnToMemptr) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION copyLargeColumnToMemptr Procedure 
FUNCTION copyLargeColumnToMemptr RETURNS LOGICAL
  ( pcColumn AS CHAR,
    pmMemptr AS MEMPTR) :
/*------------------------------------------------------------------------------
  Purpose: Copy the value of a large column to the passed Memptr
Parameters: pcColumn 
             - Unqualified column name of the field (qualified with table name).
               pcFileName - filename to copy the data to                      
            pmMemptr 
            - The memptr to copy the data to    
    Notes:  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hCol       AS HANDLE NO-UNDO.
  
  hCol = {fnarg columnHandle pcColumn}. 
    
  IF VALID-HANDLE(hCol) THEN
  DO ON STOP UNDO,LEAVE ON ERROR UNDO,LEAVE:
    COPY-LOB FROM hCol:BUFFER-VALUE TO pmMemptr.
    RETURN TRUE.
  END.
  
  RETURN FALSE.   

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-copyRow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION copyRow Procedure 
FUNCTION copyRow RETURNS CHARACTER
  ( pcViewColList AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:     Creates a new RowObject temp-table record, copies all of the 
               current row values to it.  The return value of this function is 
               a CHR(1) delimited list of the values of the current row as 
               specified in the input parameter pcViewColList.  The first value 
               of this return value is the RowIdent of the newly created row.
               
  Parameters:  
    INPUT pcViewColList - comma-separated list of columns whose values are to
                          be returned for the newly created row.
 ------------------------------------------------------------------------------*/
  DEFINE VARIABLE hRowObject     AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hFromBuffer    AS HANDLE     NO-UNDO.
  DEFINE VARIABLE iCol           AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cDispValues    AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cColumn        AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE iPos           AS INTEGER    NO-UNDO.
  DEFINE VARIABLE hDatasetSource AS HANDLE     NO-UNDO.
  DEFINE VARIABLE rRowid         AS ROWID      NO-UNDO.
  DEFINE VARIABLE cDataTable     AS CHARACTER  NO-UNDO.

  &SCOPED-DEFINE xp-assign
   {get RowObject hRowObject}
   {get DatasetSource hDatasetSource}
   {get DataTable cDataTable}
     /* Save off the "current" rowid in case the add is cancelled. 
     (rowid can be referenced when not avail) */
   {set CurrentRowid hRowObject:ROWID}

   .
  &UNDEFINE xp-assign
  
  IF NOT VALID-HANDLE(hRowObject) OR NOT VALID-HANDLE(hDatasetSource) THEN
    RETURN ?.

  IF hRowObject:AVAILABLE THEN
  DO:
    cDispValues = {fnarg colValues pcViewColList}.
    CREATE BUFFER hFrombuffer FOR TABLE hRowObject. 
    hFromBuffer:FIND-FIRST('WHERE ROWID(':U + hFromBuffer:NAME + ')':U  
                          + ' = TO-ROWID("':U + STRING(hRowObject:ROWID) + '")':U)
                NO-ERROR.
  END.
  
  rRowid = {fnarg createRow cDataTable hDatasetSource}.
  
  IF rRowid <> ? THEN
  DO:
    hRowObject:FIND-BY-ROWID(rRowid).
    /* scope to control row-updated firing  (may change) */
    DO TRANSACTION:
      IF VALID-HANDLE(hFromBuffer) AND hFromBuffer:AVAILABLE THEN 
        hRowObject:BUFFER-COPY(hFrombuffer,hRowObject:KEYS).  
  
      cDispValues = {fnarg colValues pcViewColList}.
    
     /* Finally the signature of this function serves some purpose as it allows 
         us to override the key values in the display even if they cannot be added 
         to the record. */
      DO iCol = 1 TO NUM-ENTRIES(hRowObject:KEYS):
        ASSIGN
          cColumn = ENTRY(iCol,hRowObject:KEYS)
          iPos    = LOOKUP(hRowObject:NAME + '.':U + cColumn,pcViewColList).
        IF iPos > 0 THEN
          ENTRY(iPos + 1,cDispValues,CHR(1)) = hFromBuffer:BUFFER-FIELD(cColumn):BUFFER-VALUE.
      END. /* do icol = 1 to */
    END.
  END. /* rowid <> ?  */

  IF VALID-HANDLE(hFromBuffer) THEN 
    DELETE OBJECT hFromBuffer NO-ERROR. 

  RETURN cDispValues.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-deleteRow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION deleteRow Procedure 
FUNCTION deleteRow RETURNS LOGICAL
  ( pcRowIdent AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:     Submits a row for deletion. Returns FALSE if an error occurs. 
  Parameters:  INPUT pcRowIdent - RowId of the RowObject temp-table to delete.
                                  (Usually from the visual object's RowIdent 
                                   or refined by the SBO's deleteRow)    
                                - Unknown means delete current.
  Notes:       If auto-commit is on, the row will immediately be sent back 
               to the db for deletion.
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cMessages      AS CHARACTER NO-UNDO.
  DEFINE VARIABLE cQueryPos      AS CHARACTER NO-UNDO.
  DEFINE VARIABLE hRowObject     AS HANDLE    NO-UNDO.
  DEFINE VARIABLE hDataQuery     AS HANDLE    NO-UNDO.
  DEFINE VARIABLE iCol           AS INTEGER   NO-UNDO.
  DEFINE VARIABLE iValue         AS INTEGER   NO-UNDO.
  DEFINE VARIABLE lAutoCommit    AS LOGICAL   NO-UNDO.
  DEFINE VARIABLE lBrowsed       AS LOGICAL   NO-UNDO.  
  DEFINE VARIABLE lNextNeeded    AS LOGICAL   NO-UNDO INIT no.
  DEFINE VARIABLE lSuccess       AS LOGICAL   NO-UNDO INIT yes.
  DEFINE VARIABLE rDataQuery     AS ROWID     NO-UNDO.
  DEFINE VARIABLE rRowBefore     AS ROWID     NO-UNDO.
  DEFINE VARIABLE lUpdFromSource AS LOGICAL   NO-UNDO.
  DEFINE VARIABLE lRepos         AS LOGICAL   NO-UNDO.
  DEFINE VARIABLE cMsg           AS CHAR      NO-UNDO.
  DEFINE VARIABLE lNewDeleted    AS LOGICAL   NO-UNDO.
  DEFINE VARIABLE iFirstResult   AS INTEGER    NO-UNDO.
  DEFINE VARIABLE iLastResult    AS INTEGER    NO-UNDO.
  DEFINE VARIABLE hRowIdent      AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hContainer     AS HANDLE     NO-UNDO.
  DEFINE VARIABLE lQueryContainer AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE hBeforeBuffer   AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cRowObjectState AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cKeyWhere       AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cBIKeyWhere     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cDeleteMsg      AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hDatasetSource  AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cDataTable      AS CHARACTER  NO-UNDO.

  &SCOPED-DEFINE xp-assign    
  {get RowObject hRowObject}
  {get DataHandle hDataQuery}
  {get DataQueryBrowsed lBrowsed}
  {get DatasetSource hDatasetSource}
  {get DataTable cDataTable}
  .
  &UNDEFINE xp-assign
       
  IF NOT VALID-HANDLE(hDatasetSource) THEN
    RETURN FALSE.

  /* Extract the RowObject ROWID from the RowIdent passed. If it's
     a valid ROWID and found in the Temp-Table, delete that row.
     If that entry isn't defined, then we're doing a delete for
     a query this object isn't managing. Create a RowObjUpd record
     for it (no data needed, just the RowIdent field) and delete it. */

  /* This includes ? which means delete current from 9.1B */
  IF pcRowIdent <> ? THEN
  DO: 
    rDataQuery = TO-ROWID(ENTRY(1, pcRowIdent)) NO-ERROR.
    IF NOT hRowObject:AVAILABLE OR hRowObject:ROWID <> rDataQuery THEN
    DO:
      hRowObject:BUFFER-RELEASE.
      lRepos = hDataQuery:REPOSITION-TO-ROWID(rDataQuery).
        
      IF lRepos = FALSE THEN
      DO:
        cMSg = string(29) + "," 
             + 'RowObject' + "," + 'ROWID ' + pcRowident + ''.
        {fnarg showMessage cMsg}.
      RETURN FALSE.
      END.
    END.
    /* If a Viewer is handling the delete, then we must Next on the query
       to make the row available. If the query's being browsed this is 
       implicit */    
    IF NOT hRowObject:AVAILABLE AND lRepos THEN
      hDataQuery:GET-NEXT(). 
    
    /* We need to try to find a RowObjUpd record for this row before 
       creating a new one.  findRowObjUpd takes the RowObject and RowObjUpd
       buffers and returns RowObjUpd buffer. */

  END. /* pcRowIdent <> ?  */
    
  lNewDeleted = hRowObject:ROW-STATE = ROW-CREATED.
  
  {get AutoCommit lAutoCommit}.
  {get QueryPosition cQueryPos}.  /* Were we on the first/last record? */
   

  /* If browsed we check whether the next record will be available 
      after deleteComplete. (implicit delete-current-row) */
  IF lBrowsed THEN 
  DO:
    /* @TODO future prodataset this must change if offend trigger is used   */
    hDataQuery:GET-NEXT.      
    lNextNeeded = hDataQuery:QUERY-OFF-END. 
    /* Back to Current */
    hDataQuery:GET-PREV.
  END.
  ELSE lNextNeeded = TRUE.
      
  cKeyWhere = {fn getKeyWhere}.
  cBIKeyWhere = DYNAMIC-FUNCTION('keyWhere' IN TARGET-PROCEDURE,
                                 hRowobject,hRowobject:BEFORE-BUFFER:NAME).
  
  lSuccess = DYNAMIC-FUNCTION('deleteRow':U IN hDatasetSource,
                              cDataTable, 
                              ckeyWhere).

  IF lSuccess AND lAutoCommit AND NOT lNewDeleted THEN 
  DO: 
    lSuccess = {fn submitData}.
    /* If there were no errors, delete the RowObject copy of the row. */
  END.  /* END DO IF AutoCommit */
  
  /* If the delete was successful, publish the event (for browse), 
     and figure out the new position and set properties accordingly */
  IF lSuccess THEN
  DO:
    /* This will result in a delete-current-row in the browser, which will
       make the prev or first record available.  */
    PUBLISH 'deleteComplete':U FROM TARGET-PROCEDURE. /* Tell Browser, e.g */
 
    /* If new deleted or not browsed then it will not become available 
       on the deletecomplete */      
    IF NOT hRowObject:AVAILABLE THEN
       hDataQuery:GET-NEXT.
    IF NOT hRowObject:AVAIL THEN
      hDataQuery:GET-PREV.

    /* If we deleted the first then this must now be the first record */
    IF hRowObject:AVAIL THEN
    DO:
      IF cQueryPos = 'FirstRecord':U THEN
        {set FirstRowNum INT(hRowObject:RECID)}.        
       /* If we deleted the last then this must now be the last record */
      IF cQueryPos = 'LastRecord':U THEN
        {set LastRowNum INT(hRowObject:RECID)}.              
    END.
    /* Last record deleted */
    ELSE DO:

      &SCOPED-DEFINE xp-assign
      {set FirstRowNum 0}        
      {set LastRowNum 0}
      .
      &UNDEFINE xp-assign
      
    END.

    /* If there is a Commit-Source, signal that a row has been changed. */
    IF NOT lAutoCommit THEN 
    DO:           
      cRowObjectState = 'RowUpdated':U.
      IF lNewDeleted THEN
      DO:
        /* If the new deleted was the only uncommitted change then
           set RowObjectState to 'NoUpdates' */
        hRowObject:BEFORE-BUFFER:FIND-FIRST() NO-ERROR.
        IF NOT hRowObject:BEFORE-BUFFER:AVAIL THEN 
           cRowObjectState = 'NoUpdates':U.
      END.
      PUBLISH "updateState":U FROM TARGET-PROCEDURE('delete':U).
      {set RowObjectState cRowObjectState}.
      lNextNeeded = FALSE. /* we don't need another batch (IZ 10746) */
    END.
    /* NextNeeded = false if the browse 'autopositioned', also if we deleted 
       the only or last record don't try to fetch another batch. */
    IF lNextNeeded AND {fnarg rowAvailable 'NEXT':U} AND NOT lNewDeleted THEN
      RUN fetchNext IN TARGET-PROCEDURE.
    ELSE 
      RUN rowChanged IN TARGET-PROCEDURE('different':U).   
  END.  /* IF Success  */
  ELSE DO:
    cDeleteMsg = {fnarg messageNumber 23}.
    RUN addMessage IN TARGET-PROCEDURE (cDeleteMsg,?,{fn getDataTable}).
    /* newdeleted can only be stopped at the actual delete */
    IF NOT lNewDeleted THEN
    DO:
      hRowObject:BEFORE-BUFFER:FIND-UNIQUE('WHERE ':U + cBIKeyWhere).
      DO TRANSACTION:
        hRowObject:BEFORE-BUFFER:REJECT-ROW-CHANGES.
      END.
      /* the record was deleted and the reincarnation must be added to the query */
      {fnarg  openDataQuery "'WHERE ':U + cKeyWhere"}.
      /* rowid has changed..currently used by visual objects
         possibly also new data from server */
      RUN rowChanged IN TARGET-PROCEDURE('RESET':U).   
    END.
  END.
  RETURN lSuccess.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-destroyView) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION destroyView Procedure 
FUNCTION destroyView RETURNS LOGICAL
  ( /* parameter-definitions */ ) :
/*------------------------------------------------------------------------------
  Purpose: Destroy the table definitions
    Notes: Separated out of destroyObject for design time re-creation             
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hDatasetSource   AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hContainerSource AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hQuery           AS HANDLE     NO-UNDO.
  DEFINE VARIABLE iTable           AS INTEGER    NO-UNDO.
  DEFINE VARIABLE hBuffer          AS HANDLE     NO-UNDO.

  &SCOPED-DEFINE xp-assign
  
  {get DatasetSource hDatasetSource}
  {get ContainerSource hContainerSource}
  {get DataHandle hQuery}

  {set DataColumns '':U}
  {set UpdatableColumns '':U}
  {set DatasetSource ?}
  {set RowObject ?}
  {set QueryString '':U}
  {set QueryColumns '':U}
  {set DataQueryString '':U}
  {set Tables '':U}
  /* destroy and reinitialize is not really supported, but not prevented */
  {set ObjectInitialized FALSE}
  .
  &UNDEFINE xp-assign

  IF VALID-HANDLE(hQuery) THEN
  DO iTable = 1 TO hQuery:NUM-BUFFERS:
    hBuffer = hQuery:GET-BUFFER-HANDLE(iTable).
    {fnarg destroyBuffer hBuffer hDatasetSource}.
  END.

  DELETE OBJECT hQuery NO-ERROR.
 
  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-findRow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION findRow Procedure 
FUNCTION findRow RETURNS LOGICAL
  (pcKeyValues AS CHAR) :
/*------------------------------------------------------------------------------
  Purpose: Find and reposition to a row using the key.
Parameter: pcKeyFields - Comma or chr(1) separated list of keyfields. 
    Notes:  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cKeyFields AS CHAR   NO-UNDO.
  
  {get KeyFields cKeyFields}.
  
  /* If comma separated list replace with chr(1) */  
  IF NUM-ENTRIES(cKeyFields) > 1 AND INDEX(pcKeyValues,CHR(1)) = 0 THEN 
     pcKeyValues = REPLACE(pcKeyValues,",":U,CHR(1)).

  RETURN DYNAMIC-FUNCTION('findRowWhere':U IN TARGET-PROCEDURE, 
                          cKeyFields,
                          pcKeyValues,
                          "=":U). 
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-findRowObjectUseRowIdent) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION findRowObjectUseRowIdent Procedure 
FUNCTION findRowObjectUseRowIdent RETURNS LOGICAL
  ( INPUT pcRowIdent AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:  Repositions the query to the desired row, based on the corresponding
            record rowid (specified by pcRowIdent). If that row is found in the
            DataTable, it repositions the query to that row.

  Parameters:
              INPUT pcRowIdent   - string rowid of the DataTable temp-table.

  Notes:  Does not publish the change and will typically not work very well as
          an external separate command to position a DataView. (Use findRow or
          findRowWhere for repositioning)   

      -   ROWIDs are reused so there is also a risk of finding wrong data if
          used incorrectly, for example after a failed delete.
      -   This API exists to allow visual objects that used this to reposition
          SDOs to work against DataViews. 
      -   The Dataviews RowIdent is currently a string of the temp-table ROWID,
          so there is no difference between this and repositionRowObject.
          (The two functions are different in SDOs)   
------------------------------------------------------------------------------*/
  {fnarg repositionRowObject pcRowIdent}.
  RETURN TRUE.   /* Function return value. */

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-findRowObjectWhere) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION findRowObjectWhere Procedure 
FUNCTION findRowObjectWhere RETURNS LOGICAL
  (pcColumns     AS CHARACTER,   
   pcValues      AS CHARACTER,    
   pcOperators   AS CHARACTER,
   pcMode        AS CHARACTER):
/*------------------------------------------------------------------------------   
     Purpose: Find a record in the current Rowobject table
  Parameters: 
       pcColumns   - Qualified column names (Comma separated)                    
       pcValues    - corresponding Values (CHR(1) separated)
       pcOperators - Operator - one for all columns
                                - blank - defaults to (EQ)  
                                - Use slash to define alternative string operator
                                  EQ/BEGINS etc..
                              - comma separated for each column/value
         pcMode     - FIRST
                    - LAST  (reserved for future, not yet supported)      
     Notes: Returns ? if batching properties combined with seach criteria
            cannot be resolved on the client                          
---------------------------------------------------------------------------*/
 DEFINE VARIABLE iColumn        AS INTEGER    NO-UNDO.
 DEFINE VARIABLE cColumn        AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE cOperator      AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE cValue         AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE cWhere         AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE cQueryString   AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE lOk            AS LOGICAL    NO-UNDO.
 DEFINE VARIABLE hRowObject     AS HANDLE     NO-UNDO.
 DEFINE VARIABLE hDataQuery     AS HANDLE     NO-UNDO.
 DEFINE VARIABLE rRowid         AS ROWID      NO-UNDO.
 DEFINE VARIABLE iFirstRowNum   AS INTEGER    NO-UNDO.
 DEFINE VARIABLE iLastRowNum    AS INTEGER    NO-UNDO.
 DEFINE VARIABLE cEqualColumns  AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE lDefinite      AS LOGICAL    NO-UNDO.
 DEFINE VARIABLE rCurrent       AS ROWID      NO-UNDO.
 DEFINE VARIABLE cDataTable     AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE iBuffer        AS INTEGER    NO-UNDO.
 DEFINE VARIABLE hBuffer        AS HANDLE     NO-UNDO.
 DEFINE VARIABLE hDatasetSource AS HANDLE     NO-UNDO.
 DEFINE VARIABLE cRowids        AS CHARACTER  NO-UNDO.

 {get DataHandle hDataQuery}.

 IF NOT VALID-HANDLE(hDataQuery) THEN
   RETURN ?.
 ELSE IF hDataQuery:IS-OPEN = FALSE THEN
   RETURN ?.
 
 IF pcColumns = '':U OR pcColumns = ? THEN
   RETURN NO.

 &SCOPED-DEFINE xp-assign  
 {get FirstRowNum iFirstRowNum}
 {get LastRowNum iLastRowNum}
 {get DataTable cDataTable}
 .
 &UNDEFINE xp-assign
  
 IF pcMode <> 'FIRST':U THEN
 DO:
   MESSAGE 
      SUBSTITUTE({fnarg messageNumber 58}, "findRowObjectWhere()", pcMode) SKIP       
      VIEW-AS ALERT-BOX ERROR.

   RETURN ?.
 END.

 /* This loop is just to identify the operators 
    (The pcoperators parameter supports some weird cases...) */
 DO iColumn = 1 TO NUM-ENTRIES(pcColumns):   
   RUN obtainExpressionEntries IN TARGET-PROCEDURE
         (cDataTable,
          iColumn,
          pcColumns,
          pcValues,
          pcOperators,
          OUTPUT cColumn, 
          OUTPUT cOperator,
          OUTPUT cValue). 
   
   IF cColumn > '':U AND cColumn BEGINS cDataTable + '.':U THEN
   DO:
     /* Build a list of the columns that has equality operators to check
        against the index information to decide whether the request can be 
        resolved on the client. */ 
     IF CAN-DO('=,EQ':U,cOperator) THEN 
       cEqualColumns = cEqualColumns
                     + (IF cEqualcolumns = '' THEN '' ELSE ',')
                     + cColumn.
   END. /* cColumn > '' */
 END. /* pcColumn loop */

 /* The request cannot be resolved on the client, if the first record of the 
    current query is not here and no equality match is used */ 
 IF iFirstRowNum = ? AND cEqualColumns = '':U THEN
   RETURN ?.
 
 {get QueryString cQueryString}.
 
 cQueryString = DYNAMIC-FUNCTION('newQueryString':U IN TARGET-PROCEDURE,
                                  pcColumns,
                                  pcValues,
                                  pcOperators,
                                  cQueryString,
                                  'AND':U). 
 {get RowObject hRowObject}.
 rCurrent = hRowObject:ROWID.
 /** pcMode = 'last' is not supported, returned with error message above */ 
 cRowids = {fnarg firstRowids cQueryString}. 

 lOk = (cRowids <> ?).
 
 /* if we have first and last or found something then the answer is definite */
 IF iFirstRownum <> ? AND (lOk OR iLastRowNum <> ?) THEN
   lDefinite = TRUE.
 /* else if we have found something with equality match then we have 
    a definite answer if a unique index is used 
    (the check for equalcolumns blank and unknown first is already done, so
     could be avoided here) */    
 ELSE IF lOk AND cEqualColumns > '' THEN
 DO:
   {get DatasetSource hDatasetSource}.
   lDefinite = DYNAMIC-FUNCTION('isUniqueId':U IN hDatasetSource,
                                cEqualColumns,cDataTable). 
 END. /* else (record was found, but columns need to be checked against index)*/

 /* If the request can be resolved on the client and we have a record then
    position the sdo's query to it */ 
 IF lDefinite AND lOk THEN 
 DO:
   /* the datatable is unique so we only need the first rowid if joined */
   rRowId = TO-ROWID(ENTRY(1,cRowids)).
   lOK = hDataQuery:REPOSITION-TO-ROWID(rRowid) NO-ERROR.  
   /* Repos only makes rec avail if browsed  */
   IF lOK AND NOT hRowObject:AVAIL THEN    
     hDataQuery:GET-NEXT().  
 END.
 ELSE  /* keep current record avail if not found */ 
   hRowObject:FIND-BY-ROWID(rCurrent) NO-ERROR.
 
 /* If definite then return yes or no (found or not) otherwise returm ?   */
 RETURN IF lDefinite THEN lOK ELSE ?. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-findRowWhere) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION findRowWhere Procedure 
FUNCTION findRowWhere RETURNS LOGICAL
  (pcColumns     AS CHARACTER,   
   pcValues      AS CHARACTER,    
   pcOperators   AS CHARACTER):
/*------------------------------------------------------------------------------   
Purpose: Find and reposition to a row 
Parameters: 
       pcColumns   - Qualified column names (Comma separated)                    
       pcValues    - corresponding Values (CHR(1) separated)
       pcOperators - Operator - one for all columns
                                - blank - defaults to (EQ)  
                                - Use slash to define alternative string operator
                                  EQ/BEGINS etc..
                              - comma separated for each column/value                                                     
---------------------------------------------------------------------------*/
  DEFINE VARIABLE cColumn          AS CHAR       NO-UNDO.
  DEFINE VARIABLE lOnClient        AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cQueryString     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hDataReadHandler AS HANDLE     NO-UNDO.
  DEFINE VARIABLE lQueryOpen       AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lParentOpen      AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lBrowsed         AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cTable           AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE iTable           AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cSortTables      AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cTableWhere      AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cPosition        AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hDataSource      AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cDatasetName     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cRowid           AS CHARACTER  NO-UNDO.
  
  IF {fn getScrollable} = FALSE THEN
  DO:
    {get DataQueryBrowsed lBrowsed}.
    IF NOT lBrowsed THEN
      RETURN DYNAMIC-FUNCTION('findUniqueRowWhere':U IN TARGET-PROCEDURE,
                               pcColumns,
                               pcValues,
                               pcOperators).  
    
  END.
  
  /* Don't search onclient if QueryOpen is false */   
  {get QueryOpen lQueryOpen}.
  /* if query is open check if the record already is on the client
    (Returns unknown if the request cannot be resolved on client) 
     No =  enough info to know record does not exist ) */
  
  lOnClient = ?. 
  IF lQueryOpen THEN 
    lOnCLient = DYNAMIC-FUNCTION('findRowObjectWhere':U IN TARGET-PROCEDURE,
                                  pcColumns,
                                  pcValues,
                                  pcOperators,
                                  'First':U).  
  /* ? means cannot be resolved on client */ 
  IF lOnClient = ? THEN
  DO:
    /* Add find criteria to default query as we don't want/need to include 
       querystring in server position request */
    cQueryString = DYNAMIC-FUNCTION('newQueryString':U IN TARGET-PROCEDURE,
                                     pcColumns,
                                     pcValues,
                                     pcOperators,
                                     {fn getQueryStringDefault},
                                     ?).
    {get QueryTables cSortTables}.

    /* remove sort criteria and secondary tables if not searched */ 
    DO iTable = 1 TO NUM-ENTRIES(cSortTables):
      cTable = ENTRY(iTable,cSortTables).
      /* Only pass secondary tables if explicitly in the query expression  */
      IF iTable = 1 
      OR INDEX(',':U + pcColumns,',':U + cTable + '.':U) > 0 THEN
        ASSIGN 
          cPosition = cPosition 
                    + (IF iTable = 1 THEN '':U ELSE ',':U)
                    + DYNAMIC-FUNCTION('bufferWhereClause':U IN TARGET-PROCEDURE,
                                        cTable,
                                        cQueryString).
    END. /* DO iTable = 1 TO NUM-ENTRIES(cSortTables) */

    cPosition = SUBSTRING(cPosition,INDEX(cPosition,' WHERE ':U) + 1).
    
    DYNAMIC-FUNCTION('retrieveData':U IN TARGET-PROCEDURE,
                      cPosition,
                      NOT lQueryOpen, /* don't refresh if open */
                      ?).

    ASSIGN 
      /* Get the current query + find criteria 
         The QueryString we had from above is not sufficient in all cases as 
         we need the sort to be correct and also include the foreign 
         key to be sure to not find wrong record. (Even if a child 
         request should not be issued to server when DataIsFetched is true,
         could also be a problem if the server returned too much data for 
         some reason) */
      cQueryString = DYNAMIC-FUNCTION('newQueryString':U IN TARGET-PROCEDURE,
                                         pcColumns,
                                         pcValues,
                                         pcOperators,
                                         ?, /* default= querystring */
                                         ?)   
           
      /*  first rowid is sufficent for position as DataTable is unique*/
      cRowid = ENTRY(1,{fnarg firstRowids cQueryString}).
      
    IF cRowid <> ? THEN
      lOnClient = {fnarg openDataQuery cRowid}.
    
    {get DataQueryBrowsed lBrowsed}.
    IF lBrowsed THEN
      PUBLISH 'fetchDataSet':U FROM TARGET-PROCEDURE ('BatchEnd':U).
      
  END. /* lOnClient = ? */
  
  /* Signal change also when find failed, as foreignvalues of children 
     has been set to unknown in buildDatarequest and need to be reset.
     (mainly because dataAvailable uses unknwon as fetchedbyparent signal) */  
  RUN rowChanged IN TARGET-PROCEDURE ('RESET':U).

  RETURN IF lOnCLient THEN TRUE ELSE FALSE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-findUniqueRowWhere) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION findUniqueRowWhere Procedure 
FUNCTION findUniqueRowWhere RETURNS LOGICAL
  (pcColumns     AS CHARACTER,   
   pcValues      AS CHARACTER,    
   pcOperators   AS CHARACTER):
/*------------------------------------------------------------------------------   
Purpose: Find and reposition to a row in the client DataTable  
Parameters: 
       pcColumns   - DataTable column names (Comma separated)                    
       pcValues    - corresponding Values (CHR(1) separated)
       pcOperators - Operator - one for all columns
                                - blank - defaults to (EQ)  
                                - Use slash to define alternative string operator
                                  EQ/BEGINS etc..
                              - comma separated for each column/value
 Notes:  Intended for non scrollable DataViews. 
       - Called from findRowwhere when not scrollable. 
       - Does not call service.                                               
---------------------------------------------------------------------------*/
 DEFINE VARIABLE cColumn    AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE cOperator  AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE iColumn    AS INTEGER    NO-UNDO.
 DEFINE VARIABLE cDataTable AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE cValue     AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE cWhere     AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE hRowObject AS HANDLE     NO-UNDO.
 DEFINE VARIABLE lFound     AS LOGICAL    NO-UNDO.

 &SCOPED-DEFINE xp-assign
 {get DataTable cDataTable}
 {get RowObject hRowObject}
   .
 &UNDEFINE xp-assign

 IF NOT VALID-HANDLE(hRowObject) THEN
   RETURN FALSE.

 DO iColumn = 1 TO NUM-ENTRIES(pcColumns):             
   /* get the column, operator and correctly quoted value from the lists 
     if it maps to the DataTable. */  
   RUN obtainExpressionEntries IN TARGET-PROCEDURE
                         (cDataTable,
                          iColumn,
                          pcColumns,
                          pcValues,
                          pcOperators,
                          OUTPUT cColumn, 
                          OUTPUT cOperator,
                          OUTPUT cValue).
   IF cColumn = '':U THEN
   DO:
     MESSAGE 
       "Invalid column reference '" + entry(iColumn,pcColumns) + "'passed to findUniqueRowWhere().".
     RETURN FALSE.
   END.
       
   cWhere = cWhere 
          + (IF cWhere = "":U THEN "WHERE ":U ELSE " AND ":U)
          + cColumn 
          + " ":U
          + cOperator
          + " ":U
          + cValue.
 END. /* do iColumn = 1 to num-entries(pColumns) */        

 lFound = hRowObject:FIND-UNIQUE(cWhere) NO-ERROR.
 RUN rowChanged IN TARGET-PROCEDURE('RESET':U).

 RETURN lFound.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-firstRowids) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION firstRowids Procedure 
FUNCTION firstRowids RETURNS CHARACTER
  (pcQueryString AS CHARACTER ) :
/*------------------------------------------------------------------------------
   Purpose:   Returns the ROWID (converted to a character string) of the first 
              query row satisfying the passed query prepare string.   
Parameters:
    pcWhere - A complete query where clause that matches the database query's 
              buffers.
     Notes:   Used by data class rowidwhere.
              Dataview findRowobjectwhere and findRowWhere  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hQuery      AS HANDLE    NO-UNDO.
  DEFINE VARIABLE hBuffer     AS HANDLE    NO-UNDO.
  DEFINE VARIABLE cBuffer     AS CHAR      NO-UNDO.
  DEFINE VARIABLE cBufferList AS CHAR      NO-UNDO.
  DEFINE VARIABLE hRowQuery   AS HANDLE    NO-UNDO.
  DEFINE VARIABLE lOK         AS LOGICAL   NO-UNDO.
  DEFINE VARIABLE i           AS INTEGER   NO-UNDO.
    
  DEFINE VARIABLE cRowIds    AS CHARACTER NO-UNDO.
  
  {get QueryHandle hQuery}.
    
  CREATE QUERY hRowQuery.     /* Get a query to do the "FIND" */
  
  /* Create buffers and add to the query. 
     we must create buffers to avoid conflict with the original query
     in case it's PRESELECT (non-indexed sort) */
  DO i = 1 TO hQuery:NUM-BUFFERS:
    ASSIGN
      hBuffer = hQuery:GET-BUFFER-HANDLE(i)
      cBuffer = hBuffer:NAME.
       
    CREATE BUFFER hBuffer FOR TABLE hBuffer BUFFER-NAME cBuffer.
    hRowQuery:ADD-BUFFER(hBuffer).
    cBufferList = cBufferList 
                  + (IF i = 1 THEN '':U ELSE ',':U)
                  + STRING(hBuffer). 
  END.  /* do i = 1 to */

  lOK = hRowQuery:QUERY-PREPARE(pcQueryString) NO-ERROR.
      
  IF lOK THEN lOK = hRowQuery:QUERY-OPEN().
  IF lOK THEN lOK = hRowQuery:GET-FIRST().
    
  /* Get the rowids and delete the temporary buffers */
  DO i = 1 TO NUM-ENTRIES(cBufferList):
    ASSIGN
      hBuffer = WIDGET-HANDLE(ENTRY(i,cBufferList))
      cRowids = cRowids 
              + (IF i = 1 THEN "":U ELSE ",":U)
              + (IF lOk AND hBuffer:AVAILABLE 
                 THEN STRING(hBuffer:ROWID)
                 ELSE '':U).
    DELETE OBJECT hBuffer.
  END. /* do i = 1 to hRowQuery:num-buffers */ 
  DELETE OBJECT hRowQuery.  
    
  RETURN IF lOk THEN cRowids ELSE ?.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getAuditEnabled) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getAuditEnabled Procedure 
FUNCTION getAuditEnabled RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: Indicates whether auditing is enabled. 
           Used in Audit Action EnableRules to enable the Audit action in a 
           toolbar.
    Notes:  (Hardcoded to FALSE in DataView as they don't have default support
             for Auditing)    
------------------------------------------------------------------------------*/

  RETURN FALSE.   

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getAutoCommit) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getAutoCommit Procedure 
FUNCTION getAutoCommit RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:  Returns a flag indicating whether a Commit happens on every 
            Record update.
   Params:  <none>
   Notes:
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hSource         AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hDatasetSource1 AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hDatasetSource2 AS HANDLE     NO-UNDO.
  DEFINE VARIABLE lAuto           AS LOGICAL    NO-UNDO.

  &SCOPED-DEFINE xpAutoCommit
  {get AutoCommit lAuto}.
  &UNDEFINE xpAutoCommit
  
  IF lAuto THEN
  DO:
    &SCOPED-DEFINE xp-assign
    {get DataSource hSource}
    {get DatasetSource hDatasetSource1}.
     .
    &UNDEFINE xp-assign
    
    IF VALID-HANDLE(hSource) THEN 
    DO:
      /* datasetsource no-error, in case "wrong" type datasource */ 
      {get DatasetSource hDatasetSource2 hSource} NO-ERROR.
      IF hDatasetsource1 = hDatasetsource2 THEN
        RETURN {fn getAutoCommit hSource}.
    END.
  END.
  RETURN lAuto.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getBLOBColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getBLOBColumns Procedure 
FUNCTION getBLOBColumns RETURNS CHARACTER
  ( ) :
/*------------------------------------------------------------------------------
    Purpose:  Returns a comma-delimited list of the BLOB data-type 
              columnNames for the SmartDataObject. 
  Parameters:  
       Notes: This is a runtime property that on the first call will
              be resolved from DataColumns and RowObject definition. 
           -  Very expensive if requested before the first data request as
              it then may resolve each column's data-type on the server.
             (This should not be necessary though)   
           -  read-only  (no SET is implemented)    
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cBLOBColumns AS CHARACTER  NO-UNDO.

  &SCOPED-DEFINE xpBLOBColumns
  {get BLOBColumns cBLOBColumns}.
  &UNDEFINE xpBLOBColumns
  
  /* if unknown then resolve this from rowobject and datacolumn data-types */
  IF cBLOBColumns = ? THEN
  DO:
    {fn updateLargeColumns}.
    
    &SCOPED-DEFINE xpBLOBColumns
    {get BLOBColumns cBLOBColumns}.
    &UNDEFINE xpBLOBColumns
    
  END.

  RETURN cBLOBColumns.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getBufferHandles) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getBufferHandles Procedure 
FUNCTION getBufferHandles RETURNS CHARACTER
  ( /* parameter-definitions */ ) :
/*------------------------------------------------------------------------------
  Purpose:  
    Notes:  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cBufferHandles AS CHARACTER  NO-UNDO.
                     
  &SCOPED-DEFINE xpBufferHandles 
  {get BufferHandles cBufferHandles}.
  &UNDEFINE xpbufferHandles 
  
  RETURN cBufferHandles.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getBusinessEntity) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getBusinessEntity Procedure 
FUNCTION getBusinessEntity RETURNS CHARACTER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: The Business Entity that provides data to and accepts data from 
           the DataView.  
    Notes: This is a logical name that identifies the Busines Entity in the 
           Service. The actual realization of the Business Entity is the 
           responsibility of the Service and is irrelevant for the ADM. 
           It is, however, expected that the Service Adapter who handles 
           all ADM requests to the service is using a prodataset as the 
           data transport medium.    
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cBusinessEntity AS CHARACTER  NO-UNDO.
  {get BusinessEntity cBusinessEntity}.
  RETURN cBusinessEntity. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getCLOBColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getCLOBColumns Procedure 
FUNCTION getCLOBColumns RETURNS CHARACTER
  ( ) :
/*------------------------------------------------------------------------------
    Purpose:  Returns a comma-delimited list of the CLOB data-type 
              columnNames for the SmartDataObject. 
  Parameters:  
       Notes: This is a runtime property that on the first call will
              be resolved from DataColumns and RowObject definition. 
           -  Very expensive if requested before the first data request as
              it then may resolve each column's data-type on the server.
             (This should not be necessary though)     
          -  read-only  (no SET is implemented)    
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cCLOBColumns AS CHARACTER  NO-UNDO.

  &SCOPED-DEFINE xpCLOBColumns
  {get CLOBColumns cCLOBColumns}.
  &UNDEFINE xpCLOBColumns
  
  /* if unknown then resolve this from rowobject and datacolumn data-types */
  IF cCLOBColumns = ? THEN
  DO:
    {fn updateLargeColumns}.
    
    &SCOPED-DEFINE xpCLOBColumns
    {get CLOBColumns cCLOBColumns}.
    &UNDEFINE xpCLOBColumns
    
  END.

  RETURN cCLOBColumns.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getCommitSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getCommitSource Procedure 
FUNCTION getCommitSource RETURNS HANDLE
  ( ) :
/*------------------------------------------------------------------------------
  Purpose:  Returns the handle of the object's CommitSource.
   Params:  <none>
------------------------------------------------------------------------------*/

  DEFINE VARIABLE hSource AS HANDLE NO-UNDO.
  {get CommitSource hSource}.
  RETURN hSource.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getCommitSourceEvents) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getCommitSourceEvents Procedure 
FUNCTION getCommitSourceEvents RETURNS CHARACTER
(  ) :
/*------------------------------------------------------------------------------
  Purpose:  Returns the list of events this object subscribes to in its
            Commit-Source
   Params:  <none>
------------------------------------------------------------------------------*/

  DEFINE VARIABLE cEvents AS CHARACTER NO-UNDO.
  {get CommitSourceEvents cEvents}.
  RETURN cEvents.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getCommitTarget) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getCommitTarget Procedure 
FUNCTION getCommitTarget RETURNS CHARACTER
  ( ) :
/*------------------------------------------------------------------------------
  Purpose:  Returns the handle of the object's CommitTarget, in character form.
   Params:  <none>
------------------------------------------------------------------------------*/

  DEFINE VARIABLE cTarget AS CHARACTER NO-UNDO.
  {get CommitTarget cTarget}.
  RETURN cTarget.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getCommitTargetEvents) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getCommitTargetEvents Procedure 
FUNCTION getCommitTargetEvents RETURNS CHARACTER
(  ) :
/*------------------------------------------------------------------------------
  Purpose:  Returns the list of events this object subscribes to in its
            Commit-Target
   Params:  <none>
------------------------------------------------------------------------------*/

  DEFINE VARIABLE cEvents AS CHARACTER NO-UNDO.
  {get CommitTargetEvents cEvents}.
  RETURN cEvents.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getCurrentUpdateSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getCurrentUpdateSource Procedure 
FUNCTION getCurrentUpdateSource RETURNS HANDLE
(  ) :
/*------------------------------------------------------------------------------
  Purpose:  Returns the current updateSource 
    Notes:  This is just set temporarily in updateState before re-publishing 
            updateState, so that the updateSource/DataTarget can avoid a 
            republish when it is the original publisher.
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hSource AS HANDLE NO-UNDO.
  {get CurrentUpdateSource hSource}.
  RETURN hSource.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getDataColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getDataColumns Procedure 
FUNCTION getDataColumns RETURNS CHARACTER
  ( ) :
/*------------------------------------------------------------------------------
  Purpose:     Returns a comma-delimited list of the columnNames for the 
               SmartDataObject. 
  Parameters:  
       Notes:   
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cColumns AS CHARACTER NO-UNDO.
  
  {get DataColumns cColumns}.
  RETURN cColumns.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getDataContainerHandle) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getDataContainerHandle Procedure 
FUNCTION getDataContainerHandle RETURNS HANDLE
  ( ) :
/*------------------------------------------------------------------------------
  Purpose: Returns the datacontainer that handles all data requests.  
    Notes:  
------------------------------------------------------------------------------*/
  IF NOT VALID-HANDLE(ghDataContainer) THEN
     ghDataContainer = {fnarg getManagerHandle 'DataContainer':U}.

  RETURN ghDataContainer.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getDataHandle) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getDataHandle Procedure 
FUNCTION getDataHandle RETURNS HANDLE
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:  Returns the handle to the temp-table query
   Params:  <none>
------------------------------------------------------------------------------*/

  DEFINE VARIABLE hData AS HANDLE NO-UNDO.
  {get DataHandle hData}.
  RETURN hData.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getDataIsFetched) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getDataIsFetched Procedure 
FUNCTION getDataIsFetched RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
   Purpose: Tells whether data for the query already is fetched
     This class: Used to manage prodataset children,
                 ?    -  default, set to true or false when data is retrieved.    
                 True -  used for a child's prodataset default retrieval, which
                         includes all children for all parents, which means that 
                         it never is necessary to request data from the server
                         for the child.
                 False - used on a child that only has data for one parent.
                         Set to false to override default prodataset retrieval.
     Query class: Default to no ( static sdo in initProps)
            The SBO sets this to true in the SDO when it has fethed 
            data on the SDOs behalf in order to prevent that the SDO does 
            another server call to fetch the data it already has. 
            This is checked in query.p dataAvailable and openQuery is skipped
            if its true. It's immediately turned off after it is checked.    
    Notes: Duplicated in sboext 
Note Date: 2005/10/1    
------------------------------------------------------------------------------*/
  DEFINE VARIABLE lFetched AS LOGICAL    NO-UNDO.
  {get DataIsFetched lFetched}.

  RETURN lFetched.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getDataModified) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getDataModified Procedure 
FUNCTION getDataModified RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:     Returns TRUE if the current RowObject record is BEING modified, 
  Parameters:  <none>  
  Notes:       We check updateTargets since this may be called from 
               the toolbar as a result of the updateSource's  
               setDataModifed -> publish updateState, BEFORE the updateState
               reaches us...                       
------------------------------------------------------------------------------*/
  DEFINE VARIABLE lDataModified AS LOGICAL   NO-UNDO.
  DEFINE VARIABLE cUpdateSource AS CHAR      NO-UNDO.
  DEFINE VARIABLE iSource       AS INTEGER   NO-UNDO.
  DEFINE VARIABLE hSource       AS HANDLE    NO-UNDO.

  {get UpdateSource cUpdateSource}.
  DO iSource = 1 TO NUM-ENTRIES(cUpdateSource):
    hSource = WIDGET-HANDLE(ENTRY(iSource,cUpdateSource)).
    IF VALID-HANDLE(hSource) THEN 
    DO:
      {get DataModified lDataModified hSource}.
      IF lDataModified THEN
        LEAVE.
    END.
  END.

  RETURN lDataModified.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getDataQueryBrowsed) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getDataQueryBrowsed Procedure 
FUNCTION getDataQueryBrowsed RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:      Returns TRUE if this SmartDataObject's Query is being browsed 
                by a SmartDataBrowser.
  
  Parameters:  <none>
  Notes:        This is used to prevent two SmartDataBrowsers from attempting 
                to browse the same query, which is not allowed.
------------------------------------------------------------------------------*/

  DEFINE VARIABLE lBrowsed AS LOGICAL NO-UNDO.

  &SCOPED-DEFINE xpDataQueryBrowsed
  {get DataQueryBrowsed lBrowsed}.
  &UNDEFINE xpDataQueryBrowsed
 
  RETURN lBrowsed.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getDataQueryString) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getDataQueryString Procedure 
FUNCTION getDataQueryString RETURNS CHARACTER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:  Returns a string used to prepare the RowObject query  
    Notes:  This class treats this as a private property to store an
            override of default query from all default querytables.
          - Should only be accessed at runtime by other get functions.
            - getQueryStringDefault - first option 
            - getQueryTables        - second option after a valid query handle
          - Is intended to define and store base tables, join expressions and 
            sort and not for other query expressions, sinced a DataView  in
            principle has access to all records in the business entity. 
            The QueryString is used at runtime and can be manipulated with
            assignQueryString in initializeObject for filtering at start up.                                 
         Data class (does not have override, but has different use ) 
          - Used directly in the query for the RowObject. Typically not
            a design time property. 
          - Is manipulated for local sort, but currently not filtered. 
------------------------------------------------------------------------------*/  
  DEFINE VARIABLE cQueryString AS CHARACTER NO-UNDO.
  {get DataQueryString cQueryString}.
  RETURN cQueryString.    

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getDatasetName) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getDatasetName Procedure 
FUNCTION getDatasetName RETURNS CHARACTER
  ( ) :
/*------------------------------------------------------------------------------
  Purpose:  Get the instance name of the object's DatasetSource.
   Params:  <none>
------------------------------------------------------------------------------*/

  DEFINE VARIABLE cName AS CHARACTER NO-UNDO.
  {get DatasetName cName}.
  RETURN cName.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getDatasetSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getDatasetSource Procedure 
FUNCTION getDatasetSource RETURNS HANDLE
  ( ) :
/*------------------------------------------------------------------------------
  Purpose: Returns the handle of the object's DatasetSource.
   Params:  <none>
    Notes: The DatasetSource is a procedure that encapsulates all access
           to the prodataset that holds the data for the DataView. 
         - There is currently no Dataset link, but the name -source is used 
           intentionally in the anticipation of a true link.     
------------------------------------------------------------------------------*/

  DEFINE VARIABLE hSource AS HANDLE NO-UNDO.
  {get DatasetSource hSource}.
  RETURN hSource.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getDataTable) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getDataTable Procedure 
FUNCTION getDataTable RETURNS CHARACTER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:  
    Notes:  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cDataTable AS CHARACTER  NO-UNDO.
  {get DataTable cDataTable}.
  RETURN cDataTable. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getFetchOnOpen) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getFetchOnOpen Procedure 
FUNCTION getFetchOnOpen RETURNS CHARACTER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: Return what/whether a fetch should occur when the db query is opened
    Notes: A blank value means don't fetch on open, any other value is just 
           being run as fetch + <property value>
             
Note Date: 2002/4/11    
           No xp defined for query class (currently also to handle default)
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cFetchOnOpen  AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cAsDivision   AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE lQueryCont    AS LOGICAL    NO-UNDO.
  
  &SCOPED-DEFINE xpFetchOnOpen 
  {get FetchOnOpen cFetchOnOpen}.
  &UNDEFINE xpFetchOnOpen 
     
  IF cFetchOnOpen = ? THEN
    cFetchOnOpen = 'First':U.
 
  RETURN cFetchOnOpen.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getFillBatchOnRepos) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getFillBatchOnRepos Procedure 
FUNCTION getFillBatchOnRepos RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:  Returns (LOGICAL) a flag indicating whether fetchRowIdent should
            retrieve enough rows to fill a batch of records when repositioning
            to the end or near the end of the dataset where an entire batch
            wouldn't be retrieved.
   Params:  <none>
------------------------------------------------------------------------------*/

  DEFINE VARIABLE lFillBatch AS LOGICAL NO-UNDO.
  {get fillBatchOnRepos lFillBatch}.
  RETURN lFillBatch.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getFilterActive) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getFilterActive Procedure 
FUNCTION getFilterActive RETURNS LOGICAL
  ( /* parameter-definitions */ ) :
/*------------------------------------------------------------------------------
  Purpose: Return whether a filter is active.  
    Notes: It may be set to true explicitly or use the Querycolumns   
------------------------------------------------------------------------------*/
  DEFINE VARIABLE lFilterActive  AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cQueryColumns  AS CHARACTER  NO-UNDO.
  
  &SCOPED-DEFINE xpFilterActive 
  {get FilterActive lFilterActive}.
  &UNDEFINE xpFilterActive 
  {get QueryColumns cQueryColumns}.
 
  RETURN lfilterActive AND cQuerycolumns <> '':U.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getFilterAvailable) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getFilterAvailable Procedure 
FUNCTION getFilterAvailable RETURNS LOGICAL
  ( /* parameter-definitions */ ) :
/*------------------------------------------------------------------------------
  Purpose: Return whether a filter is available. 
    Notes: 
------------------------------------------------------------------------------*/
  DEFINE VARIABLE lFilterAvailable  AS LOGICAL    NO-UNDO.
  
  &SCOPED-DEFINE xpFilterAvailable 
  {get FilterAvailable lFilterAvailable}.
  &UNDEFINE xpFilterAvailable 
  
  RETURN lFilterAvailable.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getFilterSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getFilterSource Procedure 
FUNCTION getFilterSource RETURNS HANDLE
  ( ) :
/*------------------------------------------------------------------------------
  Purpose:  Returns the handle of the object's FilterSource.
   Params:  <none>
------------------------------------------------------------------------------*/

  DEFINE VARIABLE hSource AS HANDLE NO-UNDO.
  {get FilterSource hSource}.
  RETURN hSource.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getFilterWindow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getFilterWindow Procedure 
FUNCTION getFilterWindow RETURNS CHARACTER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:  Returns the Partition name which this object 
            will run on, if any.
   Params:  none
------------------------------------------------------------------------------*/

  DEFINE VARIABLE cFilterWindow AS CHARACTER NO-UNDO.
  {get FilterWindow cFilterWindow}.
  RETURN cFilterWindow.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getFirstRowNum) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getFirstRowNum Procedure 
FUNCTION getFirstRowNum RETURNS INTEGER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:  Returns the temp-table row number of the first row.
   Params:  <none>
------------------------------------------------------------------------------*/

  DEFINE VARIABLE iRow AS INTEGER NO-UNDO.
  {get FirstRowNum iRow}.
  RETURN iRow.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getForeignFields) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getForeignFields Procedure 
FUNCTION getForeignFields RETURNS CHARACTER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:     Returns the property which holds the mapping of field's in 
               another DataSource to fields in this SMartDataObject's RowObject 
               temp-table, to open a dependent query.
  
  Parameters:  <none>
  
  Notes:       The property format is a comma-separated list, consisting of the
               first local db fieldname, followed by the matching source 
               temp-table field name, followed by more pairs if there is more 
               than one field to match.
------------------------------------------------------------------------------*/
DEFINE VARIABLE cFields             AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cDatasetName        AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cParentDatasetName  AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cDataTable          AS CHARACTER  NO-UNDO.
DEFINE VARIABLE hDataSource         AS HANDLE     NO-UNDO.

  &SCOPED-DEFINE xpForeignFields
  {get ForeignFields cFields}.
  &UNDEFINE xpForeignFields
  
  IF cFields = ? OR cFields = '' THEN
  DO:
    {get DataSource hDataSource}.
    IF VALID-HANDLE(hdataSource) THEN
    DO:
      &SCOPED-DEFINE xp-assign
      {get DataTable cDataTable}
      {get DataSetName cDataSetName}
      .
      &UNDEFINE xp-assign
      {get DatasetName cParentdatasetName hDataSource} NO-ERROR.
      IF cDataSetName = cParentdatasetName THEN
         cFields = {fnarg childForeignFields cDataTable hDataSource}.

    END.
    IF cFields > '':U THEN
       &SCOPED-DEFINE xpForeignFields
      {set ForeignFields cFields}.
       &UNDEFINE xpForeignFields
  END.

  RETURN cFields.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getForeignValues) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getForeignValues Procedure 
FUNCTION getForeignValues RETURNS CHARACTER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:     Retrieves the values of the most recently received ForeignField
               values received by dataAvailable.  The values are character
               strings formatted according to the field format specification and
               they are separated by the {&adm-tabledelimiter} character.

  Parameters:  <none>
  
  Notes:
------------------------------------------------------------------------------*/

  DEFINE VARIABLE cForeignValues AS CHARACTER NO-UNDO.
  {get ForeignValues cForeignValues}.
  RETURN cForeignValues.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getHasFirst) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getHasFirst Procedure 
FUNCTION getHasFirst RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: Returns true if the first record of the resultset is present  
    Notes:  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hDatasetSource AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cDataTable     AS CHARACTER  NO-UNDO.

  &SCOPED-DEFINE xp-assign
  {get DatasetSource hDatasetSource}
  {get DataTable cDataTable}.
  &UNDEFINE xp-assign

  IF VALID-HANDLE(hDatasetSource) THEN
    RETURN {fnarg tablePrevContext cDataTable hDatasetSource} = ''.

  RETURN ?.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getHasLast) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getHasLast Procedure 
FUNCTION getHasLast RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: Returns true if the last record of the resultset is present  
    Notes:  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hDatasetSource AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cDataTable     AS CHARACTER  NO-UNDO.

  &SCOPED-DEFINE xp-assign
  {get DatasetSource hDatasetSource}
  {get DataTable cDataTable}.
  &UNDEFINE xp-assign

  IF VALID-HANDLE(hDatasetSource) THEN
    RETURN {fnarg tableNextContext cDataTable hDatasetSource} = ''.

  RETURN ?.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getIndexInformation) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getIndexInformation Procedure 
FUNCTION getIndexInformation RETURNS CHARACTER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: Return indexinFormation formatted as the 4GL index-information 
           attribute, but with RowObject column names and chr(1) as index 
           separator and chr(2) as table separator.  
    Notes: - Intended for internal use by other index info functions, which uses 
             this as input to indexInformation(). 
           - Unmapped columns are returned fully qualifed!      
           - This property can be used as input parameter to indexInformation() 
             for further refinement.
           - If the property is ? it calls the indexInformation() in query.p
             and stores the returned value for future calls.              
           - If a similar list with database fields are needed use 
             indexInformation() directly (if connected)             
------------------------------------------------------------------------------*/
  /*
  &SCOPED-DEFINE xpIndexInformation
  {get IndexInformation cInfo}.
  &UNDEFINE xpIndexInformation
  */
  RETURN DYNAMIC-FUNCTION('indexInformation':U IN TARGET-PROCEDURE,
                          'Info(1)', /* info for table  */
                           NO,       /* table separator (no field qualifier) */
                           ?).      /* Use query data */
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getKeyFields) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getKeyFields Procedure 
FUNCTION getKeyFields RETURNS CHARACTER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:  Returns the comma-separated KeyFields property.
   Params:                                        
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hRowObject AS HANDLE NO-UNDO.
  {get RowObject hRowObject}.
  IF VALID-HANDLE(hRowObject) THEN
  DO:
    IF hRowObject:KEYS = 'ROWID':U THEN
      RETURN ''.

    RETURN hRowObject:KEYS.
  END.
  RETURN ?.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getKeyTableId) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getKeyTableId Procedure 
FUNCTION getKeyTableId RETURNS CHARACTER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: The KeyTableId identifies the table for runtime access to related 
           data where the table is part of the foreign key 
           (auditing and comments ).
    Notes:  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cBusinessEntity AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cDataTable      AS CHARACTER  NO-UNDO.
  
  &SCOPED-DEFINE xp-assign
  {get BusinessEntity cBusinessEntity}
  {get DataTable cDataTable}.
  &UNDEFINE xp-assign

  RETURN cBusinessEntity + '.':U + cDataTable.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getKeyWhere) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getKeyWhere Procedure 
FUNCTION getKeyWhere RETURNS CHARACTER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: Returns where string with criteria uniquely identifying current 
           record   
    Notes:  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hRowObject AS HANDLE     NO-UNDO.
  {get RowObject hRowObject}.
  IF VALID-HANDLE(hRowObject) AND hRowObject:AVAIL THEN
    RETURN DYNAMIC-FUNCTION('keyWhere':U IN TARGET-PROCEDURE,hRowObject,'':U).
  ELSE
    RETURN '':U.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getLargeColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getLargeColumns Procedure 
FUNCTION getLargeColumns RETURNS CHARACTER
  ( ) :
/*------------------------------------------------------------------------------
    Purpose:  Returns a comma-delimited list of the large data-type 
              columnNames for the SmartDataObject. 
  Parameters:  
       Notes: This is a runtime property that on the first call will
              be resolved from DataColumns and RowObject definition. 
           -  Very expensive if requested before the first data request as
              it then may resolve each column's data-type on the server.
             (This should not be necessary though)     
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cLargeColumns AS CHARACTER  NO-UNDO.

  &SCOPED-DEFINE xpLargeColumns
  {get LargeColumns cLargeColumns}.
  &UNDEFINE xpLargeColumns
  
  /* if unknown then resolve this from rowobject and datacolumn data-types */
  IF cLargeColumns = ? THEN
  DO:
    {fn updateLargeColumns}.
    
    &SCOPED-DEFINE xpLargeColumns
    {get LargeColumns cLargeColumns}.
    &UNDEFINE xpLargeColumns
    
  END.

  RETURN cLargeColumns.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getLastRowNum) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getLastRowNum Procedure 
FUNCTION getLastRowNum RETURNS INTEGER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:  Returns the temp-table row number of the last row.
   Params:  <none>
------------------------------------------------------------------------------*/

  DEFINE VARIABLE iRow AS INTEGER NO-UNDO.
  {get LastRowNum iRow}.
  RETURN iRow.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getNavigationSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getNavigationSource Procedure 
FUNCTION getNavigationSource RETURNS CHAR
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:     Returns the handle of the query object's Navigation source.
  
  Parameters:  <none>
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cSource AS CHARACTER NO-UNDO.
  {get NavigationSource cSource}.
  RETURN cSource. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getNavigationSourceEvents) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getNavigationSourceEvents Procedure 
FUNCTION getNavigationSourceEvents RETURNS CHARACTER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:     Returns a comma-separated list of the events this object 
               needs to subscribe to in its NavigationSource.
  Parameters:  <none>
------------------------------------------------------------------------------*/

  DEFINE VARIABLE cEvents AS CHARACTER NO-UNDO.
  {get NavigationSourceEvents cEvents}.
  RETURN cEvents.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getNewMode) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getNewMode Procedure 
FUNCTION getNewMode RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:     Returns TRUE if the current RowObject record is in new mode, 
               which is the same as the Object is in NewMode.   
              - (an add or a copy of an existing record has NOT been saved)                   
               Returns ? if there is no current RowObject.
  Parameters:  <none>  
  Notes:       The difference from getNewRow is that it returns true for any 
               saved and uncommitted new record and thus cannot be used
               to check whether we are in Add Mode.
               This uses the RowMod field in the Temp-Table to see if the 
               row's new (just as getNewRow) and in addition checks to see
               if the RowObjUpd is not valid or not avail, which indicates that 
               this has not been saved. 
               We do some double checking if a rowObjUpd is avail to ensure 
               that this is the right one.                 
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hRowObject  AS HANDLE     NO-UNDO.
  DEFINE VARIABLE rRowid      AS ROWID      NO-UNDO.

  {get RowObject hRowObject}.
  
  IF VALID-HANDLE(hRowObject) AND hRowObject:AVAILABLE 
  AND hRowObject:ROW-STATE = ROW-CREATED THEN
  DO:
    /* Stores current rec on add in order to repos on cancel and can 
       be used a newmode since it is set to Ox which is blank if no record 
       was avail on add and set to unknown on save and cancel  */
    {get CurrentRowid rRowid}.
    RETURN STRING(rRowid) <> ?. 
  END.

  RETURN FALSE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getNewRow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getNewRow Procedure 
FUNCTION getNewRow RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:     Returns TRUE if the current RowObject record is new - (an added
               record or a copy of an existing record has never been written to
               the database.)  Returns ? if there is no current RowObject.

  Parameters:  <none>
  
  Notes:       This uses the RowMod field in the Temp-Table to see if the 
               row's new.
------------------------------------------------------------------------------*/

  DEFINE VARIABLE hRowObject AS HANDLE NO-UNDO.
  DEFINE VARIABLE hColumn    AS HANDLE NO-UNDO.
  
  {get RowObject hRowObject}.
  IF NOT VALID-HANDLE(hRowObject) OR NOT hRowObject:AVAILABLE THEN
    RETURN FALSE.

  ELSE DO:
  RETURN hRowObject:ROW-STATE = ROW-CREATED. 
    /*
    hColumn = hRowObject:BUFFER-FIELD('RowMod':U).
    IF hColumn:BUFFER-VALUE = "A":U OR
       hColumn:BUFFER-VALUE = "C":U THEN
      RETURN TRUE.
    ELSE RETURN FALSE.
    */
  END.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getOpenOnInit) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getOpenOnInit Procedure 
FUNCTION getOpenOnInit RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:    Returns TRUE if the query should be opened automatically when 
              the object is initialized.

  Parameters: <none>
------------------------------------------------------------------------------*/
  DEFINE VARIABLE lOpen AS LOGICAL NO-UNDO.
  {get OpenOnInit lOpen}.
  RETURN lOpen.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getPositionSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getPositionSource Procedure 
FUNCTION getPositionSource RETURNS HANDLE
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: Return the DataView that positions this 
    Notes: The positioning Dataview is a child of this and the current record
           of it can uniquely identify a record in this. 
         - This is currently defined through an SDF target of this object.
           If this object has an SDF target then the viewer container's 
           datasource is indirectly the position source of this.
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hTarget         AS HANDLE     NO-UNDO.
  DEFINE VARIABLE iTarget         AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cTargetType     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cTargets        AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hContainer      AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hPositionSource AS HANDLE     NO-UNDO.

  {get DataTarget cTargets}.
  IF cTargets <> '' THEN
  DO iTarget = 1 TO NUM-ENTRIES(cTargets):
    hTarget =  WIDGET-HANDLE(ENTRY(iTarget,cTargets)).
    {get ObjectType cTargetType hTarget}.
    IF cTargetType = 'SmartDataField':U THEN
    DO:
      {get ContainerSource hContainer hTarget}.
      IF VALID-HANDLE(hContainer) THEN
        {get DataSource hPositionSource hContainer}.
      /* return in any case (invalid container or container source is an
         exception )*/
      RETURN hPositionSource.
    END. /* SDF */
  END. /* iTarget loop through cTargets */

  RETURN ?.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getPrimarySDOSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getPrimarySDOSource Procedure 
FUNCTION getPrimarySDOSource RETURNS HANDLE
  ( ) :
/*------------------------------------------------------------------------------
  Purpose:  Returns the handle of the object's PrimarySDOSource.
   Params:  <none>
------------------------------------------------------------------------------*/

  DEFINE VARIABLE hSource AS HANDLE NO-UNDO.
  {get PrimarySDOSource hSource}.
  RETURN hSource.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getPromptColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getPromptColumns Procedure 
FUNCTION getPromptColumns RETURNS CHARACTER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:  Return a list of field values when prompting for a delete action
    Notes:  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cPromptColumns AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE iCol           AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cColumn        AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cDataTable     AS CHARACTER  NO-UNDO.

  &SCOPED-DEFINE xpPromptColumns
  {get PromptColumns cPromptColumns}.
  &UNDEFINE xpPromptColumns
  IF cPromptColumns = '':U THEN
    cPromptColumns = (IF VALID-HANDLE(gshSessionManager) THEN
                       '(ALL)':U
                     ELSE
                       '(NONE)').
 
  RETURN cPromptColumns.   /* Function return value. */

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getPromptOnDelete) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getPromptOnDelete Procedure 
FUNCTION getPromptOnDelete RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:  Is the user to be prompted before a delete action executes?
    Notes:  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE lPrompt AS LOGICAL    NO-UNDO.
  {get PromptOnDelete lPrompt}.
  RETURN lPrompt.   /* Function return value. */

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getQueryColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getQueryColumns Procedure 
FUNCTION getQueryColumns RETURNS CHARACTER
  ( /* parameter-definitions */ ) :
/*------------------------------------------------------------------------------
  Purpose:  
    Notes:  
------------------------------------------------------------------------------*/
    DEFINE VARIABLE cQueryColumns AS CHARACTER NO-UNDO.
    {get QueryColumns cQueryColumns}.
    RETURN cQueryColumns.
    
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getQueryHandle) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getQueryHandle Procedure 
FUNCTION getQueryHandle RETURNS HANDLE
  ( /* parameter-definitions */ ) :
/*------------------------------------------------------------------------------
  Purpose: Interface for generic query processing  
    Notes: Used by generic query processing that originally was implemented 
           in the query class and worked on database queries and now have been 
           moved up to the dataview class to also handle temp-table and 
           prodataset queries.              
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hQuery AS HANDLE     NO-UNDO.
  {get DataHandle hQuery}.
  RETURN hQuery. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getQueryOpen) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getQueryOpen Procedure 
FUNCTION getQueryOpen RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
    Purpose:  Returns TRUE if the Query is currently open.
 Parameters:  <none>
      Notes: 
----------------------------------------------------------------------------*/    
  DEFINE VARIABLE hDataQuery  AS HANDLE     NO-UNDO.
  
  {get DataHandle hDataQuery}.
  RETURN IF NOT VALID-HANDLE(hDataQuery) 
         THEN NO 
         ELSE hDataQuery:IS-OPEN.   

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getQueryPosition) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getQueryPosition Procedure 
FUNCTION getQueryPosition RETURNS CHARACTER
  (   ) :
/*------------------------------------------------------------------------------
  Purpose:     Returns the QueryPosition property.

  Parameters:  <none>
  
  Notes:       Valid return values are:
                 FirstRecord, LastRecord, NotFirstOrLast or NoRecordAvailable
------------------------------------------------------------------------------*/

  /* The property does not have a field preprocessor to prevent it from being
     "set" directly, because it must also publish an event. So the code below
     must not use the {get} syntax. */

  DEFINE VARIABLE cPosition AS CHARACTER NO-UNDO.

  &SCOPED-DEFINE xpQueryPosition
  {get QueryPosition cPosition}.
  &UNDEFINE xpQueryPosition
  
  RETURN cPosition.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getQuerySort) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getQuerySort Procedure 
FUNCTION getQuerySort RETURNS CHARACTER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: Return the sort phrase.   
    Notes: Does NOT return the first BY keyword.  
    Data class    
           If a query is under work in the QueryString property this will 
           return this BY-phrase, otherwise it will return the BY-phrase in the 
           current or design query. 
           This should make this property safe to use in qbf objects that 
           may or may not have done query manipulation and may or may not 
           have opened the query. 
           It can also be used to retrieve the BY phrase before a setQueryWhere 
           (which overrides setQuerySort) and reset it after. 
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cQueryText AS CHAR NO-UNDO.
  DEFINE VARIABLE cSort      AS CHARACTER  NO-UNDO.
  /* If a query is under work, use that. */  
  {get QueryString cQueryText}.  
  cSort = {fnarg sortExpression cQueryText}.
  IF cSort > '':U THEN
    /* remove the first BY keyword */
    RETURN LEFT-TRIM(SUBSTR(cSort,3)).
  ELSE 
    RETURN "":U. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getQuerySortDefault) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getQuerySortDefault Procedure 
FUNCTION getQuerySortDefault RETURNS CHARACTER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: Return the default sort phrase.   
    Notes: Does NOT return the first BY keyword.  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cQuery AS CHAR NO-UNDO.
  DEFINE VARIABLE cSort  AS CHARACTER  NO-UNDO.
  /* If a query is under work, use that. */  
  {get QueryStringDefault cQuery}.  
  cSort = {fnarg sortExpression cQuery}.
  IF cSort > '':U THEN
    /* remove the first BY keyword */
    RETURN LEFT-TRIM(SUBSTR(cSort,3)).
  ELSE 
    RETURN "":U. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getQueryString) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getQueryString Procedure 
FUNCTION getQueryString RETURNS CHARACTER
  ( ) :
/*------------------------------------------------------------------------------
  Purpose:     Returns the QueryString attribute used as working storage for 
               all query manipulation methods.
  Parameters:  <none>
  Notes:     - The method will always return a whereclause 
               If the QueryString property has not been set it will use 
               the current where clause - QueryWhere.
               If there's no current use the design where clause - OpenQuery. 
             - The openQuery will call prepareQuery with this property.     
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cQueryString AS CHARACTER NO-UNDO.
  {get QueryString cQueryString}.
  RETURN cQueryString. 
  
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getQueryStringDefault) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getQueryStringDefault Procedure 
FUNCTION getQueryStringDefault RETURNS CHARACTER
  (   ) :
/*------------------------------------------------------------------------------
  Purpose: Used to initiate or reset the QueryString, which defines the 
           query at runtime.
           Separates the logic to initiate the QueryString out of various
           query manipulation methods. 
    Notes: This allows the Dataview class to implement query manipulation 
           method that can be used by the data class.
        -  May be referenced before the dataset is retrieved and created.
           The DataQueryString may be set at design time to capture that 
           more than one table is in the sort and defines the base for 
           this function. 
        -  If the DataQueryString is not set the value is resolved from the 
           dataset using QueryTables or just from the datatable if no dataset. 
        -  QueryTables has similar logic using Tables as the design time storage
           and using the dataset for default. 
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cDataTable       AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cQueryTables     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cDataQueryString AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hDatasetSource   AS HANDLE     NO-UNDO.

  {get DataQueryString cDataQueryString}. 
  IF cDataQueryString > '':U THEN
    RETURN cDataQueryString.
  
  &SCOPED-DEFINE xp-assign
  {get DataTable cDataTable}
  {get QueryTables cQueryTables} 
  {get DatasetSource hDatasetSource}
  . 
  &UNDEFINE xp-assign
  
  /* The default dataset resolution cannot be used after initialization 
     as data then already has been retrieved using only the datatable. */
  IF VALID-HANDLE(hDatasetSource) AND NUM-ENTRIES(cQueryTables) > 1 THEN
    RETURN {fnarg dataQueryString cQueryTables hDatasetSource}.
  
  RETURN 'FOR EACH ':U + cDataTable. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getQueryTables) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getQueryTables Procedure 
FUNCTION getQueryTables RETURNS CHARACTER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: Returns the tables that are (to be) used in the query and that
           can be used in sorting, filtering and browsing.             
    Notes: May be referenced before the dataset is retrieved and created.
         - The DataTable is always the first entry and all the other tables have 
           a many-to-one (or one-to-one) relationship to the DataTable.
         - The QueryTables may not include all ViewTables, but is always 
           included in ViewTables. 
         - The default difference is that it does not include the parent of a 
           one-to-many relation. 
         - Tables that cannot be inner-joined should not be included due to 
           a core 4GL limitation that makes get-last and reposition unusable
           on queries with outer-joins.
           The user can define the QueryTables at designtime. The result is 
           stored in the DataQueryString, from which this function resolves
           the tables again if the query is not yet defined.  
         - The dataset resolves the default if the handle and querystring is 
           not yet defined. (The DataTable is returned if not dataset exists).
         - Used in query manipulation   
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hQuery         AS HANDLE     NO-UNDO.
  DEFINE VARIABLE iTable         AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cTables        AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cViewTables    AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cDataTable     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hDatasetSource AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cQueryString   AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cChild         AS CHARACTER  NO-UNDO.

  {get DataHandle hQuery}.
  IF VALID-HANDLE(hQuery) AND hQuery:NUM-BUFFERS > 0 THEN
  DO: 
    DO iTable = 1 TO hQuery:NUM-BUFFERS: 
      cTables = cTables 
              + (IF cTables = '' THEN  '' ELSE ',')
              + hQuery:GET-BUFFER-HANDLE(iTable):NAME.
    END.
    RETURN cTables.
  END.
  
  /* Design-time querytable and sort definitions are stored in the 
     dataquerystring so resolve tables from that if it is defined */
  &SCOPED-DEFINE xp-assign
  {get DataQueryString cQueryString} 
  {get DataTable cDataTable}
  .
  &UNDEFINE xp-assign

  IF cDataTable > '' THEN 
  DO:
    IF cQueryString > '' THEN
    DO: 
      cTables = cDataTable.
      DO iTable = 2 TO NUM-ENTRIES(cQueryString):
        ASSIGN
          cChild  = ENTRY(iTable,cQueryString)
          cChild  = {fnarg whereClauseBuffer cChild}
          cTables = cTables 
                  + ','
                  + cChild.
      END.
      RETURN cTables.
    END. 
    
    /* Allow query to be undefined (important for designtime)
       The default dataset resolution cannot be used after initialization 
       as data then already has been retrieved using only the datatable.  */
    &SCOPED-DEFINE xp-assign
    {get ViewTables cViewTables}
    {get DataSetSource hDatasetSource}
    .
    &UNDEFINE xp-assign
    
    /* Allow querytables to be undefined (important for designtime) 
       A single ViewTables is the DataTable, so use default below as 
       queryTables must be in viewtables (A singe entry could be 
       default, but could also be override of default)  */
    IF VALID-HANDLE(hDatasetSource) AND NUM-ENTRIES(cViewTables) > 1 THEN
      RETURN {fnarg sortTables cDataTable hDatasetSource}.   
    ELSE 
      RETURN cDataTable.
  END.

  RETURN cDataTable. 

 END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getRebuildOnRepos) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getRebuildOnRepos Procedure 
FUNCTION getRebuildOnRepos RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:  Returns the flag indicating whether the RowObject temp-table
            should be rebuilt if a fetchLast or other reposition is done
            which is outside the bounds of the current dataset.
   Params:  <none>
------------------------------------------------------------------------------*/

  DEFINE VARIABLE lRebuild AS LOGICAL NO-UNDO.
  {get RebuildOnRepos lRebuild}.
  RETURN lRebuild.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getRequestHandle) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getRequestHandle Procedure 
FUNCTION getRequestHandle RETURNS HANDLE
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: Return the procedure handle that defines the scope of service 
           requests for this the object. 
    Notes: This is passed to the DataContainer to identify the requestor, 
           and will typically be resolved by the container's getRequestHandle, 
           which searches through parent container's to resolve this.            
        -  Returns the Dataview's own handle if no container is present or the 
           container's RequestHandle is ? because it cannot handle the request 
           either because it already is initialized or not defined to be a 
           data container.  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hContainerSource AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hRequestor       AS HANDLE     NO-UNDO.

  {get ContainerSource hContainerSource}.
  IF VALID-HANDLE(hContainerSource) THEN
  DO:
    {get RequestHandle hRequestor hContainerSource}.
    IF VALID-HANDLE(hRequestor) THEN
      RETURN hRequestor.
  END.

  RETURN TARGET-PROCEDURE.  

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getRowident) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getRowident Procedure 
FUNCTION getRowident RETURNS CHARACTER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: Returns a unique identifier for current record  
    Notes:  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hRowObject AS HANDLE     NO-UNDO.
  DEFINE VARIABLE iCol       AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cColumn    AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cValues    AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cKeys      AS CHARACTER  NO-UNDO.

  {get RowObject hRowObject}.
  /* @TODO future : possibly remove rowid dependency   
  IF hRowObject:AVAIL THEN
  DO:
    cKeys = hRowObject:KEYS.
    IF cKeys <> 'ROWID':U THEN 
    DO iCol = 1 TO NUM-ENTRIES(cKeys):
      cValues = cValues 
              + CHR(1)
              + hRowObject:BUFFER-FIELD(ENTRY(iCol,cKeys)):BUFFER-VALUE.    
    END.
    ELSE
      cValues = STRING(hRowObject:ROWID).
  END. /* avail */
  ELSE  
    cValues = ?.
  */  

  RETURN STRING(hRowObject:rowid). 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getRowObject) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getRowObject Procedure 
FUNCTION getRowObject RETURNS HANDLE
  ( ) :
/*------------------------------------------------------------------------------
  Purpose:     Returns the handle of the RowObject Temp-Table buffer.
  
  Parameters:  <none>
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hRowObject AS HANDLE NO-UNDO.  
  {get RowObject hRowObject}.
  RETURN hRowObject.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getRowObjectState) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getRowObjectState Procedure 
FUNCTION getRowObjectState RETURNS CHARACTER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:     Signals whether there are uncommitted updates in the commit/submit
               scope of this object.
               Returns 'RowUpdated' if changesexists OR 'NoUpdates' if there are 
               no changes.
  Parameters:  <none>
  Note:        The two possible return values are: 'NoUpdates' and 'RowUpdated'
             - As of current we do not store the value, but resolve it from the 
               dataset, since this is also defines the commit scope.
               We would need to store it if we ever wanted to allow the UI to 
               commit changes from several datasets though. We also need to 
               store it when/if we support no dataset TT based Dataviews.
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cDataTable     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hDataSetSource AS HANDLE     NO-UNDO.
  DEFINE VARIABLE lAutoCommit    AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lHasChanges    AS LOGICAL    NO-UNDO.

  &SCOPED-DEFINE xp-assign
  {get DataTable cDataTable}
  {get DatasetSource hDatasetSource}
  {get AutoCommit lAutoCommit}
  .
  &UNDEFINE xp-assign
  
  IF NOT lAutoCommit AND VALID-HANDLE(hDatasetSource) THEN
    lHasChanges = {fnarg hasChanges cDataTable hDatasetSource}.
  
  /* not currently in use 
  &SCOPED-DEFINE xpRowObjectState
  {get RowObjectState cState}.
  &UNDEFINE xpRowObjectState
  */
   
  RETURN IF lHasChanges THEN 'RowUpdated':U ELSE 'NoUpdates':U.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getRowsToBatch) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getRowsToBatch Procedure 
FUNCTION getRowsToBatch RETURNS INTEGER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:  Returns the number of rows to be transferred from the database
            query into the RowObject temp-table at a time.
   Params:  <none>
    Notes:  set to 200 by default. 0 = ALL 
------------------------------------------------------------------------------*/
  DEFINE VARIABLE iRows AS INTEGER NO-UNDO.
  {get RowsToBatch iRows}.
  RETURN iRows.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getScrollable) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getScrollable Procedure 
FUNCTION getScrollable RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: Tells whether the object has scrollable data.    
    Notes: This is currently decided by the dataset relationship, but  
           can be overridden by a request for all data for the specific 
           table in which case isDataquerycomplete will be true.            
         - Returns unknown if called before definitions are retrieved. 
------------------------------------------------------------------------------*/  
  DEFINE VARIABLE hDatasetSource AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cDataTable     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE lFirst         AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lLast          AS LOGICAL    NO-UNDO.

  &SCOPED-DEFINE xp-assign
  {get DatasetSource hDatasetSource}
  {get DataTable cDataTable}
  {get HasFirst lFirst}
  {get HasLast lLast}
  . 
  &UNDEFINE xp-assign
  
  IF lFirst OR lLast THEN
    RETURN TRUE.

  IF VALID-HANDLE(hDatasetSource) THEN
    RETURN {fnarg isScrollable cDataTable hDatasetSource}.
  
  /* We don't know this if no valid dataset */
  RETURN ?.  

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getTables) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getTables Procedure 
FUNCTION getTables RETURNS CHARACTER
  (  ) :
/*------------------------------------------------------------------------------
   Purpose: The Tables defines the object's view of data.    
     Notes: The names in the list references to the tables as defined in the
            object and referenced in the query, so each entry must be unique. 
  DataView - The tables may include outer join tables currently not added to
             the physical query due to 4GL limitations that makes get-last
             and reposition unusable.   
           - Should only be accessed by getViewTables at runtime.           
  Dbaware (does not overrride, but uses tables differently)    
          - The names may be buffer names that differ from the actual physical 
            names.
          - The physical names is defined in the corresponding PhysicalTables 
            property.  
          - Qualified with database name if the query is defined with dbname.
          - From 9.1B this property is a design time property while it earlier 
            was resolved from the actual query.           
          - Several other properties have table delimiters and are depending of 
            the design time order of this property.              
          - The web2/webprop.i UNDEFINEs xpTables since it need to override 
            getTables()                    
------------------------------------------------------------------------------*/
 DEFINE VARIABLE cTables AS CHARACTER  NO-UNDO.
 {get Tables cTables}.
 RETURN cTables.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getToggleDataTargets) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getToggleDataTargets Procedure 
FUNCTION getToggleDataTargets RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: Returns true if dataTargets should be toggled on/of in LinkState
           based on the passed 'active' or 'inactive' parameter 
    Notes:  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE ltoggle AS LOGICAL    NO-UNDO.
  {get toggleDataTargets lToggle}.

  RETURN lToggle. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getTransferChildrenForAll) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getTransferChildrenForAll Procedure 
FUNCTION getTransferChildrenForAll RETURNS LOGICAL
  (   ) :
/*------------------------------------------------------------------------------
  Purpose: This flag decides whether children for all records (of the batch) is 
           to be transferred from the database. 
    Notes: Currently only supported for read event handlers during a fetch. 
           The child SDO is only left with temp-table records for one parent 
           when the fetch*batch is finished.   
------------------------------------------------------------------------------*/
  DEFINE VARIABLE lTransferChildrenForAll AS LOGICAL    NO-UNDO.
  {get TransferChildrenForAll lTransferChildrenForAll}.
  RETURN lTransferChildrenForAll.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getUpdatableColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getUpdatableColumns Procedure 
FUNCTION getUpdatableColumns RETURNS CHARACTER
  (   ) :
/*------------------------------------------------------------------------------
  Purpose:     Returns a comma delimited list of the Updatable Columns for the
               DataView.
  Parameters:  <none>
  Notes:        
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cColumns AS CHARACTER  NO-UNDO.
  
  {get UpdatableColumns cColumns}.
  RETURN cColumns.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getUpdateSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getUpdateSource Procedure 
FUNCTION getUpdateSource RETURNS CHARACTER
  ( ) :
/*------------------------------------------------------------------------------
  Purpose:  Returns the handle of the object's UpdateSource.
   Params:  <none>
------------------------------------------------------------------------------*/

  DEFINE VARIABLE cSource AS CHARACTER NO-UNDO.
  {get UpdateSource cSource}.
  RETURN cSource.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getUseDBQualifier) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getUseDBQualifier Procedure 
FUNCTION getUseDBQualifier RETURNS LOGICAL
  ( /* parameter-definitions */ ) :
/*------------------------------------------------------------------------------
  Purpose: Use db-name in field list (Interface for generic query processing)  
    Notes: Used by generic query processing that originally was implemented 
           in the query class and worked on database queries and now have been 
           moved up to the dataview class to also handle temp-table and 
           prodataset queries.      
------------------------------------------------------------------------------*/
  RETURN FALSE.   

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getViewTables) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getViewTables Procedure 
FUNCTION getViewTables RETURNS CHARACTER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: All tables that are included in the view including the DataTable 
    Notes: May be referenced before the dataset is retrieved and created and
           defines which tables to retrieve from the service.
         - The DataTable is always the first entry and all the other tables have 
           a many-to-one (or one-to-one) relationship to the DataTable.
         - QueryTables defines the tables in the query. 
         - This may include outer join tables currently not added to
           the physical query due to 4GL limitations that makes get-last
           and reposition unusable on outer-join queries.   
         - The user defines this at design time storing the value in 
           the Tables attribute, which is not to be accessed outside of here
           at runtime.
         - The Tables property must be defined at design time if the object
           need to retrieve more than just the DataTable as the dataset is 
           not available before the first request. 
         - The default is resolved from the dataset relationships, which  
           mainly is for design time.             
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hDatasetSource AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cDataTable     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cTables        AS CHARACTER  NO-UNDO.
  
  /* Set at design time to override default.
     (Currently set to datatable if not defined in initializeObject
      as runtime default, when only businessentity and datatable is defined)  */
  {get Tables cTables}.
  IF cTables > '' THEN
    RETURN cTables.

  /* Allow Tables to be undefined (important for designtime) */
  &SCOPED-DEFINE xp-assign
  {get DataSetSource hDatasetSource}
  {get DataTable cDataTable}
  .
  &UNDEFINE xp-assign
  
  IF VALID-HANDLE(hDatasetSource) AND cDataTable > '' THEN
    RETURN {fnarg viewTables cDataTable hDatasetSource}.   
  ELSE 
    RETURN cDataTable.

 END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-getWordIndexedFields) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION getWordIndexedFields Procedure 
FUNCTION getWordIndexedFields RETURNS CHARACTER
  ( ) :
/*------------------------------------------------------------------------------
  Purpose: Returns a comma separated list of fields that are word indexed.   
    Notes: 
------------------------------------------------------------------------------*/
  /* Get the word indexes from the IndexInformation function */
  RETURN DYNAMIC-FUNCTION('indexInformation' IN TARGET-PROCEDURE,
                          'WORD':U, /* query  */
                           NO,   /* no table delimiter */
                           ?).

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-hasActiveAudit) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION hasActiveAudit Procedure 
FUNCTION hasActiveAudit RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: Tell toolbar source that we have no active audit data 
    Notes: This is a record level value that is used to show a tick mark on 
           the Auditing action if the current record has auditing data. 
         - Overrides should be implemented if this information is available 
           in the Business Entity.            
------------------------------------------------------------------------------*/
  
  /* A custom dataview could for instance return the logical value in a field 
     that follows a naming convention in the DataTable record 
  RETURN columnValue({fn getDataTable} + '.HasActiveAudit').
  */

  RETURN FALSE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-hasActiveComments) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION hasActiveComments Procedure 
FUNCTION hasActiveComments RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: Tell toolbar source that we have no active comments  
    Notes: This is a record level value that is used to show a tick mark on 
           the Comment action if the current record has comments. 
         - Overrides should be implemented if this information is available 
           in the Business Entity.            
------------------------------------------------------------------------------*/
  
  /* A custom dataview could for instance return the logical value in a field 
     that follows a naming convention in the DataTable record 
  RETURN columnValue({fn getDataTable} + '.HasActiveComment').
  */

  RETURN FALSE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-hasForeignKeyChanged) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION hasForeignKeyChanged Procedure 
FUNCTION hasForeignKeyChanged RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: Returns true if the dataSource Foreignfields are different 
           from the current ForeignValues  
    Notes: DataAvailable has a 'RESET' mode that indicates that the query only 
           should be opened if necessary. This function is an imporetant part of 
           that logic. If it returns TRUE the query need to be reopened.  
        -  Uncommitted values are currently not considered to be a change, so 
           the DataSource's before-image values is checked if 
           RowObjectState = 'RowUpdated'.
        -  If the query is closed the Key is considered changed.     
           (May be a result of a Cancelled Add or Copy of the parent)  
        -  duplicated in sbo.p  
Note date: 2004/06/06            
-----------------------------------------------------------------------------*/
DEFINE VARIABLE cForeignFields  AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cCurrentValues  AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cParentValues   AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cSourceFields   AS CHARACTER  NO-UNDO.
DEFINE VARIABLE iField          AS INTEGER    NO-UNDO.
DEFINE VARIABLE hField          AS HANDLE     NO-UNDO.
DEFINE VARIABLE cField          AS CHARACTER  NO-UNDO.
DEFINE VARIABLE hDataSource     AS HANDLE     NO-UNDO.
DEFINE VARIABLE cRowObjectState AS CHARACTER  NO-UNDO.
DEFINE VARIABLE hRowObjUpd      AS HANDLE     NO-UNDO.
DEFINE VARIABLE hRowObject      AS HANDLE     NO-UNDO.
DEFINE VARIABLE lNew            AS LOGICAL    NO-UNDO.
DEFINE VARIABLE lQueryOpen      AS LOGICAL    NO-UNDO.
DEFINE VARIABLE cDataTable      AS CHARACTER  NO-UNDO.

 &SCOPED-DEFINE xp-assign 
 {get ForeignFields cForeignFields}
 {get ForeignValues cCurrentValues}  
 {get DataSource hDataSource}
 {get QueryOpen lQueryOpen}
 {get DataTable cDataTable}
 {get RowObject hRowObject}
 .
 &UNDEFINE xp-assign
  
 IF NOT VALID-HANDLE(hDataSource) THEN
   RETURN FALSE.

 /* The table may have been emptied as a result of a parent, grandparent
    openQuery, so just return true if empty */  
 IF hRowObject:TABLE-HANDLE:HAS-RECORDS = FALSE THEN
   RETURN TRUE.
  
 DO iField = 1 TO NUM-ENTRIES(cForeignFields) BY 2:
   cSourceFields =  cSourceFields 
                    + (IF iField = 1 THEN "":U ELSE ",":U)                 
                     /* 2nd of pair is source RowObject fld */ 
                    +  ENTRY(iField + 1, cForeignFields).
 END.
 
 /* If the DataSource has uncommitted changes, check the before image of the 
    data source (This is admittedly somewhat dirty, but we do not want an API 
    yet...) 
    The intention here is to ensure that this function returns true
    if the parent really is pointing to a different record, but returns 
    false if we still are on the original parent, disregarding changed 
    keyvalues, we also want to disregard uncommitted new records */
 {get RowObjectState cRowObjectState hDataSource}. 
 IF cRowObjectState = 'RowUpdated':U THEN
 BeforeCheck:
 DO:
   /* New uncommitted does not constitute a change, but would fail the check 
      below */ 
   {get NewRow lNew}.
   IF lNew THEN
      RETURN FALSE.
   
   {get RowObject hRowObject hDataSource}.

   /* Find the corresponding rowObjUpd -- (really synchronize the buffers) 
      Check the before image values and RETURN this finding. 
      if no RowObjUpd record is available then the current parent has not 
      changed and we will use the general logic below   */
   IF VALID-HANDLE(hRowObject) THEN
   DO: 
     hRowObjUpd = hRowObject:BEFORE-BUFFER.
     IF VALID-HANDLE(hRowObjUpd) THEN
     DO:
       hRowObjUpd:FIND-BY-ROWID(hRowObject:BEFORE-ROWID) NO-ERROR.
       IF hRowObjUpd:AVAIL THEN
       DO:
         DO iField = 1 TO NUM-ENTRIES(cSourceFields):
           cField = ENTRY(iField,cSourceFields).
           /* We do not really support this, but this is not the place to handle 
              errors, so just leave it to the logic below */
           IF ENTRY(1,cField,'.') <> cDataTable THEN
             LEAVE beforeCheck.
           cField = ENTRY(2,cField,'.').
           hField = hRowObjUpd:BUFFER-FIELD(cField). 
           cParentValues = cParentValues + ',':U + hField:BUFFER-VALUE.
         END.
         cParentValues = LEFT-TRIM(cParentValues,',':U). 
         /* Return immediately */
         RETURN cParentValues <> cCurrentValues.
       END. /* hROwObjUpd avail */
     END.  /* valid-handle(hRowObjUpd) */
   END.
 END.

 ASSIGN
   cParentValues  = {fnarg colValues cSourceFields hDataSource} NO-ERROR.
   /* Throw away the RowIdent entry returned by colValues*/
   ENTRY(1,cParentValues,CHR(1)) = '':U.
   /* Remove the chr(1).. DON'T TRIM it may cause a problem if the first 
      value(s) in the list is blank */ 
   cParentValues  = SUBSTR(cParentValues,2).
 
 RETURN cParentValues <> cCurrentValues.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-indexInformation) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION indexInformation Procedure 
FUNCTION indexInformation RETURNS CHARACTER
   (pcQuery       AS CHAR,
    plUseTableSep AS LOG,
    pcIndexInfo   AS CHAR):
/*------------------------------------------------------------------------------
   Purpose: Return index Information for buffers in the query.
            Each index is separated with chr(1).
            The information can be specified to either be returned with  
            fieldnames qualifed with table (and db) or to use chr(2) as table 
            separator.  
                        
Parameters: pcQuery - What information? 
                - 'All'             All indexed fields
                - 'Standard' or ''  All indexed fields excluding word indexes    
                - 'Word'            Word Indexed 
                - 'Unique'          Unique indexes 
                - 'NonUnique'       Non Unique indexes 
                - 'Primary'         Primary index           
                
                - 'Info'            All info (meaningless if pcIndexInfo <> ?) 
             
             All the commands can be specified for one specific buffer by 
             specifying the buffer number in parenthesis.
             Example: 'Info(1)' returns all info for first buffer  
           
           plUseTableSep - Use table separator.  
           
                - Yes   Use table separator 
                - No    Don't use table separator 
                       (if pcIndexinfo = ? fieldnames will be qualifed
                        otherwise they will remain as in pcIndexInfo)
          
          pcIndexInfo - Query or previously retrieved info. Enables the 
                         function to be used with no database connection.    
                - ? use query - if plUseTableSep = no the field will be 
                                returned qualified.     
                -  Index info in EXACT SAME FORMAT as returned from this 
                   function earlier with indexInformation('info',yes,?).
                   
                   See Notes below for delimiters. 
     Notes: Returned delimiters
            - qualified     - chr(1) as index separator 
            - non-qualifed  - chr(1) as index separator 
                              chr(2) as table separator        
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hQuery       AS HANDLE NO-UNDO.
  DEFINE VARIABLE hBuff        AS HANDLE NO-UNDO.
  DEFINE VARIABLE iBuff        AS INT    NO-UNDO.
  DEFINE VARIABLE iIdx         AS INT    NO-UNDO.
  DEFINE VARIABLE iField       AS INT    NO-UNDO.
  DEFINE VARIABLE cInfo        AS CHAR   NO-UNDO.
  DEFINE VARIABLE cFieldInfo   AS CHAR   NO-UNDO.
  DEFINE VARIABLE cIndexInfo   AS CHAR   NO-UNDO.
  DEFINE VARIABLE cIndexString AS CHAR   NO-UNDO.
  DEFINE VARIABLE lFound       AS LOG    NO-UNDO.
  DEFINE VARIABLE lFirstIdx    AS LOG    NO-UNDO.
  DEFINE VARIABLE cTblDlm      AS CHAR   NO-UNDO.
  DEFINE VARIABLE cIdxDlm      AS CHAR   NO-UNDO.
  DEFINE VARIABLE cField       AS CHAR   NO-UNDO.
  DEFINE VARIABLE cFieldList   AS CHAR   NO-UNDO.
  DEFINE VARIABLE iFirstEntry  AS INT    NO-UNDO.
  DEFINE VARIABLE iLastEntry   AS INT    NO-UNDO.
  DEFINE VARIABLE lUseDBQual   AS LOGICAL    NO-UNDO.
  
  /* We only use query if no previouisly processed info is passed */
  IF pcIndexInfo = ? THEN
  DO:
    {get QueryHandle hQuery}.
    IF NOT VALID-HANDLE(hQuery) THEN
      RETURN ?.
  END.

  /* request for single buffer */
  IF INDEX(pcQuery,"(":U) > 0 THEN
    ASSIGN
      /* get number inside parenthesis  */
      iFirstEntry = INT(RIGHT-TRIM(ENTRY(2,pcQuery,"(":U),")":U))
      pcQuery     = ENTRY(1,pcQuery,"(":U)
      iLastEntry  = iFirstEntry.
  ELSE 
    ASSIGN 
      iFirstEntry = 1
      iLastEntry  = IF VALID-HANDLE(hQuery)
                    THEN hQuery:NUM-BUFFERS
                    ELSE NUM-ENTRIES(pcIndexInfo,cTblDlm).
  ASSIGN
    cTblDlm     = CHR(2) 
    cIdxDlm     = CHR(1).

  /* If no table separator find qualifier rule */   
  IF NOT plUseTableSep THEN
    {get UseDBQualifier lUseDBQual}.
 
  DO iBuff = iFirstEntry TO iLastEntry:
    IF pcIndexInfo <> ? THEN
      cIndexString = ENTRY(iBuff,pcIndexInfo,cTblDlm).         
    ELSE
      hBuff  = hQuery:GET-BUFFER-HANDLE(iBuff).
    
    ASSIGN
      iIdx      = 0
      lFirstIdx = TRUE.
 
    IndexBlock:
    DO WHILE TRUE:
      ASSIGN
        iIdx         = iIdx + 1
        cIndexInfo   = IF pcIndexInfo = ? 
                       THEN hBuff:INDEX-INFORMATION(iIdx)
                          /* set to unknown when all entries 
                             have been parsed */
                       ELSE IF NUM-ENTRIES(cIndexString,cIdxDlm) >= iIdx  
                            THEN ENTRY(iIdx,cIndexString,cIdxDlm)        
                            ELSE ?.
      IF cIndexInfo = ? THEN 
         LEAVE IndexBlock.    
      CASE pcQuery:
        WHEN 'Standard':U OR WHEN '':U THEN
          lFound = ENTRY(4,cIndexInfo) = "0":U.
          
        WHEN "Info":U OR WHEN "All" THEN
          lFound = TRUE.
          
        WHEN "Word":U THEN
          lFound = ENTRY(4,cIndexInfo) = "1":U.
          
        WHEN "Unique":U THEN
          lFound = ENTRY(2,cIndexInfo) = "1":U.
          
        WHEN "NonUnique":U THEN
          lFound = ENTRY(2,cIndexInfo) = "0":U AND 
                   ENTRY(4,cIndexInfo) = "0":U.
          
        WHEN "Primary" THEN
          lFound = ENTRY(3,cIndexInfo) = "1":U.
          
        OTHERWISE
        DO:
          /* Design time error */
          MESSAGE "ADM Error:"
                  "Function indexInformation() does not understand"
                  "parameter '" + pcQuery "'"
                    
          VIEW-AS ALERT-BOX ERROR.
          RETURN ?.
        END.
      END CASE. /* pcQuery */
        
      /* If pcQuery includes this index then .... */ 
      IF lFound THEN
      DO:
        cFieldList = "":U.
        /* if 'info' and use table separator we have all we need.
           Otherwise we loop through each field and refine the data */ 
        IF pcQuery <> "info":U OR NOT plUseTableSep THEN
        DO iField = 5 TO NUM-ENTRIES(cIndexInfo) BY 2:

          /* If no table separator and the buffer is valid 
             we qualify the field */ 
          cField = (IF NOT plUseTableSep AND VALID-HANDLE(hBuff)
                    THEN ((IF lUseDBQual THEN hBuff:DBNAME + ".":U
                                        ELSE "":U)
                          + hBuff:NAME + ".":U)
                    ELSE "":U)
                  + ENTRY(iField,cIndexInfo). 
          /* if 'info' just replace the field with the qualifed one */
          IF pcQuery = "Info":U THEN
            ENTRY(iField,cIndexInfo) = cField.

          ELSE 
            cFieldList = cFieldList 
                         + (IF cFieldList = "":U THEN "":U ELSE ",":U)
                         + cField.
        END.
        ASSIGN
          cInfo = cInfo 
                   /* don't add index delimiter for first index after 
                      the table separator or when empty */ 
                + (IF (plUseTableSep AND lFirstIdx) 
                   OR  cInfo = '':U 
                   THEN '':U 
                   ELSE cIdxDlm)
                   /* if 'info' just apppend all index info  */ 
                + (IF pcQuery = "Info":U 
                   THEN cIndexInfo
                   ELSE cFieldList)
          lFirstIdx = FALSE.
      END. /* if lFound */
    END. /* do while true */

    /* If no field qualifier add table delimiter unless this is the last buffer */
    IF plUseTableSep AND iBuff LT iLastEntry THEN 
      cInfo = cInfo + cTblDlm.

  END. /* do ibuff = 1 to num-buffers */  
  RETURN TRIM(cInfo,cTblDlm).
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-insertExpression) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION insertExpression Procedure 
FUNCTION insertExpression RETURNS CHARACTER
  (pcWhere      AS CHAR,   
   pcExpression AS CHAR,     
   pcAndOr      AS CHAR):                         
/*------------------------------------------------------------------------------
 Purpose:     Inserts an expression into ONE buffer's where-clause.
 Parameters:  
      pcWhere      - Complete where clause with or without the FOR keyword,
                     but without any comma before or after.
      pcExpression - New expression OR OF phrase (Existing OF phrase is replaced)
      pcAndOr      - Specifies what operator is used to add the new expression 
                     to existing ones.
                     - AND (default) 
                     - OR         
 Notes:     - The new expression is embedded in parenthesis, but no parentheses
              are placed around the existing one.  
            - Lock keywords must be unabbreviated or without -lock (i.e. SHARE
              or EXCLUSIVE.)   
            - Any keyword in comments may cause problems.              
------------------------------------------------------------------------------*/  
  DEFINE VARIABLE cTable        AS CHAR NO-UNDO.  
  DEFINE VARIABLE cRelTable     AS CHAR NO-UNDO.  
  DEFINE VARIABLE cJoinTable    AS CHAR NO-UNDO.  
  DEFINE VARIABLE cWhereOrAnd   AS CHAR NO-UNDO.  
  DEFINE VARIABLE iTblPos       AS INT  NO-UNDO.
  DEFINE VARIABLE iWherePos     AS INT  NO-UNDO.
  DEFINE VARIABLE lWhere        AS LOG  NO-UNDO.
  DEFINE VARIABLE iOfPos        AS INT  NO-UNDO.
  DEFINE VARIABLE iRelTblPos    AS INT  NO-UNDO.  
  DEFINE VARIABLE iInsertPos    AS INT  NO-UNDO.    
  
  DEFINE VARIABLE iUseIdxPos    AS INT  NO-UNDO.        
  DEFINE VARIABLE iOuterPos     AS INT  NO-UNDO.        
  DEFINE VARIABLE iLockPos      AS INT  NO-UNDO.      
  
  DEFINE VARIABLE iByPos        AS INT  NO-UNDO.        
  DEFINE VARIABLE iIdxRePos     AS INT  NO-UNDO.        
           
  ASSIGN 
    /* Get rid of potential line break characters (query builder -> repository)*/   
    pcWhere       = REPLACE(pcWhere,CHR(10),' ':U)
    cTable        = {fnarg whereClauseBuffer pcWhere}
    iTblPos       = INDEX(pcWhere,cTable) + LENGTH(cTable,"CHARACTER":U)
    
    iWherePos     = INDEX(pcWhere," WHERE ":U) + 6    
    iByPos        = INDEX(pcWhere," BY ":U)    
    iUseIdxPos    = INDEX(pcWhere," USE-INDEX ":U)    
    iIdxRePos     = INDEX(pcWhere + " ":U," INDEXED-REPOSITION ":U)    
    iOuterPos     = INDEX(pcWhere + " ":U," OUTER-JOIN ":U)     
    iLockPos      = MAX(INDEX(pcWhere + " ":U," NO-LOCK ":U),
                        INDEX(pcWhere + " ":U," SHARE-LOCK ":U),
                        INDEX(pcWhere + " ":U," EXCLUSIVE-LOCK ":U),
                        INDEX(pcWhere + " ":U," SHARE ":U),
                        INDEX(pcWhere + " ":U," EXCLUSIVE ":U)
                        )    
    iInsertPos    = LENGTH(pcWhere) + 1 
                    /* We must insert before the leftmoust keyword,
                       unless the keyword is Before the WHERE keyword */ 
    iInsertPos    = MIN(
                      (IF iLockPos   > iWherePos THEN iLockPos   ELSE iInsertPos),
                      (IF iOuterPos  > iWherePos THEN iOuterPos  ELSE iInsertPos),
                      (IF iUseIdxPos > iWherePos THEN iUseIdxPos ELSE iInsertPos),
                      (IF iIdxRePos  > iWherePos THEN iIdxRePos  ELSE iInsertPos),
                      (IF iByPos     > iWherePos THEN iByPos     ELSE iInsertPos)
                       )                                                        
    lWhere        = INDEX(pcWhere," WHERE ":U) > 0 
    cWhereOrAnd   = (IF NOT lWhere          THEN " WHERE ":U 
                     ELSE IF pcAndOr = "":U OR pcAndOr = ? THEN " AND ":U 
                     ELSE " ":U + pcAndOr + " ":U) 
    iOfPos        = INDEX(pcWhere," OF ":U).
  
  IF LEFT-TRIM(pcExpression) BEGINS "OF ":U THEN 
  DO:   
    /* If there is an OF in both the join and existing query we replace the 
       table unless they are the same */      
    IF iOfPos > 0 THEN 
    DO:
      ASSIGN
        /* Find the table in the old join */               
        cRelTable  = ENTRY(1,LEFT-TRIM(SUBSTRING(pcWhere,iOfPos + 4))," ":U)      
        /* Find the table in the new join */       
        cJoinTable = SUBSTRING(LEFT-TRIM(pcExpression),3).
      
      IF cJoinTable <> cRelTable THEN
        ASSIGN 
         iRelTblPos = INDEX(pcWhere + " ":U," ":U + cRelTable + " ":U) 
                      + 1                            
         SUBSTRING(pcWhere,iRelTblPos,LENGTH(cRelTable)) = cJointable. 
    END. /* if iOfPos > 0 */ 
    ELSE 
      SUBSTRING(pcWhere,iTblPos,0) = " ":U + pcExpression.                                                                
  END. /* if left-trim(pcExpression) BEGINS "OF ":U */
  ELSE             
    SUBSTRING(pcWhere,iInsertPos,0) = cWhereOrAnd 
                                      + "(":U 
                                      + pcExpression 
                                      + ")":U. 
                                            
  RETURN RIGHT-TRIM(pcWhere).
  
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-instanceOf) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION instanceOf Procedure 
FUNCTION instanceOf RETURNS LOGICAL
    ( INPUT pcClass AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose: Override instanceOf to support SmartDataObject subtypes in 
           non repository
    Notes: This is currently only supported for DataView, Data and Query 
------------------------------------------------------------------------------*/
 IF pcClass = 'DataView':U THEN
   RETURN TRUE.

 RETURN SUPER(pcClass).

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-isDataQueryComplete) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION isDataQueryComplete Procedure 
FUNCTION isDataQueryComplete RETURNS LOGICAL
  ( /* parameter-definitions */ ) :
/*------------------------------------------------------------------------------
  Purpose: Returns true if the temp-table has all records.    
    Notes: This may be checked before the actual query is opened  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE lLast  AS LOGICAL NO-UNDO.
  DEFINE VARIABLE lFirst AS LOGICAL NO-UNDO.
  
  &SCOPED-DEFINE xp-assign
  {get HasFirst lFirst}
  {get HasLast lLast}
  . 
  &UNDEFINE xp-assign
  RETURN lFirst AND lLast.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-keyWhere) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION keyWhere Procedure 
FUNCTION keyWhere RETURNS CHARACTER
 (phBuffer AS HANDLE,
  pcQual   AS CHAR ):
/*------------------------------------------------------------------------------
  Purpose: Returns a query expression with the key field(s) and current
           value(s). 
 phBuffer: phBuffer - the buffer is typically the before-image or after-image
                      buffer.  
           pcQual   - Optional qualifier for the column reference.               
            
    Notes: Used to find a record without relying on rowid. 
           For example in deleteRow error handling, where prodataset methods 
           may reuse the rowids of a deleted record that need to be undeleted.   
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cKeyFields AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE iField     AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cField     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cKeyWhere  AS CHARACTER  NO-UNDO.

  {get KeyFields cKeyFields}.
  IF cKeyFields = '' THEN 
     MESSAGE 'Table' 
             phBuffer:TABLE-HANDLE:NAME 
             'defined in' 
             phBuffer:TABLE-HANDLE:INSTANTIATING-PROCEDURE:FILE-NAME  
             'has no unique key.' SKIP
             program-name(2) 'operation cannot be performed.'
      VIEW-AS ALERT-BOX.           

  ELSE IF VALID-HANDLE(phBuffer) THEN
  DO iField = 1 TO NUM-ENTRIES(cKeyFields):
    ASSIGN
      cField     = ENTRY(iField,cKeyFields)
      cField     = ENTRY(NUM-ENTRIES(cField,'.'),cField,'.')
      cKeyWhere  = cKeyWhere 
                 + (IF iField > 1 THEN ' AND ' ELSE '')
                 + (IF pcQual > '' THEN pcQual ELSE phBuffer:NAME)
                 + '.' 
                 + cField
                 + ' = ' 
                 + QUOTER(phBuffer:BUFFER-FIELD(cField):BUFFER-VALUE,"'":U).


  END.

  RETURN cKeyWhere. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-newQuerySort) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION newQuerySort Procedure 
FUNCTION newQuerySort RETURNS CHARACTER
  ( pcQuery       AS CHAR,
    pcSort        AS CHAR) :
/*------------------------------------------------------------------------------
  Purpose   :  Insert sort criteria (BY phrase) in a QueryString.
  Parameters:
    pcQuery    - Query to add sort to (current sort will be replaced)        
    pcSort     - new sort expression.
                 - [BY ] column [DESCENDING | TOGGLE ] [ BY ... ]  
                 - TOGGLE sort option specifies that the column should be 
                   sorted opposite of the current sort. The option can be 
                   specified for any column in the sort.      
                                      
 Notes: Unqualified columns are always resolved as db fields (searching 
        in query order) also when plDBColumns is false.
     -  We check each entry in the new sort criteria for several reasons: 
       - Avoid appserver hit if the specified sort already is set 
         (The browser bombards the SDO with sort options at start up..) 
       - Support of 'RowObject.' qualifications, so we need to rename 
         accordingly
       - The TOGGLE option requires check for current sort option and          
         that all columns are in same order   
------------------------------------------------------------------------------*/
 DEFINE VARIABLE cNewColumn AS CHARACTER EXTENT {&MaxBreaks} NO-UNDO.
 DEFINE VARIABLE cOldColumn AS CHARACTER EXTENT {&MaxBreaks} NO-UNDO.
 DEFINE VARIABLE cNewOption AS CHARACTER EXTENT {&MaxBreaks} NO-UNDO.
 DEFINE VARIABLE cOldOption AS CHARACTER EXTENT {&MaxBreaks} NO-UNDO.

 DEFINE VARIABLE cColumn           AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE cOption           AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE cSort             AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE iNum              AS INTEGER    NO-UNDO.
 DEFINE VARIABLE iByPos            AS INTEGER    NO-UNDO.
 DEFINE VARIABLE iIdxPos           AS INTEGER    NO-UNDO.
 DEFINE VARIABLE iLength           AS INTEGER    NO-UNDO.
 DEFINE VARIABLE iCase             AS INTEGER    NO-UNDO.
 DEFINE VARIABLE iNumWords         AS INTEGER    NO-UNDO.
 DEFINE VARIABLE cSortEntry        AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE cLastentry        AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE lCommaIsSep       AS LOGICAL    NO-UNDO.

 DEFINE VARIABLE iNewEntries       AS INTEGER    NO-UNDO.
 DEFINE VARIABLE iOldEntries       AS INTEGER    NO-UNDO.
 DEFINE VARIABLE cOldSort          AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE cNewSort          AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE lDiffColumns      AS LOGICAL    NO-UNDO.
 DEFINE VARIABLE lToggled          AS LOGICAL    NO-UNDO.
 DEFINE VARIABLE cDataColumns      AS CHARACTER  NO-UNDO.

 IF pcQuery = '':U THEN
   RETURN '':U.

 ASSIGN           /* remove first BY if passed */
   pcSort       = IF LEFT-TRIM(pcSort) BEGINS "BY ":U 
                  THEN TRIM(SUBSTRING(LEFT-TRIM(pcSort),3)) 
                  ELSE TRIM(pcSort)
   cOldSort     = {fnarg sortExpression pcQuery}
   cOldSort     = IF cOldSort BEGINS "BY ":U 
                  THEN SUBSTRING(cOldSort,4) 
                  ELSE cOldSort.
 /* Backwards support for the accidental support of comma separated list.  
     In 10.0A the logic used to replace ' BY ' with commas to simplify 
     the processing. This accidentally allowed "support" for direct pass of a 
     comma separated list of sort entries... The use of comma did however mess 
     up when sort was specified with SUBSTR(field,1,199) to prevent index limit
     blowup. 
     NOTE: - spaces in comma separated list is only allowed for sortoption  */ 

 IF NUM-ENTRIES(pcSort) > 1 AND INDEX(pcSort,' BY ':U) = 0 THEN
 DO:
   {get DataColumns cDataColumns}.
   lCommaIsSep = TRUE.
   DO iNum = 1 TO NUM-ENTRIES(pcSort):
     ASSIGN
       cSortEntry  = ENTRY(iNum,pcSort)
       cColumn     = ENTRY(1,cSortEntry,' ')
       cColumn     = {fnarg resolveColumn cColumn}.
     IF LOOKUP(cColumn,cDataColumns) > 0 THEN
     DO:
       lCommaIsSep = FALSE. 
       LEAVE.
     END.
   END.

   IF lCommaIsSep THEN
     pcSort = REPLACE(pcSort,",":U," BY ":U).
 END.

 IF pcSort = '' AND cOldSort <> '' THEN
   lDiffColumns = TRUE.
 ELSE    /* loop 1 is for new sort loop 2 for old sort */
 DO iCase = 1 TO 2:

   CASE iCase:
     WHEN 1 THEN
       cSort = pcSort.
     WHEN 2 THEN
       cSort = cOldsort.
   END CASE.
   iNum = 0.

   DO WHILE cSort > '' :
     ASSIGN
       iNum    = iNum + 1
       cColumn = ''
       iByPos  = INDEX(cSort,' BY ').
     
     IF iCase = 2 AND iNum > iNewEntries THEN
     DO:
       lDiffColumns = TRUE.
       LEAVE.
     END.

     IF iByPos > 0 THEN
       ASSIGN
         cSortEntry = TRIM(SUBSTR(cSort,1,iByPos))
         cSort      = SUBSTR(cSort,iByPos + 4).
     ELSE 
       ASSIGN
         cSortEntry = cSort
         cSort      = ''.
     
     ASSIGN
       iNumWords     = NUM-ENTRIES(cSortEntry,' ':U)
       cLastEntry    = ENTRY(iNumWords,cSortEntry,' ':U)
       cOption       = (IF cLastEntry = SUBSTR('DESCENDING':U,1,MAX(4,LENGTH(cLastEntry))) 
                        THEN 'DESCENDING':U
                        ELSE IF cLastEntry = 'TOGGLE':U 
                             THEN cLastEntry
                             ELSE '')
       .

     IF cOption > '' THEN
       ASSIGN
         ENTRY(iNumWords,cSortEntry,' ') = ''
         cColumn = RIGHT-TRIM(cSortEntry).
     ELSE
       cColumn = cSortEntry.

     cColumn = {fnarg resolveColumn cColumn}.

     /* loop 1 is for new sort loop 2 for old sort */
     CASE iCase:
       WHEN 1 THEN
         ASSIGN 
           cNewColumn[iNum] = cColumn
           cNewOption[iNum] = cOption
           iNewEntries      = iNum.
       WHEN 2 THEN
         ASSIGN 
           cOldColumn[iNum] = cColumn
           cOldOption[iNum] = cOption
           iOldEntries      = iNum.
     END CASE.
   END. /* do while cSort > '' */   
 END. /* do icase = 1 to 2 */
 
 IF iOldEntries <> iNewEntries THEN
   lDiffColumns = TRUE.

 DO iNum = 1 TO iNewEntries:
   /* Keep track of whether the old sort criteria is the same as the new.
      This is a requirement for 'toggle' and is also used to avoid 
      server hit if the same sort criteria. (the query stays unchanged also 
      if qualifications does not match and stops resortQuery from resorting)
      We do not need to check this any more if an option already is toggled.*/ 
   IF NOT lDiffColumns AND NOT lToggled THEN
   DO:
     IF cOldColumn[iNum] = '':U THEN
       lDiffColumns = TRUE.
     ELSE IF cNewColumn[iNum] <> cOldColumn[iNum] THEN
       lDiffColumns = TRUE.
   END. /* NOT diff and NOT toggled */
   
   /* If sort option is toggle then swap descending/blank */
   IF cNewOption[iNum] = 'TOGGLE':U THEN
   DO:
     /* if already toggled or lDiffColumns (See above) ignore toggle  */
     IF lToggled OR lDiffColumns THEN
        cNewOption[iNum] = '':U.
     ELSE
     DO:
       IF cOldOption[iNum] = 'DESCENDING':U THEN
         cNewOption[iNum] = '':U.
       ELSE 
         cNewOption[iNum] = 'DESCENDING':U.
            /* We only support one toggling. */
       lToggled = TRUE.
     END.
   END. /* newoption[iNew] = toggle */
        
   /* if not toggled we must also include the sort option in the check
      of different sort (if same and not toggled we don't apply any sort at all) */
   IF NOT lToggled AND cOldOption[iNum] <> cNewOption[iNum] THEN
     lDiffColumns = TRUE.

   cNewSort = TRIM(cNewSort 
                    + " BY ":U 
                    + cNewColumn[iNum]
                    + ' ':U
                    + cNewOption[iNum]).
 END. /* iNum = 1 TO iNewEntries*/
 
 /* Skip sort if Same as old unless a sort option was toggled */ 
 IF lDiffColumns OR lToggled THEN
   ASSIGN          /* check for  indexed-reposition  */
      iIdxPos = INDEX(RIGHT-TRIM(pcQuery,". ") + " ":U,
                      " INDEXED-REPOSITION ":U)          
    
      /* If no INDEX-REPOSITION is found, set the iLength (where to end insert)
         to the end of where-clause. (right-trim periods and blanks to find 
         the true end of the expression) Otherwise iLength is the position of 
         INDEX-REPOSITION. */
      iLength = (IF iIdxPos = 0 
                 THEN LENGTH(RIGHT-TRIM(pcQuery,". ":U)) + 1     
                 ELSE iIdxPos)    
          
      /* Any By ? */ 
      iByPos  = INDEX(pcQuery," BY ":U)                   
      /* Now find where we should start the insert; 
         We might have both a BY and an INDEXED-REPOSITION or only one of them 
         or none. So we make sure we use the MINIMUM of whichever of those 
         unless they are 0. */
      iByPos  = MIN(IF iByPos  = 0 THEN iLength ELSE iByPos,
                    IF iIdxPos = 0 THEN iLength ELSE iIdxPos) 
          
      SUBSTR(pcQuery,iByPos,iLength - iByPos) = IF cNewSort <> '':U 
                                                THEN " ":U + cNewSort
                                                ELSE "":U.  
    
 RETURN pcQuery. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-newQueryString) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION newQueryString Procedure 
FUNCTION newQueryString RETURNS CHARACTER
  (pcColumns     AS CHARACTER,   
   pcValues      AS CHARACTER,    
   pcOperators   AS CHARACTER,
   pcQueryString AS CHARACTER,
   pcAndOr       AS CHARACTER):
/*------------------------------------------------------------------------------   
   Purpose: Returns a new query string to the passed query. 
            The tables in the passed query must match getTables().  
            Adds column/value pairs to the corresponding buffer's where-clause. 
            Each buffer's expression will always be embedded in parenthesis.
   Parameters: 
     pcColumns   - Qualified column names (Comma separated)                    
     pcValues    - corresponding Values (CHR(1) separated)
     pcOperators - Operator - one for all columns
                              - blank - defaults to (EQ)  
                              - Use slash to define alternative string operator
                                EQ/BEGINS etc..
                            - comma separated for each column/value
     pcQueryString - A complete querystring matching the queries tables.
                     MUST be qualifed correctly.
                     ? - use the existing query  
     pcAndOr       - AND or OR decides how the new expression is appended to 
                     the passed query (for each buffer!).                                               
   Notes:  This is basically the same logic as assignQuerySelection, but 
           without the replace functionality.
         - The alternative string operator is not supported before the object 
           is initialized. (datatype is not known)     
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cBufferList    AS CHAR       NO-UNDO.
  DEFINE VARIABLE cBuffer        AS CHARACTER  NO-UNDO.
  
  /* We need the columns name and the parts */  
  DEFINE VARIABLE cColumn        AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cOperator      AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cValue         AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE iColumn        AS INTEGER    NO-UNDO.
  DEFINE VARIABLE iBuffer        AS INTEGER    NO-UNDO.
  
  DEFINE VARIABLE cUsedNums      AS CHAR       NO-UNDO.
  
  /* Used to builds the column/value string expression */
  DEFINE VARIABLE cBufWhere      AS CHARACTER  NO-UNDO.
                    
  {get QueryTables cBufferList}.    
   
  /* If unkown value is passed used the existing query string */
  IF pcQueryString = ? THEN
  DO:
    {get QueryString pcQueryString}.      
    /* If no QueryString find the current query */ 
    IF pcQueryString = "":U OR pcQueryString = ? THEN
      {get QueryStringDefault pcQueryString}.    
  END. /* pcQueryString = ? */

  IF pcAndOr = "":U OR pcAndOr = ? THEN pcAndOr = "AND":U.   
  
  DO iBuffer = 1 TO NUM-ENTRIES(cBufferList):  
    ASSIGN
      cBufWhere      = "":U
      cBuffer        = ENTRY(iBuffer,cBufferList).
      
    ColumnLoop:    
    DO iColumn = 1 TO NUM-ENTRIES(pcColumns):             
      
      IF CAN-DO(cUsedNums,STRING(iColumn)) THEN 
        NEXT ColumnLoop.      
      /* get the column, operator and correctly quoted value from the lists 
         if it maps to this buffer. */  
      RUN obtainExpressionEntries IN TARGET-PROCEDURE
                         (cBuffer,
                          iColumn,
                          pcColumns,
                          pcValues,
                          pcOperators,
                          OUTPUT cColumn, 
                          OUTPUT cOperator,
                          OUTPUT cValue).
      IF cColumn = '':U THEN
        NEXT.
      ASSIGN
        cUsedNums  = cUsedNums
                   + (IF cUsedNums = "":U THEN "":U ELSE ",":U)
                   + STRING(iColumn).
        cBufWhere  = cBufWhere 
                   + (If cBufWhere = "":U 
                      THEN "":U 
                      ELSE " ":U + "AND":U + " ":U)
                   + cColumn 
                   + " ":U
                   + cOperator
                   + " ":U
                   + cValue.
    END. /* do iColumn = 1 to num-entries(pColumns) */    
    
    /* We have a new expression */                               
    IF cBufWhere <> "":U THEN
      ASSIGN 
        pcQueryString = DYNAMIC-FUNCTION('newWhereClause':U IN TARGET-PROCEDURE,
                                          cBuffer,
                                          cBufWhere,
                                          pcQueryString,
                                          pcAndOr).  

  END. /* do iBuffer = 1 to hQuery:num-buffers */
  RETURN pcQueryString.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-newWhereClause) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION newWhereClause Procedure 
FUNCTION newWhereClause RETURNS CHARACTER
  (pcBuffer     AS CHAR,   
   pcExpression AS char,  
   pcWhere      AS CHAR,
   pcAndOr      AS CHAR):
/*------------------------------------------------------------------------------
  Purpose:     Inserts a new expression to query's prepare string for a 
               specified buffer.
  Parameters:  pcBuffer     - Buffer.  
               pcExpression - The new expression. 
               pcWhere      - The current query prepare string.
               pcAndOr      - Specifies what operator is used to add the new
                              expression to existing expression(s)
                              - AND (default) 
                              - OR                                                
  Notes:       This is supported as a 'utility function' that doesn't use any 
               properties. However, if target-procedure = super the passed 
               buffer's qualification MUST match the query's. 
               If target-procedure <> super the buffer will be corrected IF 
               it exists in the object's query, otherwise it needs to match 
------------------------------------------------------------------------------*/
 DEFINE VARIABLE iStart      AS INT    NO-UNDO.
 DEFINE VARIABLE iLength     AS INT    NO-UNDO.
 DEFINE VARIABLE cBufferWhere AS CHAR   NO-UNDO.

 /* Find the buffer's 'expression-entry' in the query */
 cBufferWhere = DYNAMIC-FUNCTION('bufferWhereClause':U IN TARGET-PROCEDURE,
                                 pcBuffer,
                                 pcWhere).
 
 /* if we found it, replace it with itself with the new expression inserted */
 IF cBufferWhere <> '':U THEN
   ASSIGN
     iStart  = INDEX(pcWhere,cBufferWhere)
     iLength = LENGTH(cBufferWhere)
     SUBSTR(pcWhere,iStart,iLength) = 
               DYNAMIC-FUNCTION('insertExpression':U IN TARGET-PROCEDURE,
                                 cBufferWhere,
                                 pcExpression,
                                 pcAndOr).           
 RETURN pcWhere.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-obtainContextForServer) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION obtainContextForServer Procedure 
FUNCTION obtainContextForServer RETURNS CHARACTER
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: Return context to pass to the server 
    Notes: No default contrext. 
------------------------------------------------------------------------------*/

  RETURN ''.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-openDataQuery) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION openDataQuery Procedure 
FUNCTION openDataQuery RETURNS LOGICAL
  (pcPosition AS CHAR):
/*------------------------------------------------------------------------------
   Purpose: Open the DataQuery  
Parameters: pcPosition - 
                     First  
                     Last   
                     WHERE <criteria>
                     <criteria>  (with ' ' or '=')
                     string(Rowid)   
               internal use only (see comments in retrieveBatch):              
                     NEXT    
                     PREV    
     Notes:  This function is responsible for keeping track of which record
             is first and last on the client and whether these also are 
             first and last of the complete result set. 
------------------------------------------------------------------------------*/
 DEFINE VARIABLE hDataQuery       AS HANDLE     NO-UNDO.
 DEFINE VARIABLE cQuery           AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE cAsDivision      AS CHARACTER  NO-UNDO.
 DEFINE VARIABLE iLastRownum      AS INTEGER    NO-UNDO.
 DEFINE VARIABLE iFirstRownum     AS INTEGER    NO-UNDO.
 DEFINE VARIABLE hRowObject       AS HANDLE     NO-UNDO.
 DEFINE VARIABLE lHasFirst        AS LOGICAL    NO-UNDO.
 DEFINE VARIABLE lHasLast         AS LOGICAL    NO-UNDO.
 DEFINE VARIABLE iLoop            AS INTEGER    NO-UNDO.         
 DEFINE VARIABLE lok              AS LOGICAL    NO-UNDO.
 DEFINE VARIABLE lWhere           AS LOGICAL    NO-UNDO.

 &SCOPED-DEFINE xp-assign
 {get DataHandle hDataQuery}
 {get QueryString cQuery}  
 {get HasFirst lHasFirst}
 {get HasLast lHasLast}
 /* we turn this on allways as it is used as a flag to prevent dataAvailable 
    untill an explicit open or find  */ 
 {set OpenOnInit TRUE}.
  .
 &UNDEFINE xp-assign
 
 IF NOT lHasFirst THEN 
   {set FirstRowNum ?}. 

 IF NOT lHasLast THEN
   {set LastRowNum ?}. 
 
 IF VALID-HANDLE(hDataQuery) THEN
 DO:
   /* query-prepare empties browse even if it is set to not refreshable, so avoid
      if not necessary */
   IF cQuery = '' THEN
   DO:
     cQuery = {fn getQueryStringDefault}.
     {set QueryString cQuery}.
   END.

   IF cQuery <> hDataQuery:PREPARE-STRING THEN
     hDataQuery:QUERY-PREPARE(cQuery).

   hRowObject = hDataQuery:GET-BUFFER-HANDLE(1).
   
   hDataQuery:QUERY-OPEN().
   
   /* We need both first and last info so we do two positioning passes in order
      to do GET-LAST last if "LAST" is requested and do the GET-LAST first if
      it's not */
   DO iLoop = 1 TO 2:
     
     IF (pcPosition <> 'LAST':U AND iLoop = 1 AND lHasLast)
     OR (pcPosition =  'LAST':U AND iLoop = 2) THEN
     DO:
       hDataQuery:GET-LAST().
       IF lHasLast THEN
         {set LastRowNum INT(hRowObject:RECID)}.
     END.

     IF iLoop = 1 THEN
     DO:
       hDataQuery:GET-FIRST().
       IF NOT hRowObject:AVAIL THEN
       DO:
         /* get-last is not safe with outer join (if we want to support it) */
         {set FirstRowNum 0}.
         {set LastRowNum 0}.
       END.
       ELSE
       IF lHasFirst THEN
         {set FirstRowNum INT(hRowObject:RECID)}.
  
       IF pcPosition = 'FIRST':U THEN
         LEAVE.
       ELSE 
       IF pcPosition <> '':U AND pcPosition <> ? AND pcPosition <> 'LAST'  THEN
       DO:
         /* ensure reposition returns true also if searched record is current*/
         hRowObject:BUFFER-RELEASE().
         IF pcPosition BEGINS 'WHERE ':U THEN
           lWhere = TRUE.
         ELSE IF INDEX(pcPosition,' ') > 0 OR INDEX(pcPosition,'=') > 0 THEN 
           ASSIGN 
             pcPosition = 'WHERE ' + pcPosition
             lWhere     = TRUE.

         IF lWhere THEN
         DO:
           hRowObject:FIND-FIRST(pcPosition) NO-ERROR.
           /* show progress message for syntax error */
           IF ERROR-STATUS:GET-NUMBER(3) = 10041 THEN 
             MESSAGE 
               ERROR-STATUS:GET-MESSAGE(3) VIEW-AS ALERT-BOX ERROR.
           /* Synch the browse here (this is somewhat inconsistent since
              next,last request currently relies on this being done elsewhere)*/
           IF hRowObject:AVAIL THEN   
             lOk = hDataQuery:REPOSITION-TO-ROWID(hRowObject:ROWID) NO-ERROR.
         END.
         ELSE 
           lOk = hDataQuery:REPOSITION-TO-ROWID(TO-ROWID(pcPosition)) NO-ERROR.
         
         /* if not browsed reposition will make record not avail */
         IF lOk AND NOT hRowObject:avail THEN 
           hDataQuery:GET-NEXT(). 
             
         LEAVE.
       END.
     END.  /* iloop = 1 */
   END. /* iloop = 1 to 2 */

   hRowObject:TABLE-HANDLE:TRACKING-CHANGES = TRUE.
   
   /* Some visual objects that shows more than one record may need to know 
      that the query changed, this cannot be detected through the ordinary
      publish "dataAvailable" from the navigation methods. 
      The SmartSelect populates its list on this event and OCX objects
      like lists and Tree-views may also need to subscribe to this event. */
  
   PUBLISH "queryOpened":U FROM TARGET-PROCEDURE.
 END. /* valid hDataquery */
 
 RETURN IF VALID-HANDLE(hDataQuery) 
        THEN hDataQuery:IS-OPEN 
        ELSE FALSE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-openDataView) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION openDataView Procedure 
FUNCTION openDataView RETURNS LOGICAL
  (   ) :
/*------------------------------------------------------------------------------
  Purpose:  Opens the DataView on existing data.  
    Notes:  Existing data means data that already are on the client. 
            This method is an integral part of the DataView start up and
            data management, but can also be called separately to just refresh 
            or reset visual data-targets from existing data.    
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cFetchOnOpen    AS CHARACTER  NO-UNDO.
  
  {get FetchOnOpen cFetchOnOpen}.
  
  {fnarg openDataQuery cFetchOnOpen}. 

  RUN rowChanged IN TARGET-PROCEDURE('DIFFERENT':U).

  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-openQuery) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION openQuery Procedure 
FUNCTION openQuery RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:     Opens the SmartDataObject's database query based on the current 
               WHERE clause.
  
  Parameters:  <none>
------------------------------------------------------------------------------*/    
  
  DEFINE VARIABLE cFetchOnOpen    AS CHARACTER  NO-UNDO.
  {get FetchOnOpen cFetchOnOpen}.
  
  RETURN {fnarg openQueryAtPosition cFetchOnOpen}.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-openQueryAtPosition) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION openQueryAtPosition Procedure 
FUNCTION openQueryAtPosition RETURNS LOGICAL
  ( pcPosition AS CHAR  ) :
/*------------------------------------------------------------------------------
  Purpose:     Opens the query based on the current QueryString and 
               positions to the indicated row.
  
  Parameters:  pcPosition - FIRST 
                            LAST 
                            WHERE <expression>
                            
------------------------------------------------------------------------------*/    
  DEFINE VARIABLE hDataSource     AS HANDLE     NO-UNDO.
  DEFINE VARIABLE lParentOpen     AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lIsFetched      AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lOk             AS LOGICAL    NO-UNDO.

  &SCOPED-DEFINE xp-assign
  {get DataSource hDataSource}
  {get DataIsFetched lIsFetched}
  .
  &UNDEFINE xp-assign  
  
  /* Allow callers to pass expression without "WHERE"  */
  IF LOOKUP(pcPosition,'FIRST,LAST') = 0 AND NOT (pcPosition BEGINS 'WHERE') THEN
    pcPosition = 'WHERE ' + pcPosition.
  IF VALID-HANDLE(hDataSource) THEN
  DO:
    {get QueryOpen lParentOpen hDataSource}. 
    IF NOT lParentOpen THEN
      RETURN FALSE. 
    
    /* Default retrieval for child is by parent, so set to yes if unknown and
       opened  */
    IF lIsFetched = ? THEN
      {get QueryOpen lIsFetched}.

    IF lIsFetched <> TRUE THEN
    DO:
      {set DataIsFetched FALSE}.
      {fn addForeignKey}.
    END.
  END. /* valid datasource */
 
  /* If data is fetched then any query change should be resolved locally
     (ALL valid queries retrieved by parent) */
  IF lIsFetched <> TRUE THEN
    DYNAMIC-FUNCTION('retrieveData':U IN TARGET-PROCEDURE,
                     pcPosition,
                     YES, /* refresh (unconditional empty) */
                     ?). 
  
  lOk = {fnarg openDataQuery pcPosition}.
  
  RUN rowChanged IN TARGET-PROCEDURE(IF pcPosition BEGINS 'WHERE':U 
                                     THEN 'DIFFERENT':U
                                     ELSE pcPosition).
 
  RETURN lOk.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-refreshQuery) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION refreshQuery Procedure 
FUNCTION refreshQuery RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: Refresh the current query 
    Notes: This is a refresh of the current query, so a never opened or closed 
           query will not be refreshed by this. 
         - Currently refreshes all dependant child queries.  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cKeyWhere AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE lOpen     AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lOk       AS LOGICAL    NO-UNDO.
 
  &SCOPED-DEFINE xp-assign  
  {get KeyWhere cKeyWhere}
  {get QueryOpen lOpen}
  .
  &UNDEFINE xp-assign
  
  /* A never opened or closed query cannot be refreshed */ 
  IF NOT lOpen THEN 
    RETURN FALSE.

  lOk = {fnarg openQueryAtPosition cKeywhere}.  
  IF NOT lOk THEN
    RUN fetchFirst IN TARGET-PROCEDURE.

  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-removeDatasetClone) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION removeDatasetClone Procedure 
FUNCTION removeDatasetClone RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose:  
    Notes:  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hDatasetSource AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hDataContainer AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cNewName       AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hBuffer        AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cDataTable     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cTables        AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hDataHandle    AS HANDLE     NO-UNDO.
  DEFINE VARIABLE iTable         AS INTEGER    NO-UNDO.
  DEFINE VARIABLE hChild         AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cChild         AS CHARACTER  NO-UNDO.

  {get DatasetSource hDatasetSource}.
  {get DataTable cDataTable}.

  IF VALID-HANDLE(hDatasetSource) THEN
  DO:
    {get DataContainerHandle hDataContainer}.

    cNewName = {fnarg originDataset hDatasetSource hDataContainer}.

    IF cNewName > '' THEN
    DO:
      {fnarg destroyDataset hDatasetSource hDataContainer}. 
      {set DatasetName cNewName}.
      {fn addDatasetSource}.
      {get DatasetSource hDatasetSource}.
      IF VALID-HANDLE(hDatasetSource) THEN
      DO:
        hBuffer  = {fnarg dataTableHandle cDataTable hDatasetSource}.
        {set RowObject hBuffer}.
      END.
    END.
  END.

  IF VALID-HANDLE(hBuffer) THEN
  DO:
    {get QueryTables cTables}.
    {get DataHandle hDataHandle}.
    hDataHandle:SET-BUFFERS(hBuffer).
    DO iTable = 2 TO NUM-ENTRIES(cTables):
      ASSIGN
        cChild = ENTRY(iTable,cTables)
        hChild = {fnarg dataTableHandle cChild hDatasetSource}
        .
      IF VALID-HANDLE(hChild) THEN
      DO:
        hDataHandle:ADD-BUFFER(hChild).
      END. 
    END.
    RETURN TRUE.
  END.

  RETURN FALSE. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-removeForeignKey) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION removeForeignKey Procedure 
FUNCTION removeForeignKey RETURNS LOGICAL
  ( ) :
/*------------------------------------------------------------------------------
  Purpose: Remove the ForeignKey from the query string. 
    Notes: The ForeignKey consists of ForeignKeys and ForeignValues. 
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cLocalFields   AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cForeignFields AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cForeignValues AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cQueryString   AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE iField         AS INTEGER    NO-UNDO.

  &SCOPED-DEFINE xp-assign
  {get ForeignValues cForeignValues}
  {get ForeignFields cForeignFields}.
  &UNDEFINE xp-assign
  
  /* 1st of each pair is local db query fld  */
  DO iField = 1 TO NUM-ENTRIES(cForeignFields) BY 2:
    cLocalFields = cLocalFields +  
      (IF cLocalFields NE "":U THEN ",":U ELSE "":U)
        + ENTRY(iField, cForeignFields).
  END. /*  DO iField -- find list of local part of Foreign Fields */  

  {set ForeignValues ?}.

  RETURN DYNAMIC-FUNCTION('removeQuerySelection':U IN TARGET-PROCEDURE,
                           cLocalFields,
                           '=':U).
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-removeQuerySelection) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION removeQuerySelection Procedure 
FUNCTION removeQuerySelection RETURNS LOGICAL
  (pcColumns   AS CHARACTER,
   pcOperators AS CHARACTER):
/*------------------------------------------------------------------------------
  Purpose:     Remove field expression(s) for specified column(s) and operator(s) 
               added by assignQuerySelection from the query. 
  Parameters: 
     pcColumns   - Column names (Comma separated)                    
     pcOperators - Operator - one for all columns
                              - blank - defaults to (EQ)  
                              - Use slash to define alternative string operator
                                EQ/BEGINS etc..
                            - comma separated for each column/value

  Notes:       This procedure modifies the QueryString property.               
               openQuery will prepare the query using this property.
               
               The removal of the actual field expression is done by the help 
               of the position and length stored in the QueryColumns property. 
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cQueryString   AS CHARACTER NO-UNDO.
  DEFINE VARIABLE cBufferList    AS CHARACTER NO-UNDO.
  DEFINE VARIABLE cBuffer        AS CHARACTER NO-UNDO.
  
  /* We need the columns name and the parts */  
  DEFINE VARIABLE cColumn        AS CHARACTER NO-UNDO.
  DEFINE VARIABLE cColumnName    AS CHARACTER NO-UNDO.
    
  DEFINE VARIABLE iBuffer        AS INTEGER   NO-UNDO.
  DEFINE VARIABLE iColumn        AS INTEGER   NO-UNDO.
  
  DEFINE VARIABLE cUsedNums      AS CHAR      NO-UNDO.
  
  DEFINE VARIABLE cOperator      AS CHARACTER NO-UNDO.
  DEFINE VARIABLE cStringOp      AS CHARACTER NO-UNDO.
          
  /* Used to store and maintain offset and length */    
  DEFINE VARIABLE iValLength     AS INTEGER   NO-UNDO.
  DEFINE VARIABLE iValPos        AS INTEGER   NO-UNDO.
  DEFINE VARIABLE iPos           AS INTEGER   NO-UNDO.
  DEFINE VARIABLE iDiff          AS INTEGER   NO-UNDO.
  DEFINE VARIABLE cQueryColumns  AS CHAR      NO-UNDO.
  DEFINE VARIABLE cQueryBufCols  AS CHAR      NO-UNDO.
  DEFINE VARIABLE cNewCols       AS CHAR      NO-UNDO.
  DEFINE VARIABLE cQueryColOp    AS CHAR      NO-UNDO.
  DEFINE VARIABLE cRemoveList    AS CHARACTER NO-UNDO.
  DEFINE VARIABLE iOldEntries    AS INTEGER   NO-UNDO.
  DEFINE VARIABLE iLowestChanged AS INTEGER   NO-UNDO.
  DEFINE VARIABLE iBufPos        AS INTEGER   NO-UNDO.
  DEFINE VARIABLE iColPos        AS INTEGER   NO-UNDO.
  DEFINE VARIABLE iWhereBufPos   AS INTEGER   NO-UNDO.

  DEFINE VARIABLE cQuerySplit1   AS CHARACTER NO-UNDO.
  DEFINE VARIABLE cQuerySplit2   AS CHARACTER NO-UNDO.
  DEFINE VARIABLE iNumWords      AS INTEGER   NO-UNDO.
  DEFINE VARIABLE cWord          AS CHARACTER NO-UNDO.

  &SCOPED-DEFINE xp-assign
  {get Tables cBufferList}    
  {get QueryString cQueryString}
  {get QueryColumns cQueryColumns}.
  &UNDEFINE xp-assign
    
  /* If no QueryString or QueryColumns just return now */ 
  IF cQueryString = "":U OR cQueryColumns = "":U THEN
    RETURN FALSE.
  
  DO iBuffer = 1 TO NUM-ENTRIES(cBufferList):
    ASSIGN
      cBuffer        = ENTRY(iBuffer,cBufferList)
      iBufPos        = LOOKUP(cBuffer,cQueryColumns,":":U)
      cQueryBufCols  = IF iBufPos > 0 
                       THEN ENTRY(iBufPos + 1,cQueryColumns,":":U) 
                       ELSE "":U
      iOldEntries    = NUM-ENTRIES(cQueryBufCols) / 3    
      cRemoveList    = "":U
      iLowestChanged = 0.
    
    ColumnLoop:    
    DO iColumn = 1 TO NUM-ENTRIES(pcColumns):
      IF CAN-DO(cUsedNums,STRING(iColumn)) THEN 
        NEXT ColumnLoop.      
      
      ASSIGN
        cColumn     = ENTRY(iColumn,pcColumns).
      
      /* Get the operator for this valuelist. 
         Make sure we handle '',? and '/begins' as default */                                                  
        cOperator   = IF pcOperators = "":U 
                      OR pcOperators BEGINS "/":U 
                      OR pcOperators = ?                       
                      THEN "=":U 
                      ELSE IF NUM-ENTRIES(pcOperators) = 1 
                           THEN ENTRY(1,pcOperators,"/":U)                                                 
                           ELSE ENTRY(iColumn,pcOperators).
        
      
      /* Unqualified fields will use the first buffer that has a match
         because the columnDataType below searches all buffers in the query */           
      IF INDEX(cColumn,".":U) = 0 THEN       
        cColumn = cBuffer + ".":U + cColumn.  
     
      /* Wrong buffer */
      IF NOT (cColumn BEGINS cBuffer + ".":U) THEN 
      DO: 
        /* If the column db qualification does not match the query's we do 
           an additionl check to see if it is the correct table after all */                                
        IF NUM-ENTRIES(cColumn,".":U) - NUM-ENTRIES(cBuffer,".":U) <> 1 THEN
        DO:
          IF {fnarg columnTable cColumn} <> cBuffer THEN 
            NEXT ColumnLoop.  
        END.
        ELSE
          NEXT ColumnLoop.
      END.
      ASSIGN
        cColumnName = ENTRY(NUM-ENTRIES(cColumn,".":U),cColumn,".":U)
        cQueryColOp = cOperator
        cQueryColOp = TRIM(IF cQueryColOp = "GE":U THEN ">=":U
                           ELSE IF cQueryColOp = "LE":U THEN "<=":U
                           ELSE IF cQueryColOp = "LT":U THEN "<":U
                           ELSE IF cQueryColOp = "GT":U THEN ">":U
                           ELSE IF cQueryColOp = "EQ":U THEN "=":U
                           ELSE    cQueryColOp)
      
        cStringOp   = IF NUM-ENTRIES(pcOperators) = 1 
                      AND NUM-ENTRIES(pcOperators,"/":U) = 2  
                      THEN ENTRY(2,pcOperators,"/":U)
                      ELSE "":U
       .                                                 
      
      /* First check if this was a string with stringoperator */  
      IF cStringOp <> "":U THEN  
        iPos        = LOOKUP(cColumnName + ".":U + cStringOp,cQueryBufCols).
      ELSE iPos = 0.
      
      IF iPos = 0 THEN
        iPos        = LOOKUP(cColumnName + ".":U + cQueryColOp,cQueryBufCols).
      
        /* If the column + operator was found in the list
           we build a list of the columns to remove from the QueryString further 
           down.
           We also build a list of the numbers to remove. */         
      IF iPos > 0 THEN
      DO:        
        ASSIGN
          iLowestChanged = MIN(iPos,IF iLowestChanged = 0 
                                    THEN iPos 
                                    ELSE iLowestChanged)
          cRemoveList   = cRemoveList 
                          + (IF cRemoveList = "":U THEN "":U ELSE ",":U)
                          + STRING(INT((iPos - 1) / 3 + 1))     
          cUsedNums     = cUsedNums
                          + (IF cUsedNums = "":U THEN "":U ELSE ",":U)
                          + STRING(iColumn)
          . 
     
      END. /* IF ipos > 0 */    
    END. /* do icolumn = 1 to  */ 
    
    /* Get the buffers position in the where clause (always the
       first entry in a dynamic query because there's no 'of <external>')*/ 
    ASSIGN
      iWhereBufPos = INDEX(cQueryString + " "," ":U + cBuffer + " ":U)
      iPos         = INDEX(cQueryString,      " ":U + cBuffer + ",":U)
      iWhereBufPos = (IF iWhereBufPos > 0 AND iPos > 0
                      THEN MIN(iPos,iWhereBufPos) 
                      ELSE MAX(iPos,iWhereBufPos))
                      + 1
      iDiff        = 0
      cNewCols     = "":U
      .                          
    IF iLowestChanged > 0 THEN 
    DO iColumn = 1 TO NUM-ENTRIES(cQueryBufCols) - 2 BY 3:       
      
      ASSIGN
        iValPos      = INT(ENTRY(iColumn + 1,cQueryBufCols))
        iValLength   = INT(ENTRY(iColumn + 2,cQueryBufCols))
        iValPos      = iValPos - iDiff
        .
      /* Remove value, operator, columnname and eventual AND in the
         parenthesized expression. If it's the last expression in the parenthesis
         we also remove it and any AND/OR after or WHERE/AND/OR before. */
           
      IF CAN-DO(cRemoveList,STRING(INT((iColumn - 1) / 3 + 1))) THEN       
      DO:
         ASSIGN 
          /*Split query in two, remove value quotes and blanks */
          cQuerySplit1 = 
     RIGHT-TRIM(SUBSTR(cQueryString,1,iValPos + iWhereBufPos - 1)," '~"":U) 
          cQuerySplit2 =
     LEFT-TRIM(SUBSTR(cQueryString,iValPos + iWhereBufPos + iVallength)," '~"":U) 

          /* Count words in left part */
          iNumWords   = NUM-ENTRIES(cQuerySplit1," ":U)
         
          /* Remove Operator */ 
          ENTRY(iNumWords,cQuerySplit1," ":U) = "":U
           
          cQuerySplit1 = RIGHT-TRIM(cQuerySplit1," ":U)
          
          /* find columnname */
          cWord       = ENTRY(iNumWords - 1,cQuerySplit1," ":U)
          .

         /* if columnname has parenthesis this is the beginning of an exp */
         IF cWord BEGINS "(":U THEN
         DO:
           /* We are removing the first column/value pair in the parenthesis*/
           IF cQuerySplit2 BEGINS "AND":U THEN
           DO:
             ASSIGN
               /* Remove the previous word (columnname), but keep parenthesis */
               ENTRY(iNumWords - 1,cQuerySplit1," ":U) = "(":U
               /* Remove AND in right part */
               ENTRY(1,cQuerySplit2," ":U) = "":U
               cQuerySplit2 = LEFT-TRIM(cQuerySplit2," ":U)
               .
           END.  /* if cquerysplit2 begins and */
           ELSE IF cQuerySplit2 BEGINS ")":U THEN
           DO:
             ASSIGN
               /* Remove columnname and parenthesises around the expression */
               ENTRY(iNumWords - 1,cQuerySplit1," ":U) = "":U
               cQuerySplit1 = RIGHT-TRIM(cQuerySplit1," ":U)
               cQuerySplit2 = LEFT-TRIM(SUBSTR(cQuerySplit2,2)," ":U)
               cWord = ENTRY(iNumWords - 2,cQuerySplit1," ":U).
     
             /* Now remove AND or OR used to join an eventual expression */ 
             IF cQuerySplit2 BEGINS "AND ":U OR cQuerySplit2 BEGINS "OR ":U THEN
               ENTRY(1,cQuerySplit2," ":U) = "":U.
             
             /* There were no and after, so remove WHERE,AND or OR before */  
             ELSE IF CAN-DO("WHERE,AND,OR":U,cWord) THEN
               ENTRY(iNumWords - 2,cQuerySplit1," ":U) = "":U.                                  
             
             /* No where/and/or or and/or removed so add a blank before we join
                the splitted query  */
             ELSE cQuerySplit2 = " ":U + cQuerySplit2.
           
           END.             
         END. /* word begins '(' */ 
         ELSE 
         DO: 
           ASSIGN
             /* Now remove the prev word (columnname) */
             ENTRY(iNumWords - 1,cQuerySplit1," ":U) = "":U
             /* Remove blanks in order to find the prev word */
             cQuerySplit1 = RIGHT-TRIM(cQuerySplit1," ":U)
             /* Now remove AND */
             ENTRY(iNumWords - 2,cQuerySplit1," ":U) = "":U
             .          
           
           /* If we removed the last column/value pair,
              we leave no space between the parenthesis */
           IF cQuerySplit2 BEGINS ")":U THEN 
             cQuerySplit1 = RIGHT-TRIM(cQuerySplit1).  
         END. 
         ASSIGN
           /* Keep track of shrinkage */          
           iDiff = iDiff + (LENGTH(cQueryString) 
                         - LENGTH(cQuerySplit1 + cQuerySplit2))         
           cQueryString = cQuerySplit1 + cQuerySplit2
           .  
      END. /* if can-do(cRemoveList,... */       
      
      ELSE  /* not removed, store the position adjusted for shrinkage  */
        cNewCols = cNewCols 
                   + (IF cNewCols = "":U THEN "":U ELSE ",":U)
                   + ENTRY(icolumn,cQueryBufCols)
                   + ",":U
                   + STRING(iValPos)
                   + ",":U
                   + (ENTRY(iColumn + 2,cQueryBufCols)).
    
    END. /* else if ilowestchanged do icolumn = ilowestChanged to num-entries */  
    
    IF cNewCols <> "" THEN 
    DO:
      ENTRY(iBufPos + 1,cQueryColumns,":":U) = cNewCols.        
    END.
    ELSE IF iLowestChanged > 0 THEN
      ASSIGN
        ENTRY(iBufPos,cQueryColumns,":":U) = "":U
        ENTRY(iBufPos + 1,cQueryColumns,":":U) = "":U
        cQueryColumns = TRIM(REPLACE(cQueryColumns,":::":U,":":U),":":U).
  END.  
  
  &SCOPED-DEFINE xp-assign
  {set QueryColumns cQueryColumns}
  {set QueryString cQueryString}.
  &UNDEFINE xp-assign
  
  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-repositionRowObject) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION repositionRowObject Procedure 
FUNCTION repositionRowObject RETURNS LOGICAL
     ( pcRowIdent AS CHARACTER ):
 /*------------------------------------------------------------------------------
  Purpose:     Procedure to reposition the current rowobject record
               to the correct one. Used during updates to get around issues
               where the user has navigated to a different record in the
               SDO prior to pressing save.
  Parameters:  input rowident
  Notes:       We need to use entry 1 of the rowident which is the rowid of
               the rowobject temp-table record.
               This is NOT using reposition because we do not want the browser
               to reposition.
            -  This function is called from datavis objects as pointed out as the 
               purpose for this, but a datasource cannot be navigated to a 
               different record than its updatesource while the updatesource is 
               active. A hidden deactivated datatarget will synchronize to the 
               datasource when it becomes unhidden.         , 
               The function should thus ideally be removed, but the call may 
               give protection if the underlying temp-table is navigated without 
               using adm2 methods (or with this method....). 
             - The method should not be used standalone as it may cause the 
               very same problem that it is fixing as it does not signal any
               rowchange and assumes that it is called in a context where the 
               record that is being positioned to will be properly handled.
               (not to mention the record that is being positioned from..)  
             History:   
               It was added as part of the data class in Dynamics at a time 
               (9.1B - 9.1C) when SDOs sometimes did loose available record and 
               Dynamics supported link deactivation/activation that allowed 
               several viewers to share the source. (not supported now)
             Future:
               Multiple views of the same datasource may be implemented, but 
               hopefully without forcing the targets to reposition the source 
               before an update or cancel. (but rather as part of ) 
------------------------------------------------------------------------------*/
 DEFINE VARIABLE hRowObject AS HANDLE NO-UNDO.
 DEFINE VARIABLE rRowid     AS ROWID  NO-UNDO.
 
 {get RowObject hRowObject}.
 hRowObject:FIND-BY-ROWID(TO-ROWID(pcRowident)) NO-ERROR.
 /*
 IF hRowObject:KEYS = 'rowid':U THEN
   hRowObject:FIND-BY-ROWID(TO-ROWID(pcRowident)) NO-ERROR.
 ELSE
   hRowObject:FIND-UNIQUE('WHERE ':U 
                          + DYNAMIC-FUNCTION('keyWhere':U IN TARGET-PROCEDURE,
                                             hRowObject,
                                             hRowObject:NAME)
                          ) NO-ERROR.
 */
 RETURN VALID-HANDLE(hRowObject) AND hRowObject:AVAILABLE.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-resetQueryString) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION resetQueryString Procedure 
FUNCTION resetQueryString RETURNS LOGICAL
  (   ) :
/*------------------------------------------------------------------------------
  Purpose: Removes all filter and sort criteria from the querystring   
    Notes:  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cDefault AS CHARACTER  NO-UNDO.
  
  &SCOPED-DEFINE xp-assign
  {get QueryStringDefault cDefault}
  {set QueryString cDefault}
  {set QueryColumns '':U}
  .
  &UNDEFINE xp-assign
  
  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-resetRow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION resetRow Procedure 
FUNCTION resetRow RETURNS LOGICAL
  ( pcRowident AS CHAR ) :
/*------------------------------------------------------------------------------
  Purpose: Reset the specified rowobject record
          (to a state of unmodified from state modified in visual data target)   
Parameter: pcRowident 
               - Rowobject rowid 
               - ?  will reset current.    
    Notes: This is used to reset current row from a visual object's resetRecord. 
           The data class has logic to deal with rowobjupd records from failed 
           commits in the data class, the dataview rolls back immediately on
           failed submit. 
         Future (discussion)  
         - The setting of DataModified is a step towards removing the need to 
           call updateState after update from visual objects.  
         - But we may also want to remove DataModified completely from 
           data/dataview  as this is a state that can be detected from targets.   
------------------------------------------------------------------------------*/
  DEFINE VARIABLE lAutoCommit      AS LOGICAL  NO-UNDO.
  DEFINE VARIABLE hContainerSource AS HANDLE   NO-UNDO.
  
  IF {fnarg repositionRowobject pcRowident} THEN
  DO:
    {set DataModified FALSE}.
  END.

  RETURN TRUE. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-resolveBuffer) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION resolveBuffer Procedure 
FUNCTION resolveBuffer RETURNS CHARACTER
  ( pcBuffer AS CHAR ) :
/*------------------------------------------------------------------------------
  Purpose: Interface for generic query processing  
    Notes: Used by generic query processing that originally was implemented 
           in the query class and worked on database queries and now have been 
           moved up to the dataview class to also handle temp-table and 
           prodataset queries.              
------------------------------------------------------------------------------*/

  RETURN  pcBuffer.    

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-resolveColumn) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION resolveColumn Procedure 
FUNCTION resolveColumn RETURNS CHARACTER
  ( pcColumn AS CHAR ) :
/*------------------------------------------------------------------------------
  Purpose: Resolve column reference for query manipulation APIs 
    Notes: Qualifies unqualified columns or replaces 'RowObject' qualifier 
           with DataTable.  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cDataTable        AS CHARACTER  NO-UNDO.
  
  IF NUM-ENTRIES(pcColumn,'.':U) = 1 THEN 
  DO:
    {get DataTable cDataTable}. 
    pcColumn = cDataTable + '.':U + pcColumn.
  END.
  ELSE IF ENTRY(1,pcColumn,'.') = 'RowObject':U THEN
  DO:
    {get DataTable cDataTable}. 
    ENTRY(1,pcColumn,'.':U) = cDataTable.
  END.

  RETURN pcColumn.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-resortQuery) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION resortQuery Procedure 
FUNCTION resortQuery RETURNS LOGICAL
  ( pcSort AS CHARACTER  ) :
/*------------------------------------------------------------------------------
  Purpose: Resorts the current query  
Parameter: pcSort - sort expression 
                    (see setQuerySort for details)
                  - Blank is remove all sort 
                  - ?  reset to default.  
    Notes: if the query is closed the passed sort expression will be stored
           in the QueryString.    
          - SOrts locally,..... 
------------------------------------------------------------------------------*/
  DEFINE VARIABLE lOpen          AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cRowIdent      AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cTargets       AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hTarget        AS HANDLE     NO-UNDO.
  DEFINE VARIABLE iTarget        AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cDisabled      AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cOldSort       AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cNewSort       AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE lQueryObject   AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lDataIsFetched AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lSort          AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cKeyWhere      AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE lOk            AS LOGICAL    NO-UNDO.

  /* if the query is open open we check the current sort to avoid resorting if 
     the same sort is applied (visual objects may request a specific sort 
     at initialization)   */
  {get QueryOpen lOpen}.
  IF lOpen THEN
    {get QuerySort cOldSort}.

  /* ? is default */
  IF pcSort = ? THEN
    {get QuerySortDefault pcSort}.

  /* Store the new sort (also if not opened) */
  lSort = {set QuerySort pcSort}.

  IF lSort AND lOpen THEN
  DO:
    &SCOPED-DEFINE xp-assign 
    {get QuerySort cNewSort}
    {get KeyWhere cKeyWhere}
    .
    &UNDEFINE xp-assign

    IF cNewSort <> cOldSort AND cKeyWhere > "":U THEN
    DO:
       /* Refresh data if not all data on client 
         (no publish since we remain at same position) */
      IF {fn isDataQueryComplete} THEN 
        lOk = {fnarg openDataQuery cKeyWhere}.     
      ELSE 
      DO:
        {get DataTarget cTargets}.        
        /* We disable the data links to dataobjects as there is no need to 
           retrieve child data on the server, since we are going to end up 
           on the same record  */       
        DO iTarget = 1 TO NUM-ENTRIES(cTargets):
          hTarget = WIDGET-HANDLE(ENTRY(iTarget,cTargets)).
          IF VALID-HANDLE(hTarget) THEN
          DO:
            {get QueryObject lQueryObject hTarget}.
            IF lQueryObject THEN 
            DO:
              lDataIsFetched = FALSE.
              /* no-error for SBO (dataview to SBO is not supported,
                 but this is not the place to deal with that ) */
              {get DataIsFetched lDataIsFetched hTarget} NO-ERROR.
              IF lDataIsFetched <> TRUE THEN
              DO:
                RUN linkStateHandler IN hTarget ("inactive":U,
                                                 TARGET-PROCEDURE,
                                                 "DataSource":U).
                cDisabled = cDisabled
                          + (IF iTarget = 1 THEN '':U ELSE ',':U)
                          + STRING(hTarget).
              END.
            END. /* QueryObject*/
          END. /* valid datatarget */
        END. /* Do iTarget = 1 to NUM-ENTRIES(cTargets) */        
                
        IF cKeyWhere = ? THEN
          cKeyWhere = 'FIRST':U.

        lOk = {fnarg openQueryAtPosition cKeywhere}.  
      
        /* enable data link to targets again  */ 
        DO iTarget = 1 TO NUM-ENTRIES(cDisabled):
          hTarget = WIDGET-HANDLE(ENTRY(iTarget,cDisabled)).
          IF VALID-HANDLE(hTarget) THEN
            RUN linkStateHandler IN hTarget ("active":U,
                                             TARGET-PROCEDURE,
                                            "DataSource":U).
        END. /* do iTarget = 1 to */        
      END. /* else (do sort on server) */
      RETURN lOk.
    END. /* newsort <> oldsort and rowident > '' */

  END. /* if open */

  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-retrieveBatch) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION retrieveBatch Procedure 
FUNCTION retrieveBatch RETURNS LOGICAL
  ( pcMode AS CHAR,
    piNumRows AS INT ) :
/*------------------------------------------------------------------------------
  Purpose: Retrieve a new batch of data   
parameter: pcMode - Tells where to start retrieving in relation to current 
                    batch (and typically current record).
                    It also tells which record to position on after retrieval
                    Values:  
                    - 'NEXT'  - Retrieve next batch
                    - 'PREV'  - Retrieve prev batch
                    - 'LAST'  - Retrieve LAST batch (APPEND if not RebuildOnRepos!)
                    - 'FIRST' - Retrieve FIRST batch. Can only happen if RebuildOnRepos
                    - query expression  (forward)
        piNumRows - Number of records to retrieve 
                    Special values:
                    - ? - use RowstoBatch
                    - 0 - read all data (not already on client) 
               
    Notes: Passes FillBatch to the server/service
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cReopen    AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hQuery     AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hRowObject AS HANDLE     NO-UNDO.

  CASE pcMode:
    WHEN 'PREV':U OR WHEN 'NEXT':U THEN
    DO:
      {get DataHandle hQuery}.
      /* position to beginning/end of batch */
      IF pcMode = 'PREV':U THEN
        hQuery:GET-FIRST.
      ELSE 
        hQuery:GET-LAST.

      {get KeyWhere cReopen}.
      IF cReopen > '' THEN 
        cReopen = 'WHERE ':U + cReopen. 
    END.
    OTHERWISE 
      cReopen = pcMode.
  END.

  DYNAMIC-FUNCTION('retrieveData':U IN TARGET-PROCEDURE,pcMode,NO,piNumRows). 
    
  {fnarg openDataQuery cReopen}.
    
  /* The following will not be noticed by the browse, and is relying on the 
     calling method (fetchNext,fetchPrev) publishing dataAvailable(pcmode) to 
     synchronize the browser.
     The fetchBatch calling procedure repositions forwards/backwards to synch
     the browse instead (called from browse).
     The reposition-forward could alternatively be moved into openDataQuery 
     and removed from fetchBatch. fetchnext,fetchprev would then need to be 
     changed to run rowChanged('repositioned') */
        
  IF pcMode = 'NEXT':U THEN
    hQuery:GET-NEXT.
  ELSE IF pcMode = 'PREV':U THEN
    hQuery:GET-PREV.

  {get RowObject hRowObject}.

  RETURN hRowObject:AVAIL.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-retrieveData) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION retrieveData Procedure 
FUNCTION retrieveData RETURNS LOGICAL
  ( pcMode AS CHAR,
    plRefresh AS LOG,
    piNumRows AS INT) :
/*------------------------------------------------------------------------------
  Purpose: Retrieve  data   
parameter: pcMode - Tells where to start retrieving in relation to current 
                    batch (and typically current record).
                    Values:  
                    - 'NEXT'  - Retrieve next batch
                    - 'PREV'  - Retrieve prev batch
                    - 'LAST'  - Retrieve LAST batch 
                                  (APPEND if not RebuildOnRepos!)
                    - 'FIRST' - Retrieve FIRST batch. 
                                 Can only happen if RebuildOnRepos
                    - query expression  (forward)
        plRefresh   - Empty temp-tables even when not rebuild (append)         
        piNumRows - Number of records to retrieve 
                    Special values:
                    - ? - use RowstoBatch
                    - 0 - read all data (not already on client) 
               
    Notes: Passes FillBatch to the server/service
------------------------------------------------------------------------------*/

   DEFINE VARIABLE cEntities       AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE cEntityNames    AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE cDatasetSources AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE cDataTables     AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE cQueries        AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE cRequests       AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE cForeignFields  AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE cPositionFields AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE cBatchSizes     AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE cContext        AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE hDatasetsource  AS HANDLE     NO-UNDO.
   DEFINE VARIABLE lRebuild        AS LOGICAL    NO-UNDO.
   DEFINE VARIABLE hQuery          AS HANDLE     NO-UNDO.
   DEFINE VARIABLE cTable          AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE lFillBatch      AS LOGICAL    NO-UNDO.
   DEFINE VARIABLE lAppend         AS LOGICAL    NO-UNDO.

   DEFINE VARIABLE iChild          AS INTEGER    NO-UNDO.
   DEFINE VARIABLE hChild          AS HANDLE     NO-UNDO.
   
   DEFINE VARIABLE hDataSource     AS HANDLE     NO-UNDO.
   DEFINE VARIABLE hRequestor      AS HANDLE     NO-UNDO.
   DEFINE VARIABLE cHiddenChildren AS CHARACTER  NO-UNDO.

  &SCOPED-DEFINE xp-assign
  {get DatasetSource hDatasetSource}
  {get DataHandle hQuery}
  {get RebuildOnRepos lRebuild}
  .
  &UNDEFINE xp-assign
  
  CASE pcMode:
    WHEN 'FIRST':U THEN 
      lAppend = FALSE.

    WHEN 'LAST':U THEN
    DO:
      IF NOT lRebuild THEN
        ASSIGN
          piNumRows = 0
          lAppend = TRUE.
    END.
    WHEN 'PREV':U OR WHEN 'NEXT':U THEN
      lAppend = TRUE.         
    OTHERWISE DO:
      IF NOT lRebuild THEN
        lAppend = TRUE.
      ELSE 
        /* Rebuild position request need to know whether to fill the batch */
        {get FillBatchOnRepos lFillBatch}.
        
      IF pcMode BEGINS 'FOR ':U THEN
        pcMode = SUBSTRING(pcMode,INDEX(pcMode,' WHERE ':U) + 1).
      ELSE IF NOT TRIM(pcMode) BEGINS 'WHERE' THEN
        pcMode = 'WHERE ':U + pcMode. 
    END.
  END CASE.
  
  cHiddenChildren = {fn activateHiddenFetchChildren}.
  /* run in this to collect own data */
  RUN buildDataRequest IN TARGET-PROCEDURE
                               (INPUT TARGET-PROCEDURE,  
                                INPUT '', /* datasource*/
                                INPUT '',  /* viewersource */
                                INPUT-OUTPUT cRequests,
                                INPUT-OUTPUT cDataTables,
                                INPUT-OUTPUT cQueries,
                                INPUT-OUTPUT cBatchSizes,
                                INPUT-OUTPUT cForeignFields,
                                INPUT-OUTPUT cPositionFields,
                                INPUT-OUTPUT cContext,
                                INPUT-OUTPUT cDatasetSources,
                                INPUT-OUTPUT cEntities,
                                INPUT-OUTPUT cEntityNames).

  DO iChild = 1 TO NUM-ENTRIES(cHiddenChildren):
    hChild = WIDGET-HANDLE(ENTRY(iChild,cHiddenChildren)).
    {get DataSource hDataSource hChild}.
    RUN linkStateHandler IN hChild
                          ('INACTIVE':U,hDataSource,'DataSource':U).
  END.

  IF piNumRows = ? THEN
    {get RowsToBatch piNumRows}.

  /* could be called from initializeObject with openininit false */
  IF ENTRY(1,cRequests,CHR(1)) <> 'DEFS' THEN
    ASSIGN
      ENTRY(1,cBatchsizes)      = STRING(piNumRows)
      ENTRY(1,cRequests,CHR(1)) = pcMode.
  
  {get RequestHandle hRequestor}.
  
  RUN retrieveData IN {fn getDataContainerHandle}
                         (hRequestor,
                          plRefresh,
                          lAppend,
                          /* only set from property in one case above */
                          lFillBatch,
                          cRequests,
                          cDataTables,
                          cQueries,
                          cBatchSizes,
                          cForeignFields,
                          cPositionFields,
                          cContext,
                          cDatasetSources,
                          cEntities,
                          cEntityNames) NO-ERROR.
 
  IF ERROR-STATUS:ERROR THEN
  DO:
    MESSAGE 'Data retrieval failed.' SKIP
             IF RETURN-VALUE = '' THEN ERROR-STATUS:GET-MESSAGE(1)
             ELSE 'Error message:' + CHR(10) + RETURN-VALUE
      VIEW-AS ALERT-BOX ERROR.
    /*   RUN addmessage IN TARGET-PROCEDURE(RETURN-VALUE,?,?). */
    RETURN FALSE.
  END.
  /* startobject will applycontext after attaching dataset */ 
  IF VALID-HANDLE(hDatasetSource) THEN
  DO:
    {get DataTable cTable}.
    cContext = {fnarg tableContext cTable hDatasetSource}.
    IF cContext > '' THEN
      {fnarg applyContextFromServer cContext}.
  END.

  PUBLISH "dataRequestComplete":U FROM TARGET-PROCEDURE.
  
  RETURN TRUE. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-rowAvailable) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION rowAvailable Procedure 
FUNCTION rowAvailable RETURNS LOGICAL
  ( pcDirection  AS CHAR ) :
/*------------------------------------------------------------------------------
   Purpose: Check RowObject availability. 
            Encapsulates the different queryposition alternatives required to
            check for availability.
Parameters: pcDirection 
                   NEXT              Is there a next record available
                   PREV              Is there a prev record available
                   '', ?, or CURRENT Current record.
     Notes: This can be used in loops to simplify logic when navigating. 
            Simplifed example without dynamic-func and handles:
            -----------------------------------------                                          
            if rowAvailable('') then 
            do while true 
              run fetchNext.
              if not rowAvailable('next') then leave.  
            end.            
            ----------------------------------------
------------------------------------------------------------------------------*/
  DEFINE VARIABLE cQueryPosition AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE xcOneOrNone    AS CHARACTER  NO-UNDO
      INIT 'OnlyRecord,NoRecordAvailable,NoRecordAvailableExt':U.

  {get QueryPosition cQueryPosition}.   
  CASE pcDirection:
    WHEN 'Next':U THEN
      RETURN NOT CAN-DO('LastRecord,':U + xcOneOrNone,cQueryPosition). 
    WHEN 'Prev':U THEN
      RETURN NOT CAN-DO('FirstRecord,':U + xcOneOrNOne,cQueryPosition).
    WHEN '':U OR WHEN 'Current':U OR WHEN ? THEN 
      RETURN NOT cQueryPosition BEGINS 'NoRecord':U. 
  END CASE.

  RETURN FALSE.  
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-rowValues) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION rowValues Procedure 
FUNCTION rowValues RETURNS CHARACTER
  ( pcColumns   AS CHAR,
    pcFormat    AS CHAR,
    pcDelimiter AS CHAR) :
/*------------------------------------------------------------------------------
  Purpose: Retrieve a list of data from ALL rows in the dataobject.     
  Parameters: 
    pcColumns - Comma separated list of RowObject column names.
    pcFormat  - Formatting option
                 blank or ?   - unformatted: columnValue()  
                'Formatted'   - Formatted without trailing blanks                                     
                'TrimNumeric' - Formatted without leading spaces for
                                numeric data (left justified).     
                'NoTrim'      - Formatted with leading and trailing blanks. 
                ' &1 &2 '     - &n, where the number references the column 
                                in pcColumns order, indicates that the column 
                                values should be substituted as specified 
                                instead of returned as delimiter separated
                                values. This allows formatting data to be mixed
                                with the returned values; f.ex: '&2 (&1)', 
                                '&2 / &1'  etc.. 
                                In order to build a list-item-pair list just 
                                ensure that the delimiter is in the format;
                                F. ex: '&2 (&1)' + ',' + '&1' where ',' also 
                                is passed as delimiter would return a paired
                                list where the second item of the pair is the 
                                column number one.   
              pcDelimiter     - Single char delimiter 
                                 ?      = chr(1) ! 
                                 blank  = single space !         
              
  Notes: - This function reads all data without publishing dataAvailable to its 
           data-targets. However, if the query is browsed that will still happen 
           when reposition-to-rowid is executed to get back to the current record.                             
         - This is intended for use by the SmartSelect or other non-browser
           widgets that need to show all rows of the SDO.   
         - Should only be used with smaller amounts of records/data, as all data 
           need to fit in the character return value. The limit is in theory 32K,
           in reality somewhat smaller. The concatination of the data is 
           currently wrapped in an on stop block using no-error. The Progress 
           error message will be shown if the limit is encountered.
         - Maximum 9 columns can be passed when a substitute format is specified   
------------------------------------------------------------------------------*/ 
  DEFINE VARIABLE hDataQuery   AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hRowObject   AS HANDLE     NO-UNDO.
  DEFINE VARIABLE rRowid       AS ROWID      NO-UNDO.
  DEFINE VARIABLE iLastRowNum  AS INTEGER    NO-UNDO.
  DEFINE VARIABLE iCol         AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cValue       AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cList        AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE iReturnRows  AS INTEGER    NO-UNDO.
  DEFINE VARIABLE iLoop        AS INTEGER    NO-UNDO.
  DEFINE VARIABLE hColumnExt   AS HANDLE     NO-UNDO EXTENT 9.
  DEFINE VARIABLE cSub         AS CHARACTER  NO-UNDO EXTENT 9.
  DEFINE VARIABLE hColumn      AS HANDLE     NO-UNDO.
  DEFINE VARIABLE lSizeError   AS LOGICAL    NO-UNDO. /* if bfx size error was detected */
  DEFINE VARIABLE iNumCols     AS INTEGER    NO-UNDO.
  DEFINE VARIABLE lSubstitute  AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cSubstitute  AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cMessage     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE lRebuild     AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE iFirstRowNum AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cTable       AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cColumn      AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cColName     AS CHARACTER  NO-UNDO.
     
   /* It ain't pretty... but fast ..  
      This allows 9 fields from the buffer to be substituted without looping 
      through the fields */
   &SCOPED-DEFINE  formatvalue ~
      IF VALID-HANDLE(~{&hdl~}) ~
      THEN IF ~{&hdl~}:BUFFER-VALUE = ? THEN '?':U ~
           ELSE IF pcFormat = '' OR lSubstitute THEN ~{&hdl~}:BUFFER-VALUE ~
           ELSE IF pcformat = 'TrimNumeric':U AND CAN-DO('Decimal,Integer':U,~{&hdl~}:DATA-TYPE) ~
                THEN TRIM(~{&hdl~}:STRING-VALUE) ~
                ELSE IF pcformat = 'Formatted':U OR pcFormat = 'TrimNumeric':U ~
                     THEN RIGHT-TRIM(~{&hdl~}:STRING-VALUE) ~
                     ELSE ~{&hdl~}:STRING-VALUE ~
      ELSE ''
  &SCOPED-DEFINE hdl hColumnExt[~{&Num~}]
  
  &SCOPED-DEFINE Num 1
  &SCOPED-DEFINE formatvalue1 {&formatvalue}
  &SCOPED-DEFINE Num 2
  &SCOPED-DEFINE formatvalue2 {&formatvalue}
  &SCOPED-DEFINE Num 3
  &SCOPED-DEFINE formatvalue3 {&formatvalue}
  &SCOPED-DEFINE Num 4
  &SCOPED-DEFINE formatvalue4 {&formatvalue}
  &SCOPED-DEFINE Num 5 
  &SCOPED-DEFINE formatvalue5 {&formatvalue}
  &SCOPED-DEFINE Num 6 
  &SCOPED-DEFINE formatvalue6 {&formatvalue}
  &SCOPED-DEFINE Num 7
  &SCOPED-DEFINE formatvalue7 {&formatvalue}
  &SCOPED-DEFINE Num 8
  &SCOPED-DEFINE formatvalue8 {&formatvalue}
  &SCOPED-DEFINE Num 9
  &SCOPED-DEFINE formatvalue9 {&formatvalue}
  
  &UNDEFINE hdl
  
  /* We are not opening the query from here .. */
  {get DataHandle hDataQuery}.
  IF VALID-HANDLE(hDataQuery) AND hDataQuery:IS-OPEN THEN
  DO:
        /* ? is CHR(1) */
    IF pcDelimiter = ? THEN
      pcDelimiter = CHR(1).
    /* Ensure blank delimiter is single space */ 
    ELSE IF pcDelimiter = "":U THEN
      pcDelimiter = " ":U.

    &SCOPED-DEFINE xp-assign
    {get FirstRowNum iFirstRowNum}
    {get RowObject hRowObject}     
    {get LastRowNum iLastRowNum}
    .
    &UNDEFINE xp-assign 
    
    ASSIGN           /* if then else used as ? is allowed in format */
      lSubstitute = IF INDEX(pcFormat,'&':U) > 0 THEN TRUE ELSE FALSE  
      /* Used in WHEN, so must be set BEFORE Assign statement! */  
      iNumCols = NUM-ENTRIES(pcColumns). 
    
    IF lSubstitute AND iNumCols > 9 THEN
    DO:
      MESSAGE "The maximum number of columns that can be passed to rowValues()"
            +   " with a substitute format is 9."  
      VIEW-AS ALERT-BOX ERROR.
      RETURN ?.
    END.

    IF lSubstitute THEN 
      ASSIGN
        cSubstitute = pcFormat
        /* for default substitute we remove trailing banks in data */
        pcFormat    = 'Formatted':U.
    
    ELSE DO: 
       /* support dashes in format input parameter */
       pcFormat = REPLACE(pcformat,"-":U,"":U). 

      /* use substitute logic for any format in order to use the performance 
         preprocessor and avoid looping thru each column */   
       DO iCol = 1 TO MIN(9,iNumCols):
         cSubstitute = cSubstitute 
                     + (IF iCol = 1 THEN '' ELSE pcDelimiter)
                     +  '&':U + STRING(iCol).
       END.
    END.
    /* Maximize performance, avoid regetting dynamic buffer fields in row loop.
       (This loop is duplicated below inside the column loop for column 
        number 10 and higher )*/         
    DO iCol = 1 TO iNumCols:
      cColumn  = ENTRY(iCol,pcColumns).
      IF NUM-ENTRIES(cColumn,'.':U) > 1 THEN
        ASSIGN
          cTable   = ENTRY(1,cColumn,'.')
          cColName = ENTRY(2,cColumn,'.').
      ELSE 
        ASSIGN
          cTable   = ''  
          cColname = cColumn. 

      IF cTable = '' OR hRowObject:NAME = cTable THEN
        hColumnExt[iCol] = hRowObject:BUFFER-FIELD(cColname) NO-ERROR.  
      ELSE
        hColumnExt[iCol] = IF cTable = hRowObject:NAME 
                           THEN hRowObject:BUFFER-FIELD(cColName) 
                           ELSE {fnarg columnHandle cColumn} NO-ERROR.  
      
      IF ERROR-STATUS:GET-MESSAGE(1) > '' THEN
      DO:
        MESSAGE 
          ERROR-STATUS:GET-MESSAGE(1)
          VIEW-AS ALERT-BOX ERROR.
        RETURN ?.
      END.
      ELSE IF NOT VALID-HANDLE(hColumnExt[iCol]) THEN
      DO:
        MESSAGE 
         "Column " cColumn "not found in" {fn getObjectName} 
          VIEW-AS ALERT-BOX ERROR.
        RETURN ?.
      END.
    END. /* DO iCol = 1 TO iNumCol */

    rRowid        = hRowObject:ROWID. 
      /* Just in case the SDO is browsed, ensure refreshable is turned off */    
    PUBLISH 'fetchDataSet':U FROM TARGET-PROCEDURE ('BatchStart':U). 
    
    hDataQuery:GET-FIRST.
    IF hRowObject:AVAILABLE THEN 
    DO:
       /* We cannot call rowValues with data from the middle of the batch */
      IF iFirstRowNum = ? THEN
      DO:
        MESSAGE "The rowValues() function is being called while the first record of"
                " the result set is not present in the existing batch." skip
                IF {fn getRebuildOnRepos} 
                THEN "The RebuildOnRepos property must be FALSE in order to call rowValues()"
                   + " in an object that only has a batch of data."
                ELSE ""   
                VIEW-AS ALERT-BOX ERROR.

        RETURN ?.
      END.

      BuildBlock:
      DO iLoop = 1 TO IF iLastRowNum = ? THEN 2 ELSE 1: /* need two loops if batching */      
        IF iLoop = 2 THEN
          DYNAMIC-FUNCTION("retrieveBatch":U IN TARGET-PROCEDURE,
                           'NEXT':U,
                           0). /* all remaining data */
            
        DO WHILE hDataQuery:QUERY-OFF-END = FALSE:
  
          /* on stop undo, leave to avoid bfx error */
          DO ON STOP UNDO, LEAVE :
              /* Use local variable to avoid issues with -inp blowing up
                 the SUBSTITUTE() function.
               */
              ASSIGN cSub[1] = {&formatvalue1}
                     cSub[2] = {&formatvalue2}
                     cSub[3] = {&formatvalue3}
                     cSub[4] = {&formatvalue4}
                     cSub[5] = {&formatvalue5}.
              /* Break up assign stmt to avoind -inp errors
                 on the assign statement.
               */
              ASSIGN cSub[6] = {&formatvalue6}
                     cSub[7] = {&formatvalue7}
                     cSub[8] = {&formatvalue8}
                     cSub[9] = {&formatvalue9}.
              
              ASSIGN cList = cList + pcDelimiter
                           + SUBSTITUTE(cSubstitute,
                                        cSub[1], cSub[2], cSub[3],
                                        cSub[4], cSub[5], cSub[6],
                                        cSub[7], cSub[8], cSub[9]) NO-ERROR.
          END. /* end assign block */         
            
          IF ERROR-STATUS:ERROR THEN 
          DO:
            ASSIGN
              lSizeError = TRUE
              cMessage   = ERROR-STATUS:GET-MESSAGE(1). 
            LEAVE BuildBlock.
          END.
          
          IF iNumCols > 9 THEN
          DO iCol = 10 TO iNumCols:
            cColumn  = ENTRY(iCol,pcColumns).
            IF NUM-ENTRIES(cColumn,'.':U) > 1 THEN
              ASSIGN
                cTable   = ENTRY(1,cColumn,'.')
                cColName = ENTRY(2,cColumn,'.').
            ELSE 
              ASSIGN
                cTable   = ''  
                cColname = cColumn. 
      
            IF cTable = '' OR hRowObject:NAME = cTable THEN
              hColumnExt[iCol] = hRowObject:BUFFER-FIELD(cColname) NO-ERROR.  
            ELSE
              hColumnExt[iCol] = IF cTable = hRowObject:NAME 
                                 THEN hRowObject:BUFFER-FIELD(cColName) 
                                 ELSE {fnarg columnHandle cColumn} NO-ERROR.  
            
            IF ERROR-STATUS:GET-MESSAGE(1) > '' THEN
            DO:
              MESSAGE 
                ERROR-STATUS:GET-MESSAGE(1)
                VIEW-AS ALERT-BOX ERROR.
              RETURN ?.
            END.
            ELSE IF NOT VALID-HANDLE(hColumnExt[iCol]) THEN
            DO:
              MESSAGE 
               "Column " cColumn "not found in" {fn getObjectName} 
                VIEW-AS ALERT-BOX ERROR.
              RETURN ?.
            END.
          
            &SCOPED-DEFINE hdl hColumn
            cValue = {&formatvalue}.
            &UNDEFINE hdl 
            /* on stop undo, leave to avoid bfx error */
            DO ON STOP UNDO, LEAVE :
              ASSIGN
               cList = cList 
                     + pcDelimiter
                     + cValue NO-ERROR.
          
            END. /* end assign block */         
            
            IF ERROR-STATUS:ERROR THEN 
            DO:
              ASSIGN
                lSizeError = TRUE
                cMessage   = ERROR-STATUS:GET-MESSAGE(1). 
              LEAVE BuildBlock.
            END.
          END. /* do iCol = 9 to num-entries */         
          hDataQuery:GET-NEXT.
        END. /* BuildBlock: do while Query-off-end = false */    
      END.  /* do loop */
    END. /* if hRowObject:avail  */
    
    IF rRowid <> ? THEN
    DO:  
      hDataQuery:REPOSITION-TO-ROWID(rRowid). 
      IF NOT hRowObject:AVAILABLE THEN
        hDataQuery:GET-NEXT.
    END.

    /* In case the SDO is browsed, ensure refreshable is turned back on */    
    PUBLISH 'fetchDataSet':U FROM TARGET-PROCEDURE ('BatchEnd':U).     
  END. /* queryopen and valid */
  
  /* More than 32K in string error... */ 
  IF lSizeError THEN 
  DO:
    MESSAGE       
      cMessage SKIP
      VIEW-AS ALERT-BOX WARNING.                     

    RETURN ?.
  END.

  /* Ensure that only the first delimiter is removed; as opposed to the 
     left-trim(...,Separator). We may have space as delimiter and prepend the 
     delimiter above */
  RETURN SUBSTRING(cList,2).

  &UNDEFINE formatvalue
  &UNDEFINE formatvalue1
  &UNDEFINE formatvalue2
  &UNDEFINE formatvalue3
  &UNDEFINE formatvalue4
  &UNDEFINE formatvalue5
  &UNDEFINE formatvalue6
  &UNDEFINE formatvalue7
  &UNDEFINE formatvalue8
  &UNDEFINE formatvalue9
  &UNDEFINE num
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setAutoCommit) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setAutoCommit Procedure 
FUNCTION setAutoCommit RETURNS LOGICAL
  ( plAutoCommit AS LOGICAL ) :
/*------------------------------------------------------------------------------
  Purpose:  Sets the  flag on or off; when On, every call to submitRow
            will result in a Commit.
   Params:  plAutoCommit AS LOGICAL  -- If true,  is set On.
------------------------------------------------------------------------------*/
  &SCOPED-DEFINE xpAutoCommit
  {set AutoCommit plAutoCommit}.
  &UNDEFINE xpAutoCommit
  RETURN TRUE.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setBufferHandles) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setBufferHandles Procedure 
FUNCTION setBufferHandles RETURNS LOGICAL
  ( pcBufferHandles AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:  
    Notes:  
------------------------------------------------------------------------------*/

  &SCOPED-DEFINE xpBufferHandles
  {set BufferHandles pcBufferHandles}.
  &UNDEFINE xpBufferHandles
  
  RETURN TRUE.   /* Function return value. */

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setBusinessEntity) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setBusinessEntity Procedure 
FUNCTION setBusinessEntity RETURNS LOGICAL
  ( pcBusinessEntity AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:  
    Notes:  
------------------------------------------------------------------------------*/
  {set BusinessEntity pcBusinessEntity}.
  RETURN TRUE. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setCommitSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setCommitSource Procedure 
FUNCTION setCommitSource RETURNS LOGICAL
  ( phObject AS HANDLE ) :
/*------------------------------------------------------------------------------
  Purpose:  Sets the CommitSource link value.
   Params:  phObject AS HANDLE -- procedure handle of this object's CommitSource 
------------------------------------------------------------------------------*/

  {set CommitSource phObject}.
  RETURN TRUE.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setCommitSourceEvents) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setCommitSourceEvents Procedure 
FUNCTION setCommitSourceEvents RETURNS LOGICAL
  ( pcEvents AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:  Sets the list of events that this object wants to subscribe to
            in its Commit-Source.
   Params:  pcEvents AS CHARACTER -- list of events. Note that because it is
            a list, modifyListProperty should normally be used to add items. 
------------------------------------------------------------------------------*/

  {set CommitSourceEvents pcEvents}.
  RETURN TRUE.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setCommitTarget) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setCommitTarget Procedure 
FUNCTION setCommitTarget RETURNS LOGICAL
  ( pcObject AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:  Sets the CommitTarget link value.
   Params:  pcObject AS CHARACTER -- string form of procedure handle of this
              object's CommitTarget
------------------------------------------------------------------------------*/

  {set CommitTarget pcObject}.
  RETURN TRUE.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setCommitTargetEvents) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setCommitTargetEvents Procedure 
FUNCTION setCommitTargetEvents RETURNS LOGICAL
  ( pcEvents AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:  Sets the list of events that this object wants to subscribe to
            in its Commit-Target.
   Params:  pcEvents AS CHARACTER -- list of events. Note that because it is
            a list, modifyListProperty should normally be used to add items. 
------------------------------------------------------------------------------*/

  {set CommitTargetEvents pcEvents}.
  RETURN TRUE.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setCurrentUpdateSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setCurrentUpdateSource Procedure 
FUNCTION setCurrentUpdateSource RETURNS LOGICAL
( phSource AS HANDLE ) :
/*------------------------------------------------------------------------------
  Purpose:  Set the current updateSource 
    Notes:  This is just set temporarily in updateState before re-publishing 
            updateState, so that the updateSource/DataTarget can avoid a 
            republish when it is the original publisher.
------------------------------------------------------------------------------*/
  {set CurrentUpdateSource phSource}.
  RETURN TRUE.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setDataColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setDataColumns Procedure 
FUNCTION setDataColumns RETURNS LOGICAL
  ( pcColumns AS CHAR) :
/*------------------------------------------------------------------------------
  Purpose:     Sets the comma-delimited list of the columnNames for the 
               SmartDataObject. 
  Parameters:  
       Notes:   
------------------------------------------------------------------------------*/
  IF pcColumns = '':U THEN
     RETURN FALSE.

  {set DataColumns pcColumns}.
  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setDataIsFetched) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setDataIsFetched Procedure 
FUNCTION setDataIsFetched RETURNS LOGICAL
  ( plFetched AS LOG) :
/*------------------------------------------------------------------------------
 Purpose: Set to tell whether data for the query is or was fetched by parent.
   Notes: See details in getDataIsFetched  
------------------------------------------------------------------------------*/
  {set DataIsFetched plFetched}.
  
  RETURN TRUE.   

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setDataModified) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setDataModified Procedure 
FUNCTION setDataModified RETURNS LOGICAL
  ( plDataModified AS LOGICAL ) :
/*------------------------------------------------------------------------------
  Purpose: Backwards compatibility only to avoid error messages
    Notes:  
------------------------------------------------------------------------------*/
  &SCOPED-DEFINE xpDataModified
  {set DataModified plDataModified}.
  &UNDEFINE xpDataModified
  
  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setDataQueryBrowsed) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setDataQueryBrowsed Procedure 
FUNCTION setDataQueryBrowsed RETURNS LOGICAL
  ( plBrowsed AS LOGICAL ) :
/*------------------------------------------------------------------------------
  Purpose:     Sets a property flag indicating that this object's DataQuery
               is being browsed by a SmartDataBrowser.
 
  Parameters:
    INPUT plBrowsed - True if a SmartDataBrowser uses this SmartDataObject
                      as a Data-Source.
    
  Notes:       This is set by a SmartDataBrowser which is a Data-Target.
               The property is used to prevent multiple SmartDataBrowsers 
               from attempting to browse the same query, which is not 
               allowed.
------------------------------------------------------------------------------*/

  DEFINE VARIABLE lAlreadyBrowsed AS LOGICAL NO-UNDO.
  
  &SCOPED-DEFINE xpDataQueryBrowsed
  {get DataQueryBrowsed lAlreadyBrowsed}.
  &UNDEFINE xpDataQueryBrowsed

  IF plBrowsed AND lAlreadyBrowsed THEN 
    RETURN FALSE.

  &SCOPED-DEFINE xpDataQueryBrowsed
  {set DataQueryBrowsed plBrowsed}.
  &UNDEFINE xpDataQueryBrowsed

  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setDataQueryString) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setDataQueryString Procedure 
FUNCTION setDataQueryString RETURNS LOGICAL
  (pcQueryString AS CHARACTER) :
/*------------------------------------------------------------------------------
  Purpose:  Sets the string used to prepare the RowObject query  
    Notes:  This is set in data.i's Main block initially to: 
              FOR EACH RowObject INDEXED-REPOSITION
            If this needs to be changed to turn off INDEXED-REPOS on the 
            RowObject query, the container creating this SDO can override
            createObjects and set DataQueryString to:
              FOR EACH RowObject
------------------------------------------------------------------------------*/
  {set DataQueryString pcQueryString}.
  RETURN TRUE.   /* Function return value. */

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setDatasetName) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setDatasetName Procedure 
FUNCTION setDatasetName RETURNS LOGICAL
  ( pcName AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:  Set the instance name of the object's DatasetSource.
   Params:  <none>
------------------------------------------------------------------------------*/
  {set DatasetName pcName}.
  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setDatasetSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setDatasetSource Procedure 
FUNCTION setDatasetSource RETURNS LOGICAL
  ( phSource AS HANDLE ) :
/*------------------------------------------------------------------------------
  Purpose:  Returns the handle of the object's DaatasetSource.
   Params:  <none>
------------------------------------------------------------------------------*/
  {set DatasetSource phSource}.
  RETURN TRUE. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setDataTable) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setDataTable Procedure 
FUNCTION setDataTable RETURNS LOGICAL
  ( pcDataTable AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:  
    Notes:  
------------------------------------------------------------------------------*/
  {set DataTable pcDataTable}.
  RETURN TRUE. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setFetchOnOpen) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setFetchOnOpen Procedure 
FUNCTION setFetchOnOpen RETURNS LOGICAL
  ( pcFetchOnOpen AS CHAR ) :
/*------------------------------------------------------------------------------
  Purpose: Set whether a fetch should occur when the query is opened.                
Parameter: pcFetchOnOpen  -  
            Blank - don't do any fetch  
            First - run fetchFirst
            Last  - run FethcLast 
                    (not directly supported in the framework).       
            ?     - default         
    Notes: A stored value of undefined means use default (see getFetchOnOpen) 
------------------------------------------------------------------------------*/
  &SCOPED-DEFINE xpFetchOnOpen 
  {set FetchOnOpen pcFetchOnOpen}.
  &UNDEFINE xpFetchOnOpen 
  
  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setFillBatchOnRepos) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setFillBatchOnRepos Procedure 
FUNCTION setFillBatchOnRepos RETURNS LOGICAL
  ( plFlag AS LOGICAL ) :
/*------------------------------------------------------------------------------
  Purpose:  Sets the flag on or off which indicates whether fetchRowIdent
            will fetch enough rows to fill a batch when repositioning to the 
            (or near the) end of a dataset
   Params:  plFlag AS LOGICAL  -- If true, the code will prompt.
------------------------------------------------------------------------------*/

  {set fillBatchOnRepos plFlag}.
  RETURN TRUE.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setFilterActive) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setFilterActive Procedure 
FUNCTION setFilterActive RETURNS LOGICAL
  ( plFilterActive AS LOGICAL ) :
/*------------------------------------------------------------------------------
  Purpose: Set a flag to indicate that filter is active.  
    Notes: the getFfilerActive also checks QueryColumns   
------------------------------------------------------------------------------*/  
  &SCOPED-DEFINE xpFilterActive 
  {set FilterActive plFilterActive}.
  &UNDEFINE xpFilterActive 
     
  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setFilterAvailable) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setFilterAvailable Procedure 
FUNCTION setFilterAvailable RETURNS LOGICAL
  ( plFilterAvailable AS LOGICAL ) :
/*------------------------------------------------------------------------------
  Purpose: Set a flag to indicate that filter is available.
    Notes: ALso update the FilterWindow property for StartFilter. 
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hFilterSource     AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cFilterWindow     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hFilterContainer  AS HANDLE     NO-UNDO.
  DEFINE VARIABLE hMyContainer      AS HANDLE     NO-UNDO.
  
  &SCOPED-DEFINE xpFilterAvailable 
  {set FilterAvailable plFilterAvailable}.
  &UNDEFINE xpFilterAvailable 

  /* This info is used by startFilter */
  {get FilterWindow cFilterWindow}.
  IF cFilterWindow = '':U  OR cFilterWindow = ? THEN
  DO:
    {get FilterSource hFilterSource}.
    IF VALID-HANDLE(hFilterSource) THEN
    DO:
      {get ContainerSource hFilterContainer hFilterSource}.
      {get ContainerSource hMyContainer}.    
      IF hMyContainer <> hFilterContainer AND VALID-HANDLE(hFilterContainer) THEN
        {set FilterWindow hFilterContainer:FILE-NAME}.
    END.
  END.

  /* The toolbar is subscribing to filteravailble from the navigation link*/
  IF plFilterAvailable THEN 
     PUBLISH "FilterState":U FROM TARGET-PROCEDURE ("FilterAvailable":U).
   
  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setFilterSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setFilterSource Procedure 
FUNCTION setFilterSource RETURNS LOGICAL
  ( phObject AS HANDLE ) :
/*------------------------------------------------------------------------------
  Purpose:  Sets the FilterSource link value.
   Params:  phObject AS HANDLE -- procedure handle of this object's FilterSource 
------------------------------------------------------------------------------*/

  {set FilterSource phObject}.
  RETURN TRUE.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setFilterWindow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setFilterWindow Procedure 
FUNCTION setFilterWindow RETURNS LOGICAL
  ( pcObject AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:  Sets the FilterWindow property which is the name of the filter 
            container.
   Params:  pcObject -- Procedure name
    Notes:  
------------------------------------------------------------------------------*/
  {set FilterWindow pcObject}.
  RETURN TRUE.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setFirstRowNum) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setFirstRowNum Procedure 
FUNCTION setFirstRowNum RETURNS LOGICAL
  ( piRowNum AS INTEGER ) :
/*------------------------------------------------------------------------------
  Purpose:  sets the FirstRowNum property of the SDO.
   Params:  piRowNum AS INTEGER
    Notes:  
------------------------------------------------------------------------------*/

  {set FirstRowNum piRowNum}.
  RETURN TRUE.   

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setForeignFields) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setForeignFields Procedure 
FUNCTION setForeignFields RETURNS LOGICAL
  ( pcFields AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:     Sets the Foreign Fields property of the object.
  
  Parameters: pcFields - comma-separated paired list of this objects db fields 
                         and the RowObject fields they map to in the parent.
      Notes:   In the case where the current ForeignFields already have been 
               used to add the key to the query, the fieldnames and the values 
               will be removed from the QueryString by this call.
------------------------------------------------------------------------------*/
  {fn removeForeignKey}.
  
  &SCOPED-DEFINE xpForeignFields
  {set ForeignFields pcFields}.
  &UNDEFINE xpForeignFields
  
  RETURN TRUE.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setForeignValues) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setForeignValues Procedure 
FUNCTION setForeignValues RETURNS LOGICAL
  ( pcValues AS CHAR ) :
/*------------------------------------------------------------------------------
  Purpose: Stores the ForeignValues 
    Notes: Internal use only, defined as function to be able to be set
           as part of context when join is done on server.
------------------------------------------------------------------------------*/
  {set ForeignValues pcValues }.
  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setIndexInformation) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setIndexInformation Procedure 
FUNCTION setIndexInformation RETURNS LOGICAL
  (pcInfo AS CHAR) :
/*------------------------------------------------------------------------------
  Purpose: Store the IndexInformation  
    Notes: See getIndexInformation 
------------------------------------------------------------------------------*/
  &SCOPED-DEFINE xpIndexInformation
  {set IndexInformation pcInfo}.
  &UNDEFINE xpIndexInformation
 
  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setLargeColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setLargeColumns Procedure 
FUNCTION setLargeColumns RETURNS LOGICAL
  ( pcLargeColumns AS CHAR) :
/*------------------------------------------------------------------------------
  Purpose:    Sets the comma-delimited list of columns of large data-types
  Parameters: pcLargeColumns - comma-delimited list of column names
       Notes: Normally set from the first request to getLargeColumns   
------------------------------------------------------------------------------*/
  &SCOPED-DEFINE xpLargeColumns
  {set LargeColumns pcLargeColumns}.
  &UNDEFINE xpLargeColumns
  
  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setLastRowNum) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setLastRowNum Procedure 
FUNCTION setLastRowNum RETURNS LOGICAL
  ( piLastRowNum AS INTEGER ) :
/*------------------------------------------------------------------------------
  Purpose: Sets the LastRowNum property in an SDO
   Params: piLastRowNum -- Rownum of the last row
    Notes:
------------------------------------------------------------------------------*/
  
  {set LastRowNum piLastRowNum}.
                              
  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setNavigationSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setNavigationSource Procedure 
FUNCTION setNavigationSource RETURNS LOGICAL
  ( pcObject AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:     Sets the NavigationSource link value.
  
  Parameters:  
    pcObject - comma delimited string of the objects which should be made this 
               object's Navigation-Source.
------------------------------------------------------------------------------*/

  {set NavigationSource pcObject}.
  RETURN TRUE.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setOpenOnInit) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setOpenOnInit Procedure 
FUNCTION setOpenOnInit RETURNS LOGICAL
  ( plOpen AS LOGICAL ) :
/*------------------------------------------------------------------------------
  Purpose:     Sets the flag indicating whether the object's database query 
               should be opened automatically when the object is initialized -
               yes by default.
  
  Parameters:
    plOpen - True if the database query should be opened at initialization.
------------------------------------------------------------------------------*/

  {set OpenOnInit plOpen}.
  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setPrimarySDOSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setPrimarySDOSource Procedure 
FUNCTION setPrimarySDOSource RETURNS LOGICAL
  ( phObject AS HANDLE ) :
/*------------------------------------------------------------------------------
  Purpose:  Sets the PrimarySDOSource link value.
   Params:  phObject AS HANDLE -- procedure handle of this object's PrimarySDOSource 
------------------------------------------------------------------------------*/

  {set PrimarySDOSource phObject}.
  RETURN TRUE.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setPromptColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setPromptColumns Procedure 
FUNCTION setPromptColumns RETURNS LOGICAL
  (INPUT pcPromptColumns AS CHARACTER) :
/*------------------------------------------------------------------------------
  Purpose:  To set the a list of field values to display when prompted by
            a dialog box.  This is initially being used by confirmDelete
            in datavis.p
    Notes:  
    
          Values:
          '(NONE)'    - This is the default for security reasons.
          '(ALL)'     - All columns in the SDO.
          'fieldlist' - A comma delimited list of field names
          
    
------------------------------------------------------------------------------*/
  &SCOPED-DEFINE xpPromptColumns
  {set PromptColumns pcPromptColumns}.
  &UNDEFINE xpPromptColumns
  
  RETURN YES.   /* Function return value. */

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setPromptOnDelete) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setPromptOnDelete Procedure 
FUNCTION setPromptOnDelete RETURNS LOGICAL
  (INPUT plPrompt AS LOGICAL) :
/*------------------------------------------------------------------------------
  Purpose: Used to set whether or not the user is to be prompted 
           for a delete action to execute
    Notes:     
------------------------------------------------------------------------------*/
  {set PromptOnDelete plPrompt}.
  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setQueryColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setQueryColumns Procedure 
FUNCTION setQueryColumns RETURNS LOGICAL
  ( cQueryColumns AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:  
    Notes:  
------------------------------------------------------------------------------*/
  {set QueryColumns cQueryColumns}.
  RETURN TRUE.   /* Function return value. */

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setQueryPosition) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setQueryPosition Procedure 
FUNCTION setQueryPosition RETURNS LOGICAL
  ( pcPosition AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:     Sets the Query Position property, and publishes an event to 
               tell others.
  
  Parameters:
    pcPosition - query position possible values are:
                 'FirstRecord', 'LastRecord', 'NotFirstOrLast' and 
                 'NoRecordAvailable'
------------------------------------------------------------------------------*/

    /* The property name does not have a property preprocessor
       to prevent it from being "set" directly, so that the event will 
       always be published, so the {set} syntax is not used. */

  &SCOPED-DEFINE xpQueryPosition
  {set QueryPosition pcPosition}.
  &UNDEFINE xpQueryPosition
  
  PUBLISH 'queryPosition':U FROM TARGET-PROCEDURE (pcPosition).
  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setQuerySort) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setQuerySort Procedure 
FUNCTION setQuerySort RETURNS LOGICAL
  ( pcSort AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:     Sets or resets the sorting criteria (BY phrase) of the database
               query and stores the result in the QueryString property.
  Parameters:
    pcSort   - new sort (BY) clause.
             - [BY ] column [DESCENDING | TOGGLE ] [ BY ... ]  
             - TOGGLE sort option specifies that the column should be sorted
               opposite of the current sort. The option can be specified for 
               any column in the sort.      
             - Supports RowObject as qualifier to specify the sort with the 
               data object's column names.                    
  Notes:     - Use resetSort to apply sort criteria AND reopen the query if 
               it already is opened.
------------------------------------------------------------------------------*/
 DEFINE VARIABLE cQueryString      AS CHARACTER  NO-UNDO.

 {get QueryString cQueryString}.
 
 IF cQueryString = "":U THEN
   {get QueryStringDefault cQueryString}.

 cQueryString = DYNAMIC-FUNCTION('newQuerySort':U IN TARGET-PROCEDURE,
                                cQueryString,
                                pcSort). /* db columns */
 IF cQueryString > '':U THEN
 DO:
   {set QueryString cQueryString}.
   RETURN TRUE. 
 END.
    
 RETURN FALSE.
    
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setQueryString) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setQueryString Procedure 
FUNCTION setQueryString RETURNS LOGICAL
  (pcQueryString AS CHAR) :
/*------------------------------------------------------------------------------
  Purpose:     Sets the QueryString property used as working storage for the
               addQueryString, assignQuerySelection, removeQuerySelection, 
               setQueryWhere, setQuerySort etc.   
  Parameters:  pcQueryString - The string to store
        Note:  NEVER set this directly. It should only be maintained by other
               query manipulation methods.  
------------------------------------------------------------------------------*/
  {set QueryString pcQueryString}.
  RETURN TRUE. 
  
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setRebuildOnRepos) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setRebuildOnRepos Procedure 
FUNCTION setRebuildOnRepos RETURNS LOGICAL
  ( plRebuild AS LOGICAL ) :
/*------------------------------------------------------------------------------
  Purpose:  Sets the Rebuild-On-Reposition flag
   Params:  plRebuild AS LOGICAL; if true, the RowObject temp-table will
            be rebuilt when a reposition is done which is outside the bounds
            of the current result set.
------------------------------------------------------------------------------*/
  {set RebuildOnRepos plRebuild}.
  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setRowObject) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setRowObject Procedure 
FUNCTION setRowObject RETURNS LOGICAL
  ( phRowObject AS HANDLE ) :
/*------------------------------------------------------------------------------
  Purpose:  
    Notes:  
------------------------------------------------------------------------------*/
  {set RowObject phRowObject}.
  RETURN TRUE.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setRowObjectState) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setRowObjectState Procedure 
FUNCTION setRowObjectState RETURNS LOGICAL
  ( pcState AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:  Sets the RowObjectState property, which keeps track of whether
            there are uncommitted updates in the object. 
  Parameters: pcState - Can only be 'RowUpdated' OR 'NoUpdates'
    Notes:    When we get 'NoUpdates' and we have a Commit Panel; our 
              datasource have suppressed any 'UpdateComplete' events
              they have received until we are committed, so we send that
              updatestate event now.
            - As of current this might as well have been handled directly in 
              the rowObjectState event as we do not store the value. We would
              need to store it if we ever wanted to allow the UI to commit
              changes from several datasets though. We also need to store it 
              when/if we support no dataset TT based Dataviews.
------------------------------------------------------------------------------*/
  DEFINE VARIABLE lCommit AS LOG    NO-UNDO INIT ?.

  /* currently not needed, since we only support commit/submit across one 
     single entity 
  &SCOPED-DEFINE xpRowObjectState
  {set RowObjectState pcState}.
  &UNDEFINE xpRowObjectState
  */
  
  PUBLISH 'rowObjectState':U FROM TARGET-PROCEDURE (pcState).
  
  IF pcState = 'NoUpdates':U THEN
  DO:
    {get AutoCommit lCommit}.
    IF lCommit = NO THEN
      PUBLISH 'updateState':U FROM TARGET-PROCEDURE ('UpdateComplete':U).
  END.

  /* Tell container */ 
  PUBLISH 'UpdateActive':U FROM TARGET-PROCEDURE (pcState <> 'NoUpdates':U).

  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setRowsToBatch) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setRowsToBatch Procedure 
FUNCTION setRowsToBatch RETURNS LOGICAL
  ( piRows AS INTEGER ) :
/*------------------------------------------------------------------------------
  Purpose:     Sets the number of rows to be transferred from the database query
               into the RowObject temp-table at a time.
 
  Parameters:
    INPUT piRows - The desired number of RowObject records in a batch (default 
                   is 200)
  
  Notes:       Setting RowsToBatch to 0 indicates that ALL records should be 
               read.
------------------------------------------------------------------------------*/ 
  {set RowsToBatch piRows}.
  RETURN TRUE.
   
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setTables) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setTables Procedure 
FUNCTION setTables RETURNS LOGICAL
  ( pcTables AS CHAR) :
/*------------------------------------------------------------------------------
   Purpose: The Tables defines the object's view of data.    
     Notes: The names in the list references to the tables as defined in the
            object and referenced in the query, so each entry must be unique. 
  Dbaware (does not overrride, but uses tables differently)    
          - The names may be buffer names that differ from the actual physical 
            names.
          - The physical names is defined in the corresponding PhysicalTables 
            property.  
          - Qualified with database name if the query is defined with dbname.
          - From 9.1B this property is a design time property while it earlier 
            was resolved from the actual query.           
          - Several other properties have table delimiters and are depending of 
            the design time order of this property.              
          - The web2/webprop.i UNDEFINEs xpTables since it need to override 
            getTables()    
------------------------------------------------------------------------------*/
  {set Tables pcTables}.
  RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setToggleDataTargets) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setToggleDataTargets Procedure 
FUNCTION setToggleDataTargets RETURNS LOGICAL
  ( plToggleDataTargets AS LOGICAL ) :
/*------------------------------------------------------------------------------
  Purpose: Set to false if dataTargets should not be toggled on/of in 
           LinkStatebased based on the passed 'active' or 'inactive' parameter            
    Notes:  
------------------------------------------------------------------------------*/
  DEFINE VARIABLE ltoggle AS LOGICAL    NO-UNDO.
  {set ToggleDataTargets plToggleDataTargets}.

  RETURN TRUE. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setTransferChildrenForAll) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setTransferChildrenForAll Procedure 
FUNCTION setTransferChildrenForAll RETURNS LOGICAL
  (plTransferChildrenForAll AS LOGICAL) :
/*------------------------------------------------------------------------------
  Purpose: This flag decides whether children for all records (of the batch) is 
           to be transferred from the database. 
    Notes: Currently only supported for read event handlers during a fetch. 
           The child SDO is only left with temp-table records for one parent 
           when the fetch*batch is finished.   
------------------------------------------------------------------------------*/
  {set TransferChildrenForAll plTransferChildrenForAll}.
  RETURN TRUE.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setUpdatableColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setUpdatableColumns Procedure 
FUNCTION setUpdatableColumns RETURNS LOGICAL
  (pcColumns AS CHAR) :
/*------------------------------------------------------------------------------
  Purpose:     Set the comma delimited list of the Updatable Columns for the
               DataView.
  Parameters:  pcColumns 
  ------------------------------------------------------------------------------*/
  {set UpdatableColumns pcColumns}.
  RETURN TRUE.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-setUpdateSource) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION setUpdateSource Procedure 
FUNCTION setUpdateSource RETURNS LOGICAL
  ( pcObject AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:  Sets the UpdateSource link value.
   Params:  phObject AS CHAR -- List of procedure handles of this object's 
                                UpdateSources
                                 
------------------------------------------------------------------------------*/
  {set UpdateSource pcObject}.
  RETURN TRUE.
END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-showBI) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION showBI Procedure 
FUNCTION showBI RETURNS LOGICAL
  ( /* parameter-definitions */ ) :
/*------------------------------------------------------------------------------
  Purpose:  
    Notes:  
------------------------------------------------------------------------------*/
 DEFINE VARIABLE h AS HANDLE     NO-UNDO.
 h = {fn dataContainerHandle}.
 RUN showBI IN h ({fn getObjectName}).
 RETURN FALSE.   /* Function return value. */

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-sortExpression) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION sortExpression Procedure 
FUNCTION sortExpression RETURNS CHARACTER
  ( pcQueryString AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose: Returns the sort expression of the passed querystring 
    Notes: Includes the first BY also (getQuerySort does not) and 
           removes extra spaces.
------------------------------------------------------------------------------*/
  DEFINE VARIABLE iByPos      AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cExpression AS CHARACTER  NO-UNDO.
  
  /* Any BY ? */ 
  iByPos = INDEX(pcQueryString + " ":U," BY ":U).

  IF iByPos > 0 THEN
  DO:
    /* Trim away blanks and period and remove indexed-reposition */
    cExpression = REPLACE(TRIM(SUBSTR(pcQueryString,iByPos)," .":U),
                          ' INDEXED-REPOSITION':U,
                          '':U).
    /* Remove extra blanks (this may be used to compare new and old 
       sort expression so it need to be consistent)*/
    DO WHILE INDEX(cExpression,'  ':U) > 0:
      cExpression = REPLACE(cExpression,'  ':U,' ':U).
    END.
  END.

  RETURN cExpression.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-submitData) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION submitData Procedure 
FUNCTION submitData RETURNS LOGICAL
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: Submit ALL dataset changes to the server/service  
    Notes: External visual callers should call commitTransaction, which 
           does the necessary check for unsaved changes before calling
           this.             
------------------------------------------------------------------------------*/
  DEFINE VARIABLE hDataset       AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cEntityName    AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cDataTable     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE lOk            AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cContext       AS CHARACTER  NO-UNDO.

  &SCOPED-DEFINE xp-assign
  {get DatasetSource hDataset}
  {get BusinessEntity cEntityName}
  {get DataTable cDataTable}
  .
  &UNDEFINE xp-assign
 
  cContext = {fn obtainContextForServer}.
  RUN submitDataset IN {fn getDataContainerHandle} 
                                 (hDataSet,
                                  cEntityName, 
                                  cDataTable,
                                  cContext,
                                  OUTPUT lOk).

  cContext = {fnarg tableContext cDataTable hDataset}. 
  IF cContext > '' THEN
    {fnarg applyContextFromServer cContext}.

  IF lOk THEN 
    {set rowObjectState 'noUpdates':U}.
  

  RETURN lok. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-submitRow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION submitRow Procedure 
FUNCTION submitRow RETURNS LOGICAL
  ( pcRowIdent AS CHARACTER, pcValueList AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:     Accepts a list of changed values for a row and ASSIGNs them,
               returning FALSE if any errors occur. 
               This is done only to the RowObject Temp-Table; 
               committing the changes back to the database is 
               a separate step, which will be invoked from here if 
               AutoCommit is set on.
 
  Parameters:
    INPUT pcRowIdent  - "key" with row to update.
                         The RowObject ROWID, typically derrived from the visual 
                         DataTarget's Rowident property
                      - ?  indicates current record.    
    INPUT pcValueList - CHR(1) delimited list of alternating column names 
                        and values to be assigned.
 Notes: All current default usage of this API is intended to save data to 
        current record, although the visual Rowident is passed.                       
------------------------------------------------------------------------------*/
  DEFINE VARIABLE lNewMode       AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cErrorMessages AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cUpdColumns    AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hRowObject     AS HANDLE     NO-UNDO.
  DEFINE VARIABLE rRowObject     AS ROWID      NO-UNDO.
  DEFINE VARIABLE lAutoCommit    AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE lSuccess         AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cState         AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE lDummy         AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE iCol           AS INTEGER    NO-UNDO.
  DEFINE VARIABLE cColumnref     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cDataTable     AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hDataSource    AS HANDLE     NO-UNDO.
  DEFINE VARIABLE cForeignValues AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE cForeignFields AS CHARACTER  NO-UNDO.
  DEFINE VARIABLE hDatasetSource AS HANDLE     NO-UNDO.
  DEFINE VARIABLE lNewRow        AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE cValue         AS CHARACTER  NO-UNDO.

  rRowObject = TO-ROWID(ENTRY(1, pcRowIdent)) NO-ERROR.

  &SCOPED-DEFINE xp-assign
  {get RowObject hRowObject}
  {get DataTable cDataTable}
  {get DatasetSource hDatasetSource}
  {get DataSource hDataSource}
  .     
  &UNDEFINE xp-assign
  
  IF NOT VALID-HANDLE(hDatasetSource) THEN
    RETURN FALSE.

  /* ? means current.. */
  IF pcRowident = ? THEN
    pcRowident = STRING(hRowObject:ROWID).  
  
  IF NOT hRowObject:AVAILABLE OR rRowObject NE hRowObject:ROWID THEN 
  DO:
    hRowObject:FIND-BY-ROWID(rRowObject) NO-ERROR.
    IF NOT hRowObject:AVAILABLE THEN
    DO:
      /* Add the update cancelled message */
      RUN addMessage IN TARGET-PROCEDURE({fnarg messageNumber 15},?,?).
      /* Add the ... not found message .. */ 
      RUN addMessage IN TARGET-PROCEDURE
         (SUBSTITUTE(DYNAMIC-FUNCTION('messageNumber':U IN TARGET-PROCEDURE,29),
                    {fn getTables},
                    'ROWID ':U 
                     + (IF pcRowident = ? THEN '?':U ELSE pcRowident)
                    ),
          ?, 
          ?).
      RETURN FALSE.
    END.
  END. /* not avail or passed rowid mismatch */ 

  lSuccess = TRUE.  

  /* Verify that they're not trying to update a non-updatable field. 
     Also qualify unqualified columns with datatable  */
  {get UpdatableColumns cUpdColumns}.
  DO iCol = 1 TO NUM-ENTRIES(pcValueList,CHR(1)) BY 2:
    cColumnRef = ENTRY(iCol, pcValueList,CHR(1)).
    IF INDEX(cColumnRef,'.':U) = 0 THEN 
    DO:
      cColumnRef = cDataTable + '.' + cColumnRef.
      ENTRY(iCol,pcValueList,CHR(1)) = cColumnRef.
    END.
    IF LOOKUP(cColumnRef, cUpdColumns) = 0 THEN
    DO:
      lSuccess = FALSE.
      RUN addMessage IN TARGET-PROCEDURE (SUBSTITUTE({fnarg messageNumber 54}, cColumnRef), cColumnRef, ?).
    END. /* lookup column in upd = 0 */
  END. /* iColNum = 1 TO NUM-ENTRIES(p */
  
  /* Assign Foreign Key values if needed for new records. */
  IF lSuccess AND VALID-HANDLE(hDataSource) THEN
  DO:
    &SCOPED-DEFINE xp-assign
    {get ForeignFields cForeignFields}
    {get ForeignValues cForeignValues}
    {get NewRow lNewRow}
    .
    &UNDEFINE xp-assign
    IF lNewRow THEN
    DO:
      DO iCol = 1 TO NUM-ENTRIES(cForeignFields) BY 2:
        /* if foreignfield not already in list add foreignvalue */
        ASSIGN
          cColumnRef = ENTRY(iCol,cForeignFields)
          cValue     = DYNAMIC-FUNCTION('mappedEntry':U IN TARGET-PROCEDURE,
                                        cColumnRef,
                                        pcValueList,
                                        TRUE, /* after */
                                        CHR(1)).
        IF cValue = ? THEN
          ASSIGN cValue       = ENTRY(INT((iCol + 1) / 2), cForeignValues, CHR(1)) 
                 pcValueList  = cColumnRef + CHR(1) 
                                + (IF cValue = ? THEN "?" ELSE cValue)
                                + (IF pcValueList = "":U THEN "":U ELSE CHR(1)) 
                                + pcValueList.
      END. /* do iCol */
    END. /* new row*/
  END. /* valid datasource */

  IF lSuccess THEN
    lSuccess =  DYNAMIC-FUNCTION('updateRow':U IN hDatasetSource,
                                cDataTable,
                                {fn getKeyWhere},
                                 pcValueList).

  IF lSuccess THEN 
  DO:
    &SCOPED-DEFINE xp-assign 
    {get NewMode lNewMode}
    {get AutoCommit lAutoCommit}
    .
    &UNDEFINE xp-assign
    
    IF lAutoCommit THEN 
       /* Go ahead with the DB transaction now. */
      lSuccess  = {fn submitData}.
    ELSE 
      {set RowObjectState 'RowUpdated':U}.

    IF lSuccess THEN
    DO: 
       &SCOPED-DEFINE xp-assign
      {set DataModified FALSE}
      {set CurrentRowid ?} /* ensure newmode = false */
      .
      &UNDEFINE xp-assign
      
      {fnarg openDataQuery STRING(rRowObject)}.
      IF hRowObject:ROWID <> rRowObject THEN
        RUN showMessageProcedure IN TARGET-PROCEDURE 
                                   (INPUT "96":U, OUTPUT lDummy).           
      cState = (IF NOT lNewMode     THEN 'SAME':U
                ELSE IF lAutoCommit THEN 'DIFFERENT':U
                /* we use 'RESET' for uncommitted new records, as this 
                   will reset panels and only reopen if child has 
                   no changes */
                ELSE                     'RESET':U).  

      RUN rowChanged IN TARGET-PROCEDURE (cState).
    END. /* lSuccess (Successful commit or not autocommit) */
  END. /* lSuccess (from string to buffer) */ 
  
  IF NOT lSuccess THEN
  DO:
    /* Add the update cancelled message */
    RUN addMessage IN TARGET-PROCEDURE({fnarg messageNumber 15},?,?).
    /* back to unchanged */
    {fnarg undoRow pcRowident}.
  END.
  
  RETURN lSuccess.  

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-undoRow) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION undoRow Procedure 
FUNCTION undoRow RETURNS LOGICAL
  ( pcRowident AS CHAR ) :
/*------------------------------------------------------------------------------
  Purpose: Undo the specified rowobject record   
           To a state of unchanged. 
Parameter: pcRowident 
               - Rowobject rowid 
               - ?  will reset current.    
    Notes: This is currently no called directly from visual objects, as they 
           do not support undo of single record.  
         - undo of deleted rows is not handled here.
         Future (discussion)  
         - undo should be action in visual, but probably avoid specific action
           in toolbar and rather extend reset or undoTransaction. 
         - reset can be extended to be incremental and do an undo if already 
           reset.
           - reset - undo - undo all 
         - undoTransaction could take single record first      
------------------------------------------------------------------------------*/
  DEFINE VARIABLE lAutoCommit      AS LOGICAL    NO-UNDO.
  DEFINE VARIABLE hContainerSource AS HANDLE     NO-UNDO.
  DEFINE VARIABLE rRowid           AS ROWID      NO-UNDO.
  DEFINE VARIABLE hRowObject       AS HANDLE     NO-UNDO.

  /* don't assume rowid as param, call matching function */ 
  IF {fnarg repositionRowobject pcRowident} THEN
  DO:
    &SCOPED-DEFINE xp-assign
    {get RowObject hRowObject}
    {set DataModified FALSE}
    .
    &UNDEFINE xp-assign
    IF hRowObject:AVAILABLE AND hRowObject:BEFORE-ROWID <> ? THEN
    DO:

      hRowObject:BEFORE-BUFFER:FIND-BY-ROWID(hRowObject:BEFORE-ROWID).
      IF hRowObject:ROW-STATE = ROW-CREATED THEN
        hRowObject:BUFFER-COPY(hRowObject:BEFORE-BUFFER). 
      ELSE DO:
        /* avoid row-updated from firing unnecessarily (core behavior/bug?) */  
        rRowid = hRowObject:ROWID.
        DO TRANSACTION:
          hRowObject:BEFORE-BUFFER:REJECT-ROW-CHANGES().
        END.
        hRowObject:FIND-BY-ROWID(rRowid) NO-ERROR. 
      END.
    END.  
  END.
  
  /* always true.. state is undone */
  RETURN TRUE. 

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

&IF DEFINED(EXCLUDE-updateLargeColumns) = 0 &THEN

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION updateLargeColumns Procedure 
FUNCTION updateLargeColumns RETURNS LOGICAL PRIVATE
  (  ) :
/*------------------------------------------------------------------------------
  Purpose: Update properties that returns information about LOB columns
Parameter: pcLargeColumns - List of columns to set in LargeColumns  
    Notes: Called from whatever id called first of getCLOB- -BLOB- or 
           -LargeColumns-  (lazy).      
           LargeDataColumns is not the sum of the other because:
          -  These properties returns the values in DataColumns order.                      
          -  LargeColumns could theoretically be set to also include other large
             columns independent of data type. 
          - PRIVATE   
------------------------------------------------------------------------------*/
    DEFINE VARIABLE cLargeColumns AS CHARACTER   NO-UNDO.
    DEFINE VARIABLE cCLOBColumns  AS CHARACTER   NO-UNDO.
    DEFINE VARIABLE cBLOBColumns  AS CHARACTER   NO-UNDO.
    
    DEFINE VARIABLE cDataColumns  AS CHARACTER   NO-UNDO.

    DEFINE VARIABLE hRowObject     AS HANDLE    NO-UNDO.
    DEFINE VARIABLE iColumn        AS INTEGER   NO-UNDO.
    DEFINE VARIABLE cColumn        AS CHARACTER NO-UNDO.
    DEFINE VARIABLE cColumnRef     AS CHARACTER NO-UNDO.
    DEFINE VARIABLE cBuffer        AS CHARACTER NO-UNDO.
    DEFINE VARIABLE cDataType      AS CHARACTER NO-UNDO.
    DEFINE VARIABLE hDataSetSource AS HANDLE    NO-UNDO.
    DEFINE VARIABLE lHasLobs       AS LOGICAL   NO-UNDO.
    DEFINE VARIABLE cTable         AS CHARACTER  NO-UNDO.

    &SCOPED-DEFINE xp-assign
    {get DataColumns cDataColumns}
    {get RowObject hRowObject}
    {get DataSetSource hDataSetSource}
    {get DataTable cTable}.
    &UNDEFINE xp-assign
    
    lHasLobs = TRUE.
    
    /* Set to blank in storage when no large columns */
    IF VALID-HANDLE(hDatasetSource) 
    AND NOT {fnarg viewHasLobs cTable hDataSetSource} THEN
      lHasLobs = FALSE. 
    ELSE 
    IF VALID-HANDLE(hRowObject) AND NOT hRowObject:HAS-LOBS 
    AND INDEX(cDataColumns,'.') = 0 THEN
      lHasLobs = FALSE. 
    
    IF lHasLobs THEN 
    DO:
      DO iColumn = 1 TO NUM-ENTRIES(cDataColumns):  
        ASSIGN 
          cDataType = ''
          cColumnRef = ENTRY(iColumn,cDataColumns).
        
        IF VALID-HANDLE(hRowObject) THEN 
        DO:
          IF NUM-ENTRIES(cColumnRef,'.':U) = 2 THEN
            ASSIGN
              cBuffer = ENTRY(1,cColumnRef,'.')
              cColumn = ENTRY(2,cColumnRef,'.').
          ELSE 
            ASSIGN
              cBuffer = ''
              cColumn = cColumnRef.

           IF (cBuffer = '' OR cBuffer = hRowObject:NAME) THEN
             cDataType = hRowobject:BUFFER-FIELD(cColumn):DATA-TYPE. 
        END.

        /* We avoid calling the function for performance, unless the rowobject 
           is not valid (called before the first data request...) or 
           the column is not in rowobject.
           The dataview class will check if viewtables in the dataset
           The data class function will do an appserver call if not able to resolve 
           the request on the client!  */ 
        IF cDataType = '' THEN
          cDataType = {fnarg columnDataType cColumnRef}.
  
        IF CAN-DO('CLOB,BLOB':U,cDataType) THEN
        DO:
          cLargeColumns = cLargeColumns + ',' + cColumnRef.
          CASE cDataType:
            WHEN 'CLOB':U THEN
              cCLOBColumns  = cCLOBColumns + ',' + cColumnRef.
            WHEN 'BLOB':U THEN
              cBLOBColumns  = cBLOBColumns + ',' + cColumnRef.
          END CASE.
        END. /* clob or blob */
      END. /* do iColumn = 1 */
      
      ASSIGN
        cLargeColumns = LEFT-TRIM(cLargeColumns,',':U)
        cCLOBColumns  = LEFT-TRIM(cCLOBColumns,',':U)
        cBLOBColumns  = LEFT-TRIM(cBLOBColumns,',':U).
    END. /* lhaslobs (may) */
    
    /* Store the result (also blank), for future requests */  
    {set LargeColumns cLargeColumns}.

     /* This is normally not allowed outside of the setfunction,    
       R&D Mode... 
        These are considered READ-ONLY, so there is no set functions, but for 
        performance reasons we do want to store them. (By not defining the xp 
       in the prop file they are safe from being changed by the set include. */ 
       
    &SCOPED-DEFINE xpCLOBColumns
    {set CLOBColumns  cCLOBColumns}.
    &UNDEFINE xpCLOBColumns
    &SCOPED-DEFINE xpBLOBColumns
    {set BLOBColumns  cBLOBColumns}.
    &UNDEFINE xpBLOBColumns
 
   RETURN TRUE.

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ENDIF

